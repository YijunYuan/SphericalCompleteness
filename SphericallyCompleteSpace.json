[{"references": ["Classical.propDecidable._proof_1", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) â†’ Decidable a",
  "constCategory": "Definition"},
 {"references": ["Eq.subst"],
  "name": "heq_of_eq",
  "constType": "âˆ€ {Î± : Sort u_1} {a a' : Î±}, a = a' â†’ a â‰ a'",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max", "Eq.mp", "LE.le", "LE.le.eq_1", "le_sup_left", "congrArg"],
  "name": "Submodule.mem_sup_left",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S T : Submodule R M} {x : M}, x âˆˆ S â†’ x âˆˆ S âŠ” T",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_23",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "Exists.choose_spec",
   "Norm.norm",
   "Membership.mem",
   "Iff.mp",
   "Exists.choose",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Subtype.val",
   "DFunLike.coe",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "RingHom.id",
   "SetLike.coe_eq_coe",
   "LE.le",
   "id",
   "SphericallyCompleteSpace.orth_of_orthcomp",
   "And.left"],
  "name": "SphericallyCompleteSpace.isCompl_orthcomp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F],\n  IsCompl F (SphericallyCompleteSpace.OrthComp ğ•œ F)",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_6",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_6",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± Ã— Î² â†’ Prop}, (âˆƒ x, p x) = âˆƒ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iffâ‚‚", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_4",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  (âˆ€ (b : Î²) (a : Î±), p a â†’ f a = b â†’ q b) = âˆ€ (a : Î±), p a â†’ q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.mk.injEq",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_1",
   "Eq.trans",
   "add_add_add_comm",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Prod.fst",
   "Submodule.add_mem_sup",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_2",
   "Max.max",
   "Subtype.prop",
   "forall_congr",
   "id",
   "AddMemClass.add_mem",
   "Eq.mpr",
   "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_4",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (x_1 y : â†¥(ğ•œ âˆ™ x) Ã— â†¥F),\n  âŸ¨â†‘(x_1 + y).1 + â†‘(x_1 + y).2, â‹¯âŸ© = âŸ¨â†‘x_1.1 + â†‘x_1.2, â‹¯âŸ© + âŸ¨â†‘y.1 + â†‘y.2, â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references": ["exists_prop_of_true"],
  "name": "exists_true_left",
  "constType": "âˆ€ {p : True â†’ Prop}, Exists p â†” p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "rel_iff_cov", "LE.le", "HMul.hMul", "Subtype.val", "OfNat.ofNat"],
  "name": "mul_le_mul_iff_rightâ‚€",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Mul Î±] [inst_1 : Zero Î±] [inst_2 : Preorder Î±] {a b c : Î±} [PosMulMono Î±] [PosMulReflectLE Î±],\n  0 < a â†’ (a * b â‰¤ a * c â†” b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congrFun",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x}, f = g â†’ âˆ€ (a : Î±), f a = g a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "LE.le", "NNReal.toReal", "OfNat.ofNat"],
  "name": "NNReal.coe_mk",
  "constType": "âˆ€ (a : â„) (ha : 0 â‰¤ a), â†‘âŸ¨a, haâŸ© = a",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "LT.lt",
   "Not",
   "le_refl",
   "le_of_lt",
   "LE.le",
   "_private.Mathlib.Order.Defs.LinearOrder.0.le_of_not_gt.match_1_1",
   "lt_trichotomy"],
  "name": "le_of_not_gt",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, Â¬b < a â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.atTop", "Set", "Membership.mem", "nhds", "Filter.Tendsto"],
  "name": "IsSeqClosed",
  "constType": "{X : Type u_1} â†’ [TopologicalSpace X] â†’ Set X â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Submodule.Quotient.mk",
   "Eq.trans",
   "HasQuotient.Quotient",
   "Eq.mp",
   "Membership.mem",
   "_private.Mathlib.LinearAlgebra.Dimension.RankNullity.0.Submodule.exists_smul_notMem_of_rank_lt._simp_1_2",
   "DFunLike.coe",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "_private.Mathlib.LinearAlgebra.Dimension.RankNullity.0.Submodule.exists_smul_notMem_of_rank_lt._simp_1_1",
   "ne_eq",
   "RingHom.id",
   "LT.lt.ne",
   "funext",
   "forall_congr",
   "Eq.symm",
   "rank_eq_zero_iff",
   "propext",
   "rfl",
   "Not",
   "Submodule.mkQ",
   "binderNameHint",
   "Submodule.rank_quotient_add_rank",
   "Cardinal",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "zero_add",
   "Function.Surjective.forall",
   "Module.rank",
   "HSMul.hSMul",
   "Submodule.Quotient.mk_surjective",
   "Mathlib.Tactic.Push.not_and_eq",
   "Ne",
   "Mathlib.Tactic.Push.not_forall_eq"],
  "name": "Submodule.exists_smul_notMem_of_rank_lt",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  [HasRankNullity.{u, u_1} R] {N : Submodule R M},\n  Module.rank R â†¥N < Module.rank R M â†’ âˆƒ m, âˆ€ (r : R), r â‰  0 â†’ r â€¢ m âˆ‰ N",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "FiniteDimensional",
   "_private.SphericalCompleteness.NormedVectorSpace.Basic.0.SphericallyCompleteSpace.induction_sphericallyCompleteSpace_of_finiteDimensional",
   "Membership.mem",
   "NNReal.toReal",
   "Set.iInter",
   "Subtype.val",
   "Subspace",
   "congrArg",
   "le_rfl",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Module.finrank",
   "Dist.dist",
   "forall_congr",
   "Submodule.eq_top_of_finrank_eq",
   "Set.Nonempty",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_finiteDimensional._simp_1_1",
   "NNReal",
   "Nat.recAux",
   "Bot.bot",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Exists.casesOn",
   "Metric.closedBall",
   "Antitone",
   "NNDist.nndist",
   "LE.le",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_2",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_1",
   "id",
   "Nat.le_of_succ_le",
   "Top.top",
   "inferInstance",
   "Eq.mpr",
   "finrank_bot",
   "trivial",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_finiteDimensional",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] [SphericallyCompleteSpace ğ•œ] (E : Type u_2)\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] [IsUltrametricDist E] [FiniteDimensional ğ•œ E],\n  SphericallyCompleteSpace E",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "Int.add_one_le_of_lt",
  "constType": "âˆ€ {a b : â„¤}, a < b â†’ a + 1 â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Metric.mem_ball",
   "Set",
   "Dist.dist",
   "Membership.mem",
   "Metric.ball",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.ball x Îµ) = (dist y x < Îµ)",
  "constCategory": "Theorem"},
 {"references": ["eq_false", "one_ne_zero", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_8",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : Zero Î±] [inst_1 : One Î±] [NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_2",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "NNReal.toReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_3",
   "IsometryEquiv.isometry",
   "Set.iInter",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "forall_congr",
   "IsometryEquiv.preimage_closedBall",
   "Dist.dist",
   "funext",
   "IsometryEquiv.apply_symm_apply",
   "Eq.symm",
   "Set.preimage",
   "Set.Nonempty",
   "Set",
   "NNReal",
   "Exists.casesOn",
   "Metric.closedBall",
   "HasSubset.Subset",
   "IsometryEquiv.symm",
   "Antitone",
   "Isometry.dist_eq",
   "LE.le",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._proof_1_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_4"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
  "constType":
  "âˆ€ {E : Type u_1} {F : Type u_2} [inst : PseudoMetricSpace E] [inst_1 : PseudoMetricSpace F]\n  [he : SphericallyCompleteSpace E] (f : E â‰ƒáµ¢ F), SphericallyCompleteSpace F",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, (x â‰¥ y) = (y â‰¤ x)",
  "constCategory": "Theorem"},
 {"references": ["Nat.below", "Nat.brecOn", "Nat.ble.match_1"],
  "name": "Nat.ble",
  "constType": "â„• â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["ENNReal", "iSup", "EDist.edist", "Set", "Membership.mem"],
  "name": "Metric.ediam",
  "constType": "{X : Type u_2} â†’ [PseudoEMetricSpace X] â†’ Set X â†’ ENNReal",
  "constCategory": "Definition"},
 {"references": ["Set", "Iff.mpr", "iInf_congr_Prop"],
  "name": "Set.iInter_congr_Prop",
  "constType":
  "âˆ€ {Î± : Type u_1} {p q : Prop} {fâ‚ : p â†’ Set Î±} {fâ‚‚ : q â†’ Set Î±} (pq : p â†” q),\n  (âˆ€ (x : q), fâ‚ â‹¯ = fâ‚‚ x) â†’ Set.iInter fâ‚ = Set.iInter fâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Inv.inv", "inv_pos", "OfNat.ofNat", "propext"],
  "name": "inv_pos._simp_1",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a : Gâ‚€},\n  (0 < aâ»Â¹) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Exists.choose_spec",
   "Set",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
   "Membership.mem",
   "NNReal",
   "And.right",
   "NNReal.toReal",
   "Exists.choose",
   "Subtype.val",
   "Set.Elem",
   "Set.Countable",
   "OfNat.ofNat",
   "Prod.fst",
   "Dense",
   "HAdd.hAdd",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball",
   "Metric.closedBall",
   "lt_add_one",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_sub_closedball_not_belong",
   "HasSubset.Subset",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_strictanti",
   "Denumerable.ofNat",
   "TopologicalSpace.SeparableSpace.exists_countable_dense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.not_in_funk_chain_of_ball",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [hiud : IsUltrametricDist Î±]\n  [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] [nemp : Nonempty Î±] [hsep : TopologicalSpace.SeparableSpace Î±]\n  (hÎ±' : Denumerable â†‘â‹¯.choose) (n : â„•),\n  â†‘(Denumerable.ofNat (â†‘â‹¯.choose) n) âˆ‰\n    Metric.closedBall (SphericallyCompleteSpace.funk_chain_of_ballâœ hÎ±' (n + 1)).1\n      â†‘(SphericallyCompleteSpace.funk_chain_of_ballâœÂ¹ hÎ±' (n + 1)).2",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
   "Metric.diam_subsingleton",
   "Dense.closure_eq",
   "Eq.trans",
   "Singleton.singleton",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_radius_eq",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "Metric.diam",
   "Classical.propDecidable",
   "Denumerable.ofNat_encode",
   "Membership.mem.out",
   "Set.iInter",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_23",
   "Subtype.val",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Set.Elem",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball",
   "nonempty_denumerable_iff",
   "False.elim",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_17",
   "Eq.symm",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_15",
   "Eq.ndrec",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_3",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_8",
   "Nat.ble",
   "rfl",
   "Exists.choose_spec",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.not_in_funk_chain_of_ball",
   "NNReal",
   "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_1",
   "MulZeroClass.mul_zero",
   "Prod.snd",
   "Set.disjoint_iff_forall_ne",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_12",
   "IsUltrametricDist.dist_triangle_max",
   "Antitone",
   "Disjoint.closure_left",
   "Classical.byContradiction",
   "NNDist.nndist",
   "Set.ext",
   "Eq.mpr",
   "Set.Finite",
   "one_mul",
   "Exists.choose.congr_simp",
   "setOf",
   "Std.lt_of_lt_of_le",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_20",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_25",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_evalâ‚ƒ",
   "Metric.ball",
   "and_true",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "EmptyCollection.emptyCollection",
   "Prod.fst",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_9",
   "LT.lt.ne'",
   "congr",
   "InfSet.sInf",
   "Denumerable.ofNat",
   "propext",
   "Metric.isOpen_ball",
   "Set",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_18",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_24",
   "Set.Subsingleton",
   "OfNat.ofNat",
   "Set.Finite.isClosed",
   "HAdd.hAdd",
   "Set.univ",
   "eq_self",
   "Metric.closedBall",
   "Max.max",
   "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_22",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "congr_argâ‚‚",
   "inferInstance",
   "nndist_self",
   "Ne",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "dite",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_19",
   "closure_eq_iff_isClosed",
   "And.casesOn",
   "TopologicalSpace.SeparableSpace.exists_countable_dense",
   "lt_trans",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
   "Membership.mem",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball_decreasing",
   "HMul.hMul",
   "Mathlib.Tactic.FieldSimp.NF.cons_pos",
   "GT.gt",
   "Set.toFinite",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
   "HDiv.hDiv",
   "not_false_eq_true",
   "mul_le_iff_le_one_right",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_11",
   "Disjoint",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_13",
   "forall_congr",
   "funext",
   "csInf_le'",
   "And.left",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_21",
   "div_self",
   "Neg.neg",
   "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
   "And.right",
   "Mathlib.Tactic.FieldSimp.lt_eq_cancel_lt",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_14",
   "Exists.casesOn",
   "zero_add",
   "Set.image",
   "HasSubset.Subset",
   "Iff.mpr",
   "SphericallyCompleteSpace.IsSphericallyDense.spherically_dense",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_7",
   "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
   "id",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_5",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
   "div_one",
   "Nat.cast",
   "Eq.mp",
   "mul_div_cancel_rightâ‚€",
   "Metric.mem_closedBall",
   "le_trans",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_3",
   "NNReal.toReal",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_10",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_16",
   "Encodable.encode",
   "Set.Countable",
   "Dense",
   "congrArg",
   "Dist.dist",
   "closure",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
   "zero_lt_one",
   "Set.Nonempty.csInf_mem",
   "Set.subsingleton_iff_singleton",
   "Exists.choose",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Nonempty.some",
   "LT.lt",
   "not_lt",
   "of_eq_true",
   "le_of_lt",
   "CharP.cast_eq_zero",
   "LE.le",
   "one_add_one_eq_two",
   "Set.finite_univ_iff",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : MetricSpace Î±] [hiud : IsUltrametricDist Î±]\n  [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] [nemp : Nonempty Î±] [hsep : TopologicalSpace.SeparableSpace Î±],\n  Â¬SphericallyCompleteSpace Î±",
  "constCategory": "Theorem"},
 {"references": ["Set.iInter_subtype", "Set", "Membership.mem", "Set.Elem"],
  "name": "Set.iInter_coe_set",
  "constType":
  "âˆ€ {Î± : Type u_12} {Î² : Type u_13} (s : Set Î±) (f : â†‘s â†’ Set Î²), â‹‚ i, f i = â‹‚ i, â‹‚ (h : i âˆˆ s), f âŸ¨i, hâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "HasQuotient.Quotient",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Memâ„“p",
   "zero_memâ„“p",
   "forall_congr",
   "funext",
   "Set.range_const",
   "QuotientAddGroup.mk'",
   "rfl",
   "PreLp",
   "Memâ„“p.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Memâ„“p.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "Iff.mpr",
   "LE.le",
   "HSMul.hSMul",
   "Top.top",
   "id",
   "Eq.mpr",
   "memâ„“p_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_7",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (c : ğ•œ) (x : E),\n  (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup) âŸ¨fun x_1 â†¦ c â€¢ x, â‹¯âŸ© =\n    (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup) âŸ¨fun x_1 â†¦ c â€¢ x, â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references": ["LE.le.ge_iff_eq'", "zero_le", "OfNat.ofNat"],
  "name": "nonpos_iff_eq_zero",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddZeroClass Î±] [inst_1 : PartialOrder Î±] [CanonicallyOrderedAdd Î±] {a : Î±}, a â‰¤ 0 â†” a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "LinearIsometry.comp._proof_1",
   "LinearMap.comp"],
  "name": "LinearIsometry.comp",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {Râ‚ƒ : Type u_3} â†’\n      {E : Type u_5} â†’\n        {Eâ‚‚ : Type u_6} â†’\n          {Eâ‚ƒ : Type u_7} â†’\n            [inst : Semiring R] â†’\n              [inst_1 : Semiring Râ‚‚] â†’\n                [inst_2 : Semiring Râ‚ƒ] â†’\n                  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n                    {Ïƒâ‚â‚ƒ : R â†’+* Râ‚ƒ} â†’\n                      {Ïƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} â†’\n                        [RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] â†’\n                          [inst_4 : SeminormedAddCommGroup E] â†’\n                            [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                              [inst_6 : SeminormedAddCommGroup Eâ‚ƒ] â†’\n                                [inst_7 : _root_.Module R E] â†’\n                                  [inst_8 : _root_.Module Râ‚‚ Eâ‚‚] â†’\n                                    [inst_9 : _root_.Module Râ‚ƒ Eâ‚ƒ] â†’\n                                      (Eâ‚‚ â†’â‚›â‚—áµ¢[Ïƒâ‚‚â‚ƒ] Eâ‚ƒ) â†’ (E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚ƒ] Eâ‚ƒ",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "Set.mem_smul_set",
   "OfNat.ofNat",
   "congrArg",
   "Exists.casesOn",
   "SetLike.coe",
   "Iff.mpr",
   "SMulMemClass.smul_mem",
   "HSMul.hSMul",
   "Eq.symm",
   "id",
   "Set.smulSet",
   "Set.ext",
   "Ne",
   "Eq.mpr",
   "smul_inv_smulâ‚€",
   "And.casesOn"],
  "name": "smul_submodule_eq_self",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {E : Type u_2} [inst_1 : AddCommMonoid E] [inst_2 : _root_.Module ğ•œ E] {a : ğ•œ},\n  a â‰  0 â†’ âˆ€ (M : Submodule ğ•œ E), a â€¢ â†‘M = â†‘M",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup.le_sup_left"],
  "name": "le_sup_left",
  "constType": "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt_top_iff", "Top.top", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] {a : Î±}, (Â¬a < âŠ¤) = (a = âŠ¤)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Classical.choose_spec",
   "Not",
   "Eq.trans",
   "_private.Init.Classical.0.Classical.em.match_1_3",
   "eq_iff_iff._simp_1",
   "iff_false",
   "Classical.choose",
   "congrArg",
   "mt",
   "not_false_eq_true",
   "of_eq_true",
   "congr",
   "funext",
   "id",
   "_private.Init.Classical.0.Classical.em.match_1_1",
   "not_true_eq_false",
   "Eq.mpr",
   "Ne",
   "propext"],
  "name": "Classical.em",
  "constType": "âˆ€ (p : Prop), p âˆ¨ Â¬p",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth._simp_1_1",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Membership.mem",
   "Metric.mem_closedBall._simp_1",
   "SProd.sprod",
   "Prod.snd",
   "sup_le_iff._simp_1",
   "Prod.fst",
   "congrArg",
   "Metric.closedBall",
   "iff_self",
   "of_eq_true",
   "Set.mem_prod._simp_1",
   "congr",
   "LE.le",
   "Dist.dist",
   "Set.ext"],
  "name": "closedBall_prod_same",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] (x : Î±) (y : Î²) (r : â„),\n  Metric.closedBall x r Ã—Ë¢ Metric.closedBall y r = Metric.closedBall (x, y) r",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Subtype.mk.injEq",
   "Eq.trans",
   "Classical.propDecidable",
   "Membership.mem.out",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "Set.Elem",
   "le_csSup",
   "iSup",
   "le_ciInf",
   "RingHom.id",
   "Eq.symm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "Set.Nonempty.coe_sort",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Norm.norm",
   "Set.Nonempty.some_mem",
   "Submodule.coe_iSup_of_directed",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_13",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "Submodule.mem_iSup",
   "implies_true",
   "SetLike.coe",
   "LinearIsometry.toLinearMap",
   "lowerBounds",
   "Top.top",
   "Eq.mpr",
   "le_top._simp_1",
   "setOf",
   "IsChain",
   "LinearMap.mem_range",
   "Subspace",
   "iInf",
   "propext",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Set",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_6",
   "OfNat.ofNat",
   "Subtype.range_coe_subtype",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "Classical.not_not._simp_1",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_16",
   "Set.iUnion_coe_set",
   "eq_of_le_of_ge",
   "zorn_leâ‚€",
   "dite",
   "Set.mem_range",
   "And.casesOn",
   "Membership.mem",
   "Iff.mp",
   "Set.iUnion",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_3",
   "forall_congr",
   "funext",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "csInf_le",
   "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_10",
   "Set.Nonempty.some",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_12",
   "Exists.casesOn",
   "SphericallyCompleteSpace.IsImmediate",
   "HasSubset.Subset",
   "Iff.of_eq",
   "upperBounds",
   "Iff.mpr",
   "id",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_4",
   "Metric.infDist_eq_iInf",
   "Eq.mp",
   "LinearMap.range",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_7",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_9",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_11",
   "IsChain.directed",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Subtype.prop",
   "Dist.dist",
   "Set.iUnion_congr_Prop",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_14",
   "Metric.infDist",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "Not",
   "Set.Nonempty",
   "exists_prop_congr",
   "of_eq_true",
   "LE.le",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_8",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_5",
   "SphericallyCompleteSpace.imm_ext_nonempty",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_15"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (Eâ‚€ : Type u_3) [inst_4 : NormedAddCommGroup Eâ‚€]\n  [inst_5 : NormedSpace ğ•œ Eâ‚€] [inst_6 : IsUltrametricDist Eâ‚€] [inst_7 : SphericallyCompleteSpace Eâ‚€] (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€),\n  âˆƒ m, Maximal (fun x â†¦ x âˆˆ SphericallyCompleteSpace.imm_ext_in_sph_comp E Eâ‚€ f) m",
  "constCategory": "Theorem"},
 {"references": ["mul_le_mul_iff_rightâ‚€"],
  "name": "mul_le_mul_iff_of_pos_left",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Mul Î±] [inst_1 : Zero Î±] [inst_2 : Preorder Î±] {a b c : Î±} [PosMulMono Î±] [PosMulReflectLE Î±],\n  0 < a â†’ (a * b â‰¤ a * c â†” b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.le_succ",
  "constType": "âˆ€ (n : â„•), n â‰¤ n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "LT.lt", "div_pos_iff_of_pos_left", "propext", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.câ‚€._simp_6",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : Semifield Î±] [inst_1 : PartialOrder Î±] [PosMulReflectLT Î±] {a b : Î±} [IsStrictOrderedRing Î±],\n  0 < a â†’ (0 < a / b) = (0 < b)",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "False.elim", "propext"],
  "name": "eq_false",
  "constType": "âˆ€ {p : Prop}, Â¬p â†’ p = False",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "SMulMemClass.smul_mem",
  "constType":
  "âˆ€ {S : Type u_1} {R : outParam (Type u_2)} {M : Type u_3} {inst : SMul R M} {inst_1 : SetLike S M}\n  [self : SMulMemClass S R M] {s : S} (r : R) {m : M}, m âˆˆ s â†’ r â€¢ m âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name": "gt_iff_lt._simp_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LT Î±] {x y : Î±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references": ["Int.negOfNat.match_1", "OfNat.ofNat", "Unit"],
  "name": "Int.negOfNat",
  "constType": "â„• â†’ â„¤",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Classical.propDecidable",
   "Classical.arbitrary",
   "Exists.choose",
   "dite"],
  "name": "Function.invFun",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort u_3} â†’ [Nonempty Î±] â†’ (Î± â†’ Î²) â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_2",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": ["HSub.hSub", "Eq.ndrec"],
  "name": "Lean.Omega.Int.sub_congr",
  "constType": "âˆ€ {a b c d : â„¤}, a = b â†’ c = d â†’ a - c = b - d",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "eq_true", "zero_lt_one", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : PartialOrder Î±] [ZeroLEOneClass Î±] [NeZero 1],\n  (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl", "GT.gt"],
  "name": "gt_iff_lt",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LT Î±] {x y : Î±}, x > y â†” y < x",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "nonpos_iff_eq_zero", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_20",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddZeroClass Î±] [inst_1 : PartialOrder Î±] [CanonicallyOrderedAdd Î±] {a : Î±}, (a â‰¤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Top.top", "lp.instNormedSpace._proof_1"],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_2",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], IsScalarTower ğ•œ ğ•œ â†¥(lp (fun x â†¦ E) âŠ¤)",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iffâ‚‚", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_8",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  (âˆ€ (b : Î²) (a : Î±), p a â†’ f a = b â†’ q b) = âˆ€ (a : Î±), p a â†’ q (f a)",
  "constCategory": "Theorem"},
 {"references": ["lt_irrefl"],
  "name": "Mathlib.Tactic.Linarith.lt_irrefl",
  "constType": "âˆ€ {Î± : Type u} [inst : Preorder Î±] {a : Î±}, Â¬a < a",
  "constCategory": "Theorem"},
 {"references": ["LinearMap.range", "Membership.mem", "Iff.rfl"],
  "name": "LinearMap.mem_range",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {x : Mâ‚‚}, x âˆˆ f.range â†” âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["add_nonpos", "LE.le", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_nonpos",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] {a b : Î±}, a â‰¤ 0 â†’ b â‰¤ 0 â†’ a + b â‰¤ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod.fst",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ Î± Ã— Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat.cast",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNat_eq_true.match_1_1"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_true",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddMonoidWithOne Î±] {a b : Î±} {c : â„•},\n  Mathlib.Meta.NormNum.IsNat a c â†’ Mathlib.Meta.NormNum.IsNat b c â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["Nat.ofNat_pos'"],
  "name": "Nat.ofNat_pos",
  "constType":
  "âˆ€ {Î± : Type u_3} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] [Nontrivial Î±] {n : â„•}\n  [inst_4 : n.AtLeastTwo], 0 < OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_3} â†’ [inst : Add M] â†’ AddSubsemigroup M â†’ Set M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.isSphericallyComplete",
  "constType":
  "âˆ€ {Î± : Type u_1} {inst : PseudoMetricSpace Î±} [self : SphericallyCompleteSpace Î±] â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n  (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_6",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "ZeroMemClass.zero_mem",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  0 âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Nat.cast",
   "Eq.trans",
   "Iff.mp",
   "and_true",
   "Nat.not_le",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "eq_self",
   "gt_iff_lt._simp_1",
   "LE.le",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "HSub.hSub",
   "id",
   "Int.ofNat_sub",
   "Eq.mpr",
   "dite"],
  "name": "Lean.Omega.Int.ofNat_sub_dichotomy",
  "constType": "âˆ€ {a b : â„•}, b â‰¤ a âˆ§ â†‘(a - b) = â†‘a - â†‘b âˆ¨ a < b âˆ§ â†‘(a - b) = 0",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Array.mkArray5"],
  "name": "Lean.Syntax.node5",
  "constType":
  "SourceInfo â†’ SyntaxNodeKind â†’ Syntax â†’ Syntax â†’ Syntax â†’ Syntax â†’ Syntax â†’ Syntax",
  "constCategory": "Definition"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_9",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 â‰¤ â€–aâ€–) = True",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth._simp_1_2",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Classical.propDecidable",
   "HMul.hMul",
   "Submodule.span",
   "congrArg",
   "congr",
   "Set.smulSet",
   "Eq.symm",
   "Metric.infDist",
   "Eq.ndrec",
   "norm_zero",
   "Not",
   "infDist_smulâ‚€",
   "Norm.norm",
   "Set",
   "Metric.infDist_zero_of_mem",
   "SphericallyCompleteSpace.Orth",
   "smul_submodule_eq_self",
   "OfNat.ofNat",
   "norm_smul",
   "SetLike.coe",
   "of_eq_true",
   "HSMul.hSMul",
   "SphericallyCompleteSpace.smul_orth_of_orth._simp_1_1",
   "id",
   "zero_smul",
   "Eq.mpr",
   "dite"],
  "name": "SphericallyCompleteSpace.smul_orth_of_orth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x y : E} (a : ğ•œ), (x âŸ‚[ğ•œ] y) â†’ a â€¢ x âŸ‚[ğ•œ] y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "neg_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "âˆ€ {R : Type u_2} [inst : CommRing R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Subtype.mk.injEq",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "eq_true",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Submodule.add_mem_sup",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "RingHom.id",
   "Eq.symm",
   "Subtype.coe_eta",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.smul_morth_of_morth'",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "norm_zero",
   "sub_mem_comm_iff",
   "sup_of_le_right",
   "Exists.choose_spec",
   "Norm.norm",
   "sub_neg_eq_add",
   "Prod.snd",
   "true_and",
   "SphericallyCompleteSpace.eq_zero_of_morth_of_mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "SetLike.coe",
   "SetLike.coe_eq_coe",
   "SMulMemClass.smul_mem",
   "Int.negOfNat",
   "Set.ext",
   "norm_neg",
   "Eq.mpr",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_5",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "add_neg_cancel_comm",
   "and_true",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Subspace",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Submodule.mem_sup",
   "congr",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_9",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "neg_eq_iff_eq_neg",
   "Metric.notMem_of_dist_lt_infDist",
   "neg_sub",
   "HPow.hPow",
   "OfNat.ofNat",
   "not_le_of_gt",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "and_self",
   "smul_add",
   "dite",
   "And.casesOn",
   "Submodule.neg_mem",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "add_add_add_comm",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_8",
   "add_comm",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "NegMemClass.neg_mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_10",
   "Neg.neg",
   "And.right",
   "add_zero",
   "zero_add",
   "Mathlib.Tactic.Ring.atom_pf",
   "sup_of_le_left",
   "Nat.cast_zero",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "AddMemClass.add_mem",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Prod.ext_iff",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_1",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Or.resolve_right",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "DFunLike.coe",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_7",
   "congrArg",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_2",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
   "Metric.infDist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "sub_eq_sub_iff_add_eq_add",
   "eq_of_le_of_not_lt",
   "Submodule.add_eq_sup",
   "Exists.choose",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_6",
   "Mathlib.Tactic.Ring.add_congr",
   "Submodule.sub_mem_iff_left",
   "Or.casesOn",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "le_of_lt",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_16",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ğ•œ E)\n  (hxF : SphericallyCompleteSpace.MOrth ğ•œ x F) (x_1 : â†¥(ğ•œ âˆ™ x) Ã— â†¥F),\n  â€–{ toFun := fun z â†¦ âŸ¨â†‘z.1 + â†‘z.2, â‹¯âŸ©, map_add' := â‹¯, map_smul' := â‹¯,\n          invFun := â‹¯.mpr fun z â†¦ (âŸ¨â‹¯.choose, â‹¯âŸ©, âŸ¨â‹¯.choose, â‹¯âŸ©), left_inv := â‹¯, right_inv := â‹¯ }\n        x_1â€– =\n    â€–x_1â€–",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Membership.mem", "Iff.rfl"],
  "name": "Submodule.mem_inf",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M} {x : M}, x âˆˆ p âŠ“ q â†” x âˆˆ p âˆ§ x âˆˆ q",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "LT.lt", "div_pos_iff_of_pos_right", "propext", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_18",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : Semifield Î±] [inst_1 : PartialOrder Î±] [PosMulReflectLT Î±] {a b : Î±} [IsStrictOrderedRing Î±],\n  0 < b â†’ (0 < a / b) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.Subtype.Basic.0.Subtype.exists.match_1_3",
   "_private.Init.Data.Subtype.Basic.0.Subtype.exists.match_1_1"],
  "name": "Subtype.exists",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) â†” âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.neg_mem",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "eq_true",
   "Submodule.span",
   "Subtype.val",
   "Submodule.add_mem_sup",
   "HSub.hSub",
   "Eq.symm",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.smul_morth_of_morth'",
   "Eq.ndrec",
   "add_comm",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "sub_mem_comm_iff",
   "Exists.choose_spec",
   "Neg.neg",
   "And.right",
   "Prod.snd",
   "true_and",
   "SphericallyCompleteSpace.eq_zero_of_morth_of_mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "SetLike.coe",
   "SetLike.coe_eq_coe",
   "Iff.mpr",
   "id",
   "Set.ext",
   "Eq.mpr",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_5",
   "Prod.ext_iff",
   "Eq.mp",
   "and_true",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_7",
   "Subspace",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "Submodule.mem_sup",
   "congr",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
   "propext",
   "sub_eq_sub_iff_add_eq_add",
   "Set",
   "neg_eq_iff_eq_neg",
   "Submodule.add_eq_sup",
   "neg_sub",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_6",
   "Exists.choose",
   "Submodule.sub_mem_iff_left",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "and_self",
   "Max.max",
   "of_eq_true",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_13",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ğ•œ E),\n  SphericallyCompleteSpace.MOrth ğ•œ x F â†’\n    âˆ€ (t : â†¥(ğ•œ âˆ™ x) Ã— â†¥F), â‹¯.mpr (fun z â†¦ (âŸ¨â‹¯.choose, â‹¯âŸ©, âŸ¨â‹¯.choose, â‹¯âŸ©)) âŸ¨â†‘t.1 + â†‘t.2, â‹¯âŸ© = t",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ", "Set", "Membership.mem", "eq_true", "Set.mem_univ"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_2",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), (x âˆˆ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsLinearMap.map_smul",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\n  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R Mâ‚‚] {f : M â†’ Mâ‚‚},\n  IsLinearMap R f â†’ âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Classical.propDecidable",
   "iff_true",
   "eq_true",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "iff_self",
   "congr",
   "eq_false",
   "not_true_eq_false",
   "dite"],
  "name": "Lean.Grind.iff_eq",
  "constType": "âˆ€ (p q : Prop), (p â†” q) = (p = q)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "Subtype.forall._simp_1",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": ["Quotient.mk''", "QuotientAddGroup.leftRel"],
  "name": "QuotientAddGroup.mk",
  "constType":
  "{Î± : Type u_1} â†’ [inst : AddGroup Î±] â†’ {s : AddSubgroup Î±} â†’ Î± â†’ Î± â§¸ s",
  "constCategory": "Definition"},
 {"references": ["sub_mem"],
  "name": "Submodule.sub_mem",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x y : M}, x âˆˆ p â†’ y âˆˆ p â†’ x - y âˆˆ p",
  "constCategory": "Theorem"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
  "constType": "{Î± : Type u} â†’ [Semiring Î±] â†’ AddMonoidWithOne Î±",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "Eq.mp",
   "inv_smul_smulâ‚€",
   "HSMul.hSMul",
   "SphericallyCompleteSpace.smul_morth_of_morth",
   "Ne",
   "SphericallyCompleteSpace.MOrth",
   "OfNat.ofNat",
   "Subspace",
   "congrArg"],
  "name": "SphericallyCompleteSpace.smul_morth_iff_morth_of_nonzero",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ğ•œ E} {a : ğ•œ},\n  a â‰  0 â†’ (SphericallyCompleteSpace.MOrth ğ•œ x F â†” SphericallyCompleteSpace.MOrth ğ•œ (a â€¢ x) F)",
  "constCategory": "Theorem"},
 {"references": ["Ne.symm", "Top.top", "Ne", "Ne.lt_top"],
  "name": "Ne.lt_top'",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] {a : Î±}, âŠ¤ â‰  a â†’ a < âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "le_sup_iff", "LE.le", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b c : Î±}, (a â‰¤ max b c) = (a â‰¤ b âˆ¨ a â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Nat.rawCast"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : AddMonoidWithOne Î±] (n : â„•), Mathlib.Meta.NormNum.IsNat n.rawCast n",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Int.rawCast"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : Ring Î±] (n : â„¤), Mathlib.Meta.NormNum.IsInt n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Prod.fst",
   "congrArg",
   "HDiv.hDiv",
   "congr",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (n : â„¤) (e : M) {t t_n t_d : Mathlib.Tactic.FieldSimp.NF M},\n  t.eval = t_n.eval / t_d.eval â†’ ((n, e) ::áµ£ t).eval = ((n, e) ::áµ£ t_n).eval / t_d.eval",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Metric.isBounded_closedBall",
   "Metric.diam",
   "HMul.hMul",
   "Int.rawCast",
   "Membership.mem.out",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Ring.sub_pf",
   "And.left",
   "Metric.ediam",
   "NNReal",
   "Exists.casesOn",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "Set.Ioc",
   "Nat.cast_zero",
   "NNDist.nndist",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "diam_le_radius_of_ultrametric",
   "Eq.mp",
   "Metric.dist_le_diam_of_mem",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "ENNReal.toNNReal",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "eq_of_le_of_ge",
   "And.casesOn",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense"],
  "name": "SphericallyCompleteSpace.exists_dist_lt_diam_iff_isSphericallyDense",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] [hiud : IsUltrametricDist Î±],\n  SphericallyCompleteSpace.IsSphericallyDense Î± â†”\n    âˆ€ (z : Î±) â¦ƒr r' : NNRealâ¦„,\n      r' < r â†’ âˆƒ x y, x âˆˆ Metric.closedBall z â†‘r âˆ§ y âˆˆ Metric.closedBall z â†‘r âˆ§ nndist x y âˆˆ Set.Ioc r' r",
  "constCategory": "Theorem"},
 {"references":
  ["neg_eq_zero_sub", "Neg.neg", "HSub.hSub", "Eq.symm", "OfNat.ofNat"],
  "name": "zero_sub",
  "constType": "âˆ€ {G : Type u_1} [inst : SubNegMonoid G] (a : G), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "And.right",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_11",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (z : â†¥(ğ•œ âˆ™ x âŠ” F)), âˆƒ z_1 âˆˆ F, â‹¯.choose + z_1 = â†‘z",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_3",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references": ["SemilinearIsometryClass.norm_map"],
  "name": "LinearIsometry.norm_map",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup Eâ‚‚] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module Râ‚‚ Eâ‚‚] (f : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) (x : E), â€–f xâ€– = â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "SphericallyCompleteSpace.câ‚€._proof_2",
   "Norm.norm",
   "lp",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€._proof_3",
   "GT.gt",
   "GE.ge",
   "Subtype.val",
   "OfNat.ofNat",
   "ENNReal",
   "SphericallyCompleteSpace.câ‚€._proof_4",
   "SphericallyCompleteSpace.câ‚€._proof_1",
   "LE.le",
   "Top.top",
   "setOf"],
  "name": "SphericallyCompleteSpace.câ‚€",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : â„• â†’ Type u_2) â†’\n      [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)] â†’ [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] â†’ Submodule ğ•œ â†¥(lp E âŠ¤)",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.coe", "HasSubset.Subset", "Set", "InfSet.sInf", "setOf"],
  "name": "Submodule.span",
  "constType":
  "(R : Type u_1) â†’\n  {M : Type u_4} â†’\n    [inst : Semiring R] â†’ [inst_1 : AddCommMonoid M] â†’ [inst_2 : _root_.Module R M] â†’ Set M â†’ Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Submodule.eq_bot_iff",
   "Eq.trans",
   "Membership.mem",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.ne_bot_iff._simp_1_2",
   "Bot.bot",
   "OfNat.ofNat",
   "congrArg",
   "of_eq_true",
   "iff_self",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.ne_bot_iff._simp_1_1",
   "funext",
   "propext"],
  "name": "Submodule.ne_bot_iff",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), p â‰  âŠ¥ â†” âˆƒ x âˆˆ p, x â‰  0",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "GT.gt",
  "constType": "{Î± : Type u} â†’ [LT Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Int.natCast_nonneg",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_13",
  "constType": "âˆ€ (n k : â„•), k + 1 â‰¥ n + 1 â†’ Â¬k = n â†’ Â¬n â‰¤ k - 1 â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "PreLp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.câ‚€",
   "lp.instNormedSpace._proof_1"],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_5",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E],\n  âˆƒ m,\n    Maximal\n      (fun x â†¦\n        x âˆˆ\n          SphericallyCompleteSpace.imm_ext_in_sph_comp E (â†¥(lp (fun x â†¦ E) âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E)\n            (SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E))\n      m",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset", "Set", "Iff.mpr", "Inter.inter", "Set.inter_eq_right"],
  "name": "Set.inter_eq_self_of_subset_right",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, t âŠ† s â†’ s âˆ© t = t",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Iff.rfl"],
  "name": "Submodule.mem_mk",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : AddSubmonoid M} {x : M} (h : âˆ€ (c : R) {x : M}, x âˆˆ S.carrier â†’ c â€¢ x âˆˆ S.carrier),\n  x âˆˆ { toAddSubmonoid := S, smul_mem' := h } â†” x âˆˆ S",
  "constCategory": "Theorem"},
 {"references": ["rfl", "funext"],
  "name": "forall_congr",
  "constType":
  "âˆ€ {Î± : Sort u} {p q : Î± â†’ Prop}, (âˆ€ (a : Î±), p a = q a) â†’ (âˆ€ (a : Î±), p a) = âˆ€ (a : Î±), q a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "add_neg", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_neg",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsStrictOrderedRing Î±] {a b : Î±},\n  a < 0 â†’ b < 0 â†’ a + b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth._simp_1_3",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Prime",
  "constType": "â„• â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulActionSemiHomClass.map_smulâ‚›â‚—",
   "Eq.trans",
   "of_eq_true",
   "RingHom.id",
   "outParam",
   "HSMul.hSMul",
   "DFunLike.coe",
   "congrArg"],
  "name": "ContinuousLinearMap.map_smul",
  "constType":
  "âˆ€ {Râ‚ : Type u_1} [inst : Semiring Râ‚] {Mâ‚ : Type u_4} [inst_1 : TopologicalSpace Mâ‚] [inst_2 : AddCommMonoid Mâ‚]\n  {Mâ‚‚ : Type u_6} [inst_3 : TopologicalSpace Mâ‚‚] [inst_4 : AddCommMonoid Mâ‚‚] [inst_5 : _root_.Module Râ‚ Mâ‚]\n  [inst_6 : _root_.Module Râ‚ Mâ‚‚] (f : Mâ‚ â†’L[Râ‚] Mâ‚‚) (c : Râ‚) (x : Mâ‚), f (c â€¢ x) = c â€¢ f x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Eq.ndrec"],
  "name": "Submodule.mk.congr_simp",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (toAddSubmonoid toAddSubmonoid_1 : AddSubmonoid M) (e_toAddSubmonoid : toAddSubmonoid = toAddSubmonoid_1)\n  (smul_mem' : âˆ€ (c : R) {x : M}, x âˆˆ toAddSubmonoid.carrier â†’ c â€¢ x âˆˆ toAddSubmonoid.carrier),\n  { toAddSubmonoid := toAddSubmonoid, smul_mem' := smul_mem' } = { toAddSubmonoid := toAddSubmonoid_1, smul_mem' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Submodule.toAddSubmonoid",
   "Submodule.smul_mem'",
   "AddSubmonoid.toAddSubsemigroup"],
  "name": "Submodule.toSubMulAction",
  "constType":
  "{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Semiring R] â†’ [inst_1 : AddCommMonoid M] â†’ [inst_2 : _root_.Module R M] â†’ Submodule R M â†’ SubMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "ConditionallyCompleteLattice.csInf_le",
   "Membership.mem",
   "BddBelow"],
  "name": "csInf_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, BddBelow s â†’ a âˆˆ s â†’ sInf s â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mpr",
   "LE.le",
   "Membership.mem",
   "Eq.symm",
   "Submodule.mem_bot",
   "Iff.mp",
   "Bot.bot",
   "eq_bot_iff",
   "OfNat.ofNat"],
  "name": "Submodule.eq_bot_iff",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), p = âŠ¥ â†” âˆ€ x âˆˆ p, x = 0",
  "constCategory": "Theorem"},
 {"references": ["LinearMap.map_add", "DFunLike.coe", "LinearMap.map_zero"],
  "name": "LinearMap.toAddMonoidHom",
  "constType":
  "{R : Type u_1} â†’\n  {S : Type u_5} â†’\n    {Mâ‚ : Type u_9} â†’\n      {Mâ‚‚ : Type u_10} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring S] â†’\n            [inst_2 : AddCommMonoid Mâ‚] â†’\n              [inst_3 : AddCommMonoid Mâ‚‚] â†’\n                {modMâ‚ : _root_.Module R Mâ‚} â†’ {modMâ‚‚ : _root_.Module S Mâ‚‚} â†’ {Ïƒ : R â†’+* S} â†’ (Mâ‚ â†’â‚›â‚—[Ïƒ] Mâ‚‚) â†’ Mâ‚ â†’+ Mâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["LinearEquiv.ofTop._proof_2",
   "LinearEquiv.ofTop._proof_1",
   "RingHom.id",
   "Membership.mem",
   "Top.top",
   "LinearEquiv.ofTop._proof_3",
   "Submodule.subtype"],
  "name": "LinearEquiv.ofTop",
  "constType":
  "{R : Type u_1} â†’\n  {M : Type u_5} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : AddCommMonoid M] â†’ {module_M : _root_.Module R M} â†’ (p : Submodule R M) â†’ p = âŠ¤ â†’ â†¥p â‰ƒâ‚—[R] M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u â†’ Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set.Nonempty",
   "Set",
   "Antitone",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter"],
  "name": "SphericallyCompleteSpace.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    {motive : SphericallyCompleteSpace Î± â†’ Sort u} â†’\n      (t : SphericallyCompleteSpace Î±) â†’\n        ((isSphericallyComplete :\n              âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n                (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’\n                  (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty) â†’\n            motive â‹¯) â†’\n          motive t",
  "constCategory": "Definition"},
 {"references": ["left_distrib"],
  "name": "mul_add",
  "constType":
  "âˆ€ {R : Type v} [inst : Mul R] [inst_1 : Add R] [LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Unit"],
  "name": "Bool.or",
  "constType": "Bool â†’ Bool â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["Set.Nonempty", "Set", "Membership.mem", "Classical.choose"],
  "name": "Set.Nonempty.some",
  "constType": "{Î± : Type u} â†’ {s : Set Î±} â†’ s.Nonempty â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Subtype.exists", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_7",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "RingHom.id",
   "LinearMap.range",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.MOrth"],
  "name": "SphericallyCompleteSpace.IsImmediate",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [IsUltrametricDist E] â†’\n            {F : Type v} â†’\n              [inst_4 : SeminormedAddCommGroup F] â†’\n                [inst_5 : NormedSpace ğ•œ F] â†’ [IsUltrametricDist F] â†’ (E â†’â‚—áµ¢[ğ•œ] F) â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass.zero_add"],
  "name": "zero_add",
  "constType": "âˆ€ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "sup_eq_left", "Iff.mpr", "LE.le"],
  "name": "sup_of_le_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, b â‰¤ a â†’ a âŠ” b = a",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.Data.Subtype.Basic.0.Subtype.forall.match_1_1"],
  "name": "Subtype.forall",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) â†” âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.spherically_dense",
  "constType":
  "âˆ€ {Î± : Type u_1} {inst : PseudoMetricSpace Î±} [self : SphericallyCompleteSpace.IsSphericallyDense Î±] (c : Î±)\n  (r : NNReal), Metric.diam (Metric.closedBall c â†‘r) = â†‘r",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim"],
  "name": "forall_const",
  "constType":
  "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆ€ (a : Î±), b) â†” b",
  "constCategory": "Theorem"},
 {"references": ["padicNorm", "CauSeq.Completion.Cauchy", "Nat.Prime"],
  "name": "Padic",
  "constType": "(p : â„•) â†’ [Fact (Nat.Prime p)] â†’ Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_4",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [IsUltrametricDist E],\n  SphericallyCompleteSpace (â†¥(lp (fun x â†¦ E) âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_eq_left", "HasSubset.Subset", "Set", "Iff.mpr", "Inter.inter"],
  "name": "Set.inter_eq_self_of_subset_left",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, s âŠ† t â†’ s âˆ© t = s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "zero_add",
   "Eq.trans",
   "of_eq_true",
   "HSMul.hSMul",
   "zero_zsmul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.zero_termg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (x a : Î±), Mathlib.Tactic.Abel.termg 0 x a = a",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "HMul.hMul",
   "Iff.rfl",
   "OfNat.ofNat",
   "le_mul_inv_iffâ‚€",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "LE.le",
   "id",
   "Eq.mpr",
   "propext"],
  "name": "le_div_iffâ‚€",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [MulPosReflectLT Gâ‚€] {a b c : Gâ‚€},\n  0 < c â†’ (a â‰¤ b / c â†” a * c â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.mp",
  "constType": "{Î± Î² : Sort u} â†’ Î± = Î² â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.unfold_sub",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SubtractionMonoid Î±] (a b c : Î±), a + -b = c â†’ a - b = c",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.pi",
  "constType":
  "{Î¹ : Type u_1} â†’ {Î± : Î¹ â†’ Type u_2} â†’ Set Î¹ â†’ ((i : Î¹) â†’ Set (Î± i)) â†’ Set ((i : Î¹) â†’ Î± i)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "SphericallyCompleteSpace._aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___unexpand_SphericallyCompleteSpace_MOrth_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_trans"],
  "name": "le_trans",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_3",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Subtype.val", "OfNat.ofNat"],
  "name": "NNReal.toReal",
  "constType": "NNReal â†’ â„",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ",
   "Set",
   "Disjoint",
   "Set.univ_disjoint",
   "EmptyCollection.emptyCollection",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_10",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Disjoint Set.univ s = (s = âˆ…)",
  "constCategory": "Theorem"},
 {"references": ["Semigroup.mul_assoc"],
  "name": "mul_assoc",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Eq.trans",
   "add_add_add_comm",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "heq_of_eq",
   "Subtype.val",
   "Set.Elem",
   "RingHom.id",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
   "eq_of_heq",
   "Submodule.mem_span_singleton",
   "funext",
   "forall_congr",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "ContinuousLinearMap.map_smul",
   "And.left",
   "rfl",
   "Submodule.toSubMulAction",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Exists.choose_spec",
   "Norm.norm",
   "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "Submodule.smul_mem",
   "And.right",
   "Mathlib.Tactic.Abel.term_add_constg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "map_add",
   "zero_add",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.Abel.term_atomg",
   "Exists.choose.congr_simp",
   "Eq.mp",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "DFunLike.coe",
   "congrArg",
   "ContinuousLinearMap.map_add",
   "Subtype.prop",
   "Submodule.mem_sup",
   "congr",
   "eq_and_eq_of_add_eq_add_of_not_mem_submodule_span_singleton",
   "Mathlib.Tactic.Abel.termg",
   "Not",
   "Set.Nonempty",
   "Set",
   "smul_left_injective",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Exists.choose",
   "OfNat.ofNat",
   "Submodule.add_mem",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Max.max",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
   "of_eq_true",
   "add_assoc",
   "smul_smul",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "smul_add",
   "Ne",
   "add_smul"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (ha1 : a âˆ‰ D) {F : Type u_3}\n  [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ğ•œ F]\n  [hsc : SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) {ğ’° : Set (E â†’L[ğ•œ] F)} (hğ’° : ğ’°.Nonempty) {Îµ : â†‘ğ’° â†’ â„}\n  (hÎµ1 : âˆ€ (T : â†‘ğ’°), 0 < Îµ T) (hÎµ2 : âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V))\n  (hÎµ3 : âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–),\n  IsLinearMap ğ•œ (SphericallyCompleteSpace.rooij_lemma_4_4_T ha1 S hğ’° hÎµ1 hÎµ2 hÎµ3)",
  "constCategory": "Definition"},
 {"references":
  ["Set.rangeFactorization_injective",
   "LinearMap.range",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "RingHom.id",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Subtype.val_injective",
   "Set",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "Set.rangeFactorization_surjective",
   "Eq.casesOn",
   "HAdd.hAdd",
   "map_add",
   "Function.RightInverse",
   "LinearIsometry.toLinearMap",
   "Function.rightInverse_invFun",
   "Iff.mpr",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_2",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’â‚—áµ¢[ğ•œ] F)\n  (x y : â†¥f.range),\n  Function.invFun (Set.rangeFactorization â‡‘f) (x + y) =\n    Function.invFun (Set.rangeFactorization â‡‘f) x + Function.invFun (Set.rangeFactorization â‡‘f) y",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) â†’ [h : Decidable p] â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["dist_self_add_right",
   "HAdd.hAdd",
   "Norm.norm",
   "dist_comm",
   "Dist.dist",
   "id",
   "Eq.mpr",
   "congrArg"],
  "name": "dist_self_add_left",
  "constType":
  "âˆ€ {E : Type u_2} [inst : SeminormedAddCommGroup E] (a b : E), dist (a + b) a = â€–bâ€–",
  "constCategory": "Theorem"},
 {"references": ["setOf"],
  "name": "Set.range",
  "constType": "{Î± : Type u} â†’ {Î¹ : Sort u_1} â†’ (Î¹ â†’ Î±) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.symm",
   "id",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Eq.mpr",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Prod.fst",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons_eq_eval_of_eq_of_eq",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (r : â„¤) (x : M) {t t' l' : Mathlib.Tactic.FieldSimp.NF M},\n  t.eval = t'.eval â†’ ((r, x) ::áµ£ t').eval = l'.eval â†’ ((r, x) ::áµ£ t).eval = l'.eval",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "HDiv.hDiv",
   "Inv.inv",
   "LE.le",
   "HMul.hMul",
   "mul_le_of_le_mul_invâ‚€",
   "OfNat.ofNat"],
  "name": "mul_le_of_le_divâ‚€",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [MulPosReflectLT Gâ‚€] {a b c : Gâ‚€},\n  0 â‰¤ b â†’ 0 â‰¤ c â†’ a â‰¤ b / c â†’ a * c â‰¤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.ker",
   "Membership.mem",
   "DFunLike.coe",
   "OfNat.ofNat",
   "propext",
   "LinearMap.mem_ker"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_2",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {y : M}, (y âˆˆ f.ker) = (f y = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddSubsemigroup.mem_mk", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_5",
  "constType":
  "âˆ€ {M : Type u_1} [inst : Add M] {s : Set M} {x : M} (h_add : âˆ€ {a b : M}, a âˆˆ s â†’ b âˆˆ s â†’ a + b âˆˆ s),\n  (x âˆˆ { carrier := s, add_mem' := h_add }) = (x âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.Coeffs.ofList",
  "constType": "List â„¤ â†’ Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["le_refl", "LE.le", "id", "Eq.mpr", "congrArg"],
  "name": "le_of_eq",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, a = b â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Dist.dist",
  "constType": "{Î± : Type u_3} â†’ [self : Dist Î±] â†’ Î± â†’ Î± â†’ â„",
  "constCategory": "Definition"},
 {"references": ["HasSubset.Subset", "Set", "Iff.rfl", "setOf"],
  "name": "Set.setOf_subset_setOf",
  "constType":
  "âˆ€ {Î± : Type u} {p q : Î± â†’ Prop}, {a | p a} âŠ† {a | q a} â†” âˆ€ (a : Î±), p a â†’ q a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.mpr", "iSup_congr_Prop"],
  "name": "Set.iUnion_congr_Prop",
  "constType":
  "âˆ€ {Î± : Type u_1} {p q : Prop} {fâ‚ : p â†’ Set Î±} {fâ‚‚ : q â†’ Set Î±} (pq : p â†” q),\n  (âˆ€ (x : q), fâ‚ â‹¯ = fâ‚‚ x) â†’ Set.iUnion fâ‚ = Set.iUnion fâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "_private.Mathlib.Order.SetNotation.0.Set.mem_iInter.match_1_1",
   "Set",
   "Membership.mem",
   "Set.iInter",
   "Set.range",
   "setOf"],
  "name": "Set.mem_iInter",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, x âˆˆ â‹‚ i, s i â†” âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.not_sat_of_isImpossible",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.Constraint.not_sat'_of_isImpossible",
  "constType":
  "âˆ€ {c : Omega.Constraint}, c.isImpossible = true â†’ âˆ€ {x y : Omega.Coeffs}, Â¬c.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "le_refl",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "eq_true",
   "Submodule.span",
   "Set.iInter",
   "funext",
   "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_1",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "Set.iInter_congr_Prop",
   "Norm.norm",
   "Set.mem_range._simp_1",
   "And.right",
   "SphericallyCompleteSpace.Orth",
   "Set.singleton_subset_iff._simp_1",
   "Set.mem_iInter._simp_1",
   "Exists.casesOn",
   "SetLike.coe",
   "lt_iff_not_ge",
   "HasSubset.Subset",
   "Iff.of_eq",
   "id",
   "Set.ext",
   "Eq.mpr",
   "implies_congr_ctx",
   "setOf",
   "Submodule.nonempty",
   "Eq.mp",
   "Submodule.mem_span_singleton_self",
   "Metric.le_infDist",
   "Subspace",
   "Set.range",
   "congrArg",
   "ZeroMemClass.zero_mem",
   "congr",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "Not",
   "eq_of_le_of_not_lt",
   "Set",
   "dist_zero_right",
   "OfNat.ofNat",
   "LT.lt",
   "forall_const._simp_1",
   "Metric.infDist_lt_iff",
   "of_eq_true",
   "SetLike.mem_coe._simp_1",
   "LE.le",
   "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_2",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.morth_iff_forall_orth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ğ•œ E),\n  SphericallyCompleteSpace.MOrth ğ•œ x F â†” âˆ€ y âˆˆ F, x âŸ‚[ğ•œ] y",
  "constCategory": "Theorem"},
 {"references": ["Classical.propDecidable", "Decidable.not_and_iff_not_or_not"],
  "name": "not_and_or",
  "constType": "âˆ€ {a b : Prop}, Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b",
  "constCategory": "Theorem"},
 {"references": ["Not", "LT.lt", "left_lt_sup", "Max.max", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_6",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (a < a âŠ” b) = Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "eq_true",
   "le_of_not_gt",
   "Eq.symm",
   "Submodule.exists_smul_notMem_of_rank_lt",
   "Nat.ble",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div'",
   "inv_pos._simp_1",
   "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
   "congr_arg",
   "Set.mem_image",
   "true_and",
   "SetLike.coe",
   "one_smul",
   "gt_iff_lt._simp_1",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_14",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "CancelDenoms.add_subst",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Prod.fst",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_11",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_8",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "eq_self",
   "sub_sub",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "Ne",
   "eq_of_le_of_ge",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_15",
   "add_pos'",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
   "Membership.mem",
   "Inter.inter",
   "Right.add_pos_of_nonneg_of_pos",
   "Subtype.mk.congr_simp",
   "GT.gt",
   "GE.ge",
   "Nat.cast_pos'",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "forall_congr",
   "Mathlib.Tactic.Linarith.add_neg",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "Mathlib.Tactic.FieldSimp.subst_add",
   "add_nonneg",
   "And.right",
   "mul_add",
   "Mathlib.Tactic.Ring.mul_zero",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_6",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Module.rank",
   "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
   "AddMemClass.add_mem",
   "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "NNReal.toReal",
   "le_of_forall_pos_le_add",
   "Metric.le_infDist",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_eq_eval_of_eq_of_eq",
   "Nat.cast_nonneg'",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_10",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "Not",
   "Set.Nonempty",
   "Inv.inv",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
   "Mathlib.Tactic.Ring.cast_pos",
   "zero_lt_one",
   "Mathlib.Tactic.Ring.add_congr",
   "sub_sub_sub_cancel_right",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_congr",
   "add_assoc",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "CancelDenoms.mul_subst",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "Mathlib.Tactic.Ring.one_mul",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "Module.finrank_eq_rank'",
   "rfl",
   "Mathlib.Meta.Positivity.nat_ceil_pos",
   "Norm.norm",
   "Exists.choose_spec",
   "NNReal",
   "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
   "one_ne_zero",
   "Prod.snd",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_5",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_9",
   "Nat.rawCast",
   "one_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "dist_eq_norm",
   "Nat.cast_lt",
   "one_div",
   "Nat.ceil",
   "and_true",
   "div_pos",
   "Subspace",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_4",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "LT.lt.ne'",
   "congr",
   "Mathlib.Tactic.Ring.mul_add",
   "sub_mem",
   "propext",
   "lt_of_not_ge",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_7",
   "dist_comm",
   "OfNat.ofNat",
   "Metric.infDist_nonneg",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
   "Set.mem_of_mem_inter_left",
   "congr_argâ‚‚",
   "inferInstance",
   "antitone_nat_of_succ_le",
   "neg_neg_of_pos",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_3",
   "Mathlib.Tactic.FieldSimp.NF.cons_pos",
   "HDiv.hDiv",
   "Module.finrank",
   "Mathlib.Meta.NormNum.isNat_add",
   "funext",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_13",
   "HSub.hSub",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_2",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.FieldSimp.NF.inv_eq_eval",
   "Nat.le_ceil",
   "Neg.neg",
   "Mathlib.Tactic.Linarith.natCast_nonneg",
   "Mathlib.Tactic.Linarith.without_one_mul",
   "CancelDenoms.sub_subst",
   "Set.image",
   "inv_le_iff_one_le_mulâ‚€'",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "HSMul.hSMul",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball",
   "div_one",
   "Submodule.nonempty",
   "sub_eq_zero",
   "FiniteDimensional",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_12",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_16",
   "congrArg",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Mathlib.Tactic.FieldSimp.eq_div_of_subst",
   "Exists.choose",
   "Cardinal",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "exists_prop_congr",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "lt_mul_iff_one_lt_right'._simp_2",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (F : Subspace ğ•œ E) [sF : SphericallyCompleteSpace â†¥F]\n  [FiniteDimensional ğ•œ E], Module.finrank ğ•œ â†¥F < Module.finrank ğ•œ E â†’ âˆƒ x, x â‰  0 âˆ§ SphericallyCompleteSpace.MOrth ğ•œ x F",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_iff_eq_add'",
   "sub_eq_iff_eq_add",
   "sub_add_eq_add_sub",
   "Eq.trans",
   "eq_comm",
   "congrArg",
   "HAdd.hAdd",
   "iff_self",
   "of_eq_true",
   "congr",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "add_comm",
   "propext"],
  "name": "sub_eq_sub_iff_add_eq_add",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddCommGroup G] {a b c d : G}, a - b = c - d â†” a + d = c + b",
  "constCategory": "Theorem"},
 {"references": ["ZeroLEOneClass.zero_le_one"],
  "name": "zero_le_one",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [ZeroLEOneClass Î±], 0 â‰¤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual", "Set.Nonempty", "Set", "Set.Nonempty.csSup_mem", "Set.Finite"],
  "name": "Set.Nonempty.csInf_mem",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : ConditionallyCompleteLinearOrder Î±] {s : Set Î±}, s.Nonempty â†’ s.Finite â†’ sInf s âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter",
   "OfNat.ofNat",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Metric.closedBall",
   "Filter.atTop",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter",
   "Antitone",
   "id",
   "Eq.mpr",
   "Filter.Tendsto",
   "nhds",
   "propext"],
  "name": "SphericallyCompleteSpace.instCompleteOfSphericallyComplete",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [sc : SphericallyCompleteSpace Î±], CompleteSpace Î±",
  "constCategory": "Theorem"},
 {"references":
  ["LinearEquiv.symm._proof_1",
   "LinearEquiv.toEquiv",
   "Equiv.left_inv",
   "LinearMap.inverse",
   "LinearEquiv.toLinearMap",
   "DFunLike.coe",
   "LinearEquiv.invFun",
   "LinearEquiv.symm._proof_2",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.symm",
   "LinearEquiv.right_inv",
   "LinearEquiv.left_inv"],
  "name": "LinearEquiv.symm",
  "constType":
  "{R : Type u_1} â†’\n  {S : Type u_6} â†’\n    {M : Type u_7} â†’\n      {Mâ‚‚ : Type u_9} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring S] â†’\n            [inst_2 : AddCommMonoid M] â†’\n              [inst_3 : AddCommMonoid Mâ‚‚] â†’\n                {module_M : _root_.Module R M} â†’\n                  {module_S_Mâ‚‚ : _root_.Module S Mâ‚‚} â†’\n                    {Ïƒ : R â†’+* S} â†’\n                      {Ïƒ' : S â†’+* R} â†’\n                        {reâ‚ : RingHomInvPair Ïƒ Ïƒ'} â†’ {reâ‚‚ : RingHomInvPair Ïƒ' Ïƒ} â†’ (M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) â†’ Mâ‚‚ â‰ƒâ‚›â‚—[Ïƒ'] M",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "AddMemClass.add_mem"],
  "name": "Submodule.add_mem",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x y : M}, x âˆˆ p â†’ y âˆˆ p â†’ x + y âˆˆ p",
  "constCategory": "Theorem"},
 {"references":
  ["lt_add_of_pos_right", "AddLeftStrictMono", "zero_lt_one", "OfNat.ofNat"],
  "name": "lt_add_one",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : One Î±] [inst_1 : AddZeroClass Î±] [inst_2 : PartialOrder Î±] [ZeroLEOneClass Î±] [NeZero 1]\n  [AddLeftStrictMono Î±] (a : Î±), a < a + 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "trivial"],
  "name": "of_eq_true",
  "constType": "âˆ€ {p : Prop}, p = True â†’ p",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_7",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "âˆ€ {R : Type u_2} [inst : CommRing R] {a a' b : R}, a = a' â†’ -a' = b â†’ -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "LT.lt", "lt_iff_le_not_ge", "LE.le", "Iff.mp", "And.left"],
  "name": "le_of_lt",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, a < b â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup.add_assoc"],
  "name": "add_assoc",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_8",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) = (a âˆ§ b)",
  "constCategory": "Theorem"},
 {"references": ["Set", "IsSeqClosed", "SequentialSpace.isClosed_of_seq"],
  "name": "IsSeqClosed.isClosed",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [SequentialSpace X] {s : Set X}, IsSeqClosed s â†’ IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_5",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Submodule.mem_mk",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_3",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : AddSubmonoid M} {x : M} (h : âˆ€ (c : R) {x : M}, x âˆˆ S.carrier â†’ c â€¢ x âˆˆ S.carrier),\n  (x âˆˆ { toAddSubmonoid := S, smul_mem' := h }) = (x âˆˆ S)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "HSMul.hSMul",
   "Eq.symm",
   "add_comm",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.const_add_termg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (k : Î±) (n : â„¤) (x a a' : Î±),\n  k + a = a' â†’ k + Mathlib.Tactic.Abel.termg n x a = Mathlib.Tactic.Abel.termg n x a'",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_10",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["or_false",
   "iff_self",
   "smul_eq_zero._simp_1",
   "Eq.trans",
   "of_eq_true",
   "eq_false",
   "HSMul.hSMul",
   "Ne",
   "OfNat.ofNat",
   "congrArg"],
  "name": "smul_eq_zero_iff_left",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {r : R}\n  {m : M} [Module.IsTorsionFree R M] [IsDomain R], m â‰  0 â†’ (r â€¢ m = 0 â†” r = 0)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LE.le", "add_lt_of_neg_of_le", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsStrictOrderedRing Î±] {a b c : Î±},\n  a < 0 â†’ b â‰¤ c â†’ a + b < c",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "exists_apply_eq_apply",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} (f : Î± â†’ Î²) (a' : Î±), âˆƒ a, f a = f a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.trans",
  "constType": "âˆ€ {Î± : Sort u} {a b c : Î±}, a = b â†’ b = c â†’ a = c",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "dist_eq_norm",
   "Eq.trans",
   "Membership.mem",
   "Filter.atTop_basis",
   "IsDirectedOrder",
   "Metric.ball",
   "congrArg",
   "iff_self",
   "forall_congr",
   "funext",
   "Dist.dist",
   "Metric.mem_ball._simp_1",
   "HSub.hSub",
   "Filter.HasBasis.tendsto_iff",
   "nhds",
   "Filter.Tendsto",
   "Iff.trans",
   "Norm.norm",
   "Set",
   "Metric.nhds_basis_ball",
   "true_and",
   "OfNat.ofNat",
   "Set.mem_Iic._simp_2",
   "LT.lt",
   "Set.Ici",
   "Filter.atTop",
   "of_eq_true",
   "LE.le"],
  "name": "NormedAddCommGroup.tendsto_atTop",
  "constType":
  "âˆ€ {Î± : Type u_2} [Nonempty Î±] [inst : Preorder Î±] [IsDirectedOrder Î±] {Î² : Type u_5} [inst_2 : SeminormedAddCommGroup Î²]\n  {f : Î± â†’ Î²} {b : Î²}, Filter.Tendsto f Filter.atTop (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ âˆƒ N, âˆ€ (n : Î±), N â‰¤ n â†’ â€–f n - bâ€– < Îµ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearMap.toAddHom",
  "constType":
  "{R : Type u_14} â†’\n  {S : Type u_15} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring S] â†’\n        {Ïƒ : R â†’+* S} â†’\n          {M : Type u_16} â†’\n            {Mâ‚‚ : Type u_17} â†’\n              [inst_2 : AddCommMonoid M] â†’\n                [inst_3 : AddCommMonoid Mâ‚‚] â†’\n                  [inst_4 : _root_.Module R M] â†’ [inst_5 : _root_.Module S Mâ‚‚] â†’ (M â†’â‚›â‚—[Ïƒ] Mâ‚‚) â†’ M â†’â‚™+ Mâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "eq_true",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh",
   "Set.iInter",
   "Subtype.val",
   "quotient_norm_mk_eq",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Eq.symm",
   "QuotientAddGroup.mk'",
   "csInf_le",
   "Norm.norm",
   "NNReal",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_7",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_3",
   "Submodule.toAddSubgroup",
   "add_zero",
   "Exists.casesOn",
   "implies_true",
   "Set.image",
   "SetLike.coe",
   "IsUltrametricDist.dist_triangle_max",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_10",
   "Antitone",
   "Iff.mpr",
   "lowerBounds",
   "id",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "Eq.mpr",
   "setOf",
   "dist_eq_norm",
   "HasQuotient.Quotient",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_8",
   "Eq.mp",
   "le_trans",
   "NNReal.toReal",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_2",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_6",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_3",
   "Subtype.prop",
   "congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_4",
   "InfSet.sInf",
   "Dist.dist",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_9",
   "sup_le_iff",
   "propext",
   "dist_self",
   "Set.Nonempty",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_4",
   "Set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "StrictAnti",
   "Metric.closedBall",
   "and_self",
   "Max.max",
   "lt_add_one",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_5",
   "QuotientAddGroup.mk",
   "inferInstance",
   "antitone_nat_of_succ_le",
   "Nat.le_add_right",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh_prop"],
  "name": "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [iud : IsUltrametricDist E] [scsk : SphericallyCompleteSpace E] {F : Submodule ğ•œ E},\n  SphericallyCompleteSpace (E â§¸ F)",
  "constCategory": "Theorem"},
 {"references": ["Set.mem_setOf", "Set", "Membership.mem", "Iff.mp", "setOf"],
  "name": "Membership.mem.out",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {p : Î± â†’ Prop}, a âˆˆ {x | p x} â†’ p a",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_7",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.rawCast",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1_1",
   "Int.cast"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {n : â„¤} [inst : Ring Î±], Mathlib.Meta.NormNum.IsInt a n â†’ a = n.rawCast",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Eq.symm"],
  "name": "le_of_eq_of_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b c : Î±} [inst : LE Î±], a = b â†’ b â‰¤ c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.MOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.MOrth.eq_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ğ•œ E),\n  SphericallyCompleteSpace.MOrth ğ•œ x F = (Metric.infDist x â†‘F = â€–xâ€–)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "sub_eq_add_neg",
  "constType":
  "âˆ€ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "Iff.rfl"],
  "name": "iff_self",
  "constType": "âˆ€ (p : Prop), (p â†” p) = True",
  "constCategory": "Theorem"},
 {"references": ["add_lt_of_le_of_neg", "LT.lt", "LE.le", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_lt_of_le_of_neg",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsStrictOrderedRing Î±] {a b c : Î±},\n  b â‰¤ c â†’ a < 0 â†’ b + a < c",
  "constCategory": "Theorem"},
 {"references": ["Metric.ediam", "Set", "ENNReal.toReal_nonneg"],
  "name": "Metric.diam_nonneg",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} [inst : PseudoMetricSpace Î±], 0 â‰¤ Metric.diam s",
  "constCategory": "Theorem"},
 {"references":
  ["dist_eq_norm", "Norm.norm", "Dist.dist", "HSub.hSub", "Eq.symm"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_7",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), â€–a - bâ€– = dist a b",
  "constCategory": "Theorem"},
 {"references": ["Module.finrank_eq_rank", "FiniteDimensional"],
  "name": "Module.finrank_eq_rank'",
  "constType":
  "âˆ€ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]\n  [FiniteDimensional K V], â†‘(Module.finrank K V) = Module.rank K V",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.PropLemmas.0.forall_exists_index.match_1_1"],
  "name": "forall_exists_index",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) â†” âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_21",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LT Î±] {x y : Î±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "rfl",
  "constType": "âˆ€ {Î± : Sort u} {a : Î±}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["dist_nonneg",
   "Metric.closedBall",
   "_private.Mathlib.Topology.MetricSpace.Pseudo.Defs.0.Metric.nonempty_closedBall.match_1_1",
   "Set.Nonempty",
   "Set",
   "Dist.dist",
   "Membership.mem",
   "LE.le",
   "Metric.mem_closedBall_self",
   "OfNat.ofNat",
   "LE.le.trans"],
  "name": "Metric.nonempty_closedBall",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, (Metric.closedBall x Îµ).Nonempty â†” 0 â‰¤ Îµ",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Iff.mpr", "Nat.ceil", "OfNat.ofNat", "Nat.ceil_pos"],
  "name": "Mathlib.Meta.Positivity.nat_ceil_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] [inst_1 : LinearOrder Î±] [inst_2 : FloorSemiring Î±] {a : Î±}, 0 < a â†’ 0 < âŒˆaâŒ‰â‚Š",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_3",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "OfNat.ofNat"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["exists_and_left", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_13",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, b âˆ§ p x) = (b âˆ§ âˆƒ x, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_6",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Set.forall_mem_image",
   "Iff.trans",
   "Set.Nonempty",
   "isGLB_ciInf_set",
   "Set",
   "Membership.mem",
   "BddBelow",
   "Subtype.val",
   "Set.Elem",
   "Set.image",
   "LE.le",
   "lowerBounds",
   "iInf",
   "le_isGLB_iff"],
  "name": "le_ciInf_set_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {Î¹ : Type u_5} {s : Set Î¹} {f : Î¹ â†’ Î±} {a : Î±},\n  s.Nonempty â†’ BddBelow (f '' s) â†’ (a â‰¤ â¨… i, f â†‘i â†” âˆ€ i âˆˆ s, a â‰¤ f i)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_4",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "zero_le_one", "eq_true", "OfNat.ofNat"],
  "name": "zero_le_one._simp_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : LE Î±] [ZeroLEOneClass Î±], (0 â‰¤ 1) = True",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.rfl", "Set.Elem"],
  "name": "Set.finite_coe_iff",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Finite â†‘s â†” s.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Inter.inter", "Membership.mem", "Set.mem_inter_iff", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), (x âˆˆ a âˆ© b) = (x âˆˆ a âˆ§ x âˆˆ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_le_of_gt", "LT.lt", "Not", "LE.le", "Nat.ge_of_not_lt", "flip"],
  "name": "Nat.not_lt",
  "constType": "âˆ€ {a b : â„•}, Â¬a < b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_infinite_iff_finite", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_12",
  "constType": "âˆ€ {Î± : Sort u_1}, (Â¬Infinite Î±) = Finite Î±",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€._simp_2",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NNDist.nndist",
  "constType": "{Î± : Type u_3} â†’ [self : NNDist Î±] â†’ Î± â†’ Î± â†’ NNReal",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.byContradiction", "Classical.propDecidable"],
  "name": "Classical.byContradiction",
  "constType": "âˆ€ {p : Prop}, (Â¬p â†’ False) â†’ p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_3} â†’ [inst : AddZeroClass M] â†’ AddSubmonoid M â†’ AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references": ["Not", "not_and", "propext"],
  "name": "Mathlib.Tactic.Push.not_and_eq",
  "constType": "âˆ€ (p q : Prop), (Â¬(p âˆ§ q)) = (p â†’ Â¬q)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast"],
  "name": "Nat.rawCast",
  "constType": "{Î± : Type u} â†’ [AddMonoidWithOne Î±] â†’ â„• â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.antitone_of_countable_chain_of_ball._simp_1_2",
   "le_trans",
   "Membership.mem",
   "Inter.inter",
   "NNReal.toReal",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_3",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "Prod.fst",
   "HDiv.hDiv",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_9",
   "InfSet.sInf",
   "And.left",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_4",
   "Set.Nonempty",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.eq_def",
   "Exists.choose_spec",
   "Set",
   "And.right",
   "NNReal",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.smaller_radius",
   "Prod.snd",
   "Exists.choose",
   "HPow.hPow",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_10",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_2",
   "Nonempty.some",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_8",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.match_1",
   "Metric.closedBall",
   "of_eq_true",
   "le_of_lt",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_1",
   "Min.min",
   "LE.le",
   "id",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric",
   "Eq.mpr",
   "antitone_nat_of_succ_le",
   "setOf"],
  "name":
  "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.antitone_of_countable_chain_of_ball",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] [iud : IsUltrametricDist Î±] [SphericallyCompleteSpace Î±]\n  {S : Set (Î± Ã— NNReal)} [hS : Nonempty â†‘S],\n  (âˆ€ (w1 w2 : â†‘S), (Metric.closedBall (â†‘w1).1 â†‘(â†‘w1).2 âˆ© Metric.closedBall (â†‘w2).1 â†‘(â†‘w2).2).Nonempty) â†’\n    âˆ€ (hw : âˆ€ w âˆˆ S, sInf {x | âˆƒ w âˆˆ S, w.2 = x} < w.2),\n      Antitone fun n â†¦\n        Metric.closedBall (â†‘(SphericallyCompleteSpace.countable_chain_of_ballâœ hw n)).1\n          â†‘(â†‘(SphericallyCompleteSpace.countable_chain_of_ballâœÂ¹ hw n)).2",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mp",
   "eq_false",
   "id",
   "Classical.not_imp._simp_1",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg"],
  "name": "Lean.Grind.eq_false_of_imp_eq_false",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) = False â†’ b = False",
  "constCategory": "Theorem"},
 {"references": ["Set.Pairwise", "Set"],
  "name": "IsChain",
  "constType": "{Î± : Type u_1} â†’ (Î± â†’ Î± â†’ Prop) â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["_private.Init.Prelude.0.Or.elim.match_1_1"],
  "name": "Or.elim",
  "constType": "âˆ€ {a b c : Prop}, a âˆ¨ b â†’ (a â†’ c) â†’ (b â†’ c) â†’ c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNat_mul.match_1_1",
   "Nat.cast",
   "Eq.symm",
   "HMul.hMul",
   "Nat.cast_mul"],
  "name": "Mathlib.Meta.NormNum.isNat_mul",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] {f : Î± â†’ Î± â†’ Î±} {a b : Î±} {a' b' c : â„•},\n  f = HMul.hMul â†’\n    Mathlib.Meta.NormNum.IsNat a a' â†’\n      Mathlib.Meta.NormNum.IsNat b b' â†’ a'.mul b' = c â†’ Mathlib.Meta.NormNum.IsNat (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Std.le_trans",
   "Not.elim",
   "Eq.mp",
   "And.right",
   "LE.le",
   "id",
   "Eq.mpr",
   "And.left",
   "_private.Init.Data.Order.Lemmas.0.Std.instAsymmLtOfLawfulOrderLT._simp_1"],
  "name": "Std.lt_of_lt_of_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : LT Î±] [Trans (fun x1 x2 â†¦ x1 â‰¤ x2) (fun x1 x2 â†¦ x1 â‰¤ x2) fun x1 x2 â†¦ x1 â‰¤ x2]\n  [LawfulOrderLT Î±] {a b c : Î±}, a < b â†’ b â‰¤ c â†’ a < c",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "Inv.inv", "Eq.symm", "inv_eq_one_div", "OfNat.ofNat"],
  "name": "one_div",
  "constType": "âˆ€ {G : Type u_1} [inst : DivInvMonoid G] (a : G), 1 / a = aâ»Â¹",
  "constCategory": "Theorem"},
 {"references": ["FloorSemiring.ceil"],
  "name": "Nat.ceil",
  "constType":
  "{Î± : Type u_2} â†’ [inst : Semiring Î±] â†’ [inst_1 : PartialOrder Î±] â†’ [FloorSemiring Î±] â†’ Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["rfl", "Set", "Singleton.singleton", "Submodule.subset_span"],
  "name": "Submodule.mem_span_singleton_self",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (x : M),\n  x âˆˆ R âˆ™ x",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "PosMulReflectLT.toPosMulStrictMono",
   "HMul.hMul",
   "OfNat.ofNat",
   "mul_pos",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "Iff.mpr",
   "id",
   "Eq.mpr",
   "inv_pos"],
  "name": "div_pos",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a b : Gâ‚€},\n  0 < a â†’ 0 < b â†’ 0 < a / b",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "map_neg", "map_sub'"],
  "name": "map_sub",
  "constType":
  "âˆ€ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : AddGroup G]\n  [inst_2 : SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (a b : G), f (a - b) = f a - f b",
  "constCategory": "Theorem"},
 {"references": ["le_refl"],
  "name": "le_rfl",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a : Î±}, a â‰¤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubgroup.toAddCommGroup._proof_1",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddCommGroup G], AddSubgroupClass (AddSubgroup G) G",
  "constCategory": "Theorem"},
 {"references": [],
  "name":
  "SphericallyCompleteSpace.instQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€OfIsUltrametricDist",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] [IsUltrametricDist ğ•œ],\n  SphericallyCompleteSpace (â†¥(lp (fun x â†¦ ğ•œ) âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ ğ•œ)",
  "constCategory": "Theorem"},
 {"references": ["Set.Ioc", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_Ioc",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b x : Î±}, x âˆˆ Set.Ioc a b â†” a < x âˆ§ x â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congr",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {fâ‚ fâ‚‚ : Î± â†’ Î²} {aâ‚ aâ‚‚ : Î±}, fâ‚ = fâ‚‚ â†’ aâ‚ = aâ‚‚ â†’ fâ‚ aâ‚ = fâ‚‚ aâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "abs_norm_sub_norm_le",
   "HSub.hSub",
   "le_abs_self",
   "abs",
   "LE.le.trans"],
  "name": "norm_sub_norm_le",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), â€–aâ€– - â€–bâ€– â‰¤ â€–a - bâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "NNReal.toReal",
   "SphericallyCompleteSpace.câ‚€",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_1",
   "Subtype.val",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_3",
   "DFunLike.coe",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_5",
   "SphericallyCompleteSpace.câ‚€._proof_1",
   "HSub.hSub",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_2",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section.match_1",
   "QuotientAddGroup.mk'",
   "PreLp",
   "Norm.norm",
   "Set",
   "NNReal",
   "Submodule.quotientRel",
   "Nat.brecOn",
   "Submodule.toAddSubgroup",
   "Exists.choose",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_4",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "StrictAnti",
   "ENNReal",
   "Antitone",
   "Nat.below",
   "Top.top",
   "Quotient.out"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : â„• â†’ Type u_2) â†’\n      [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)] â†’\n        [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] â†’\n          [âˆ€ (i : â„•), IsUltrametricDist (E i)] â†’\n            {c : â„• â†’ â†¥(lp E âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ E} â†’\n              {r : â„• â†’ NNReal} â†’\n                StrictAnti r â†’\n                  (Antitone fun i â†¦ Metric.closedBall (c i) â†‘(r i)) â†’\n                    (k : â„•) â†’ { z // (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ E).toAddSubgroup) z = c k }",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet.sInf",
  "constType": "{Î± : Type u_1} â†’ [self : InfSet Î±] â†’ Set Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Denumerable.decode_isSome", "Option.get", "Encodable.decode"],
  "name": "Denumerable.ofNat",
  "constType": "(Î± : Type u_3) â†’ [Denumerable Î±] â†’ â„• â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Norm.norm",
   "Exists.choose_spec",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthProj",
   "Exists.choose",
   "Subtype.val",
   "DFunLike.coe",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "RingHom.id",
   "LE.le",
   "id",
   "And.left"],
  "name": "SphericallyCompleteSpace.OrthProj_id",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F],\n  âˆ€ a âˆˆ F, â†‘((SphericallyCompleteSpace.OrthProj ğ•œ F) a) = a",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "ZeroHomClass.map_zero"],
  "name": "map_zero",
  "constType":
  "âˆ€ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]\n  [ZeroHomClass F M N] (f : F), f 0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsImmediate._proof_1",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ], RingHomSurjective (RingHom.id ğ•œ)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "DFunLike.coe", "ContinuousLinearMap.comp"],
  "name": "ContinuousLinearMap.comp_apply",
  "constType":
  "âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} {Râ‚ƒ : Type u_3} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Semiring Râ‚ƒ]\n  {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Ïƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ïƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ} {Mâ‚ : Type u_4} [inst_3 : TopologicalSpace Mâ‚]\n  [inst_4 : AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [inst_5 : TopologicalSpace Mâ‚‚] [inst_6 : AddCommMonoid Mâ‚‚] {Mâ‚ƒ : Type u_7}\n  [inst_7 : TopologicalSpace Mâ‚ƒ] [inst_8 : AddCommMonoid Mâ‚ƒ] [inst_9 : _root_.Module Râ‚ Mâ‚]\n  [inst_10 : _root_.Module Râ‚‚ Mâ‚‚] [inst_11 : _root_.Module Râ‚ƒ Mâ‚ƒ] [inst_12 : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ]\n  (g : Mâ‚‚ â†’SL[Ïƒâ‚‚â‚ƒ] Mâ‚ƒ) (f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) (x : Mâ‚), (g.comp f) x = g (f x)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Metric.ball", "Iff.rfl"],
  "name": "Metric.mem_ball",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, y âˆˆ Metric.ball x Îµ â†” dist y x < Îµ",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "congr",
   "HSub.hSub",
   "neg_neg",
   "neg_add_rev",
   "congrArg"],
  "name": "neg_sub",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SubtractionMonoid Î±] (a b : Î±), -(a - b) = b - a",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.ndrec"],
  "name": "Lean.Omega.Int.add_congr",
  "constType": "âˆ€ {a b c d : â„¤}, a = b â†’ c = d â†’ a + c = b + d",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono", "eq_false", "LE.le", "Nat.not_ofNat_le_one", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_24",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] [CharZero Î±]\n  {n : â„•} [inst_5 : n.AtLeastTwo], (OfNat.ofNat n â‰¤ 1) = False",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (Eâ‚€ : Type u_1) [inst_1 : NormedAddCommGroup Eâ‚€]\n  [inst_2 : NormedSpace ğ•œ Eâ‚€] [IsUltrametricDist Eâ‚€] (M : Submodule ğ•œ Eâ‚€), IsUltrametricDist â†¥M",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_19",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) = (a âˆ§ b)",
  "constCategory": "Theorem"},
 {"references": ["Set.iUnion_subtype", "Set", "Membership.mem", "Set.Elem"],
  "name": "Set.iUnion_coe_set",
  "constType":
  "âˆ€ {Î± : Type u_12} {Î² : Type u_13} (s : Set Î±) (f : â†‘s â†’ Set Î²), â‹ƒ i, f i = â‹ƒ i, â‹ƒ (h : i âˆˆ s), f âŸ¨i, hâŸ©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulAction.one_smul",
  "constType":
  "âˆ€ {Î± : Type u_9} {Î² : Type u_10} {inst : Monoid Î±} [self : MulAction Î± Î²] (b : Î²), 1 â€¢ b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Nat.zero_le",
   "Directed",
   "OfNat.ofNat",
   "Antitone.directed_ge",
   "HAdd.hAdd",
   "IsCompact.of_isClosed_subset",
   "HasSubset.Subset",
   "IsCompact",
   "IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed",
   "Antitone",
   "Superset",
   "antitone_nat_of_succ_le"],
  "name": "IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed",
  "constType":
  "âˆ€ {X : Type u} [inst : TopologicalSpace X] (t : â„• â†’ Set X),\n  (âˆ€ (i : â„•), t (i + 1) âŠ† t i) â†’\n    (âˆ€ (i : â„•), (t i).Nonempty) â†’ IsCompact (t 0) â†’ (âˆ€ (i : â„•), IsClosed (t i)) â†’ (â‹‚ i, t i).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "dite",
  "constType":
  "{Î± : Sort u} â†’ (c : Prop) â†’ [h : Decidable c] â†’ (c â†’ Î±) â†’ (Â¬c â†’ Î±) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["absurd", "Not", "rfl", "ite", "_private.Init.Core.0.if_pos.match_1_1"],
  "name": "if_pos",
  "constType":
  "âˆ€ {c : Prop} {h : Decidable c}, c â†’ âˆ€ {Î± : Sort u} {t e : Î±}, (if c then t else e) = t",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "TopologicalSpace.SeparableSpace.exists_countable_dense",
  "constType":
  "âˆ€ {Î± : Type u} {t : TopologicalSpace Î±} [self : TopologicalSpace.SeparableSpace Î±], âˆƒ s, s.Countable âˆ§ Dense s",
  "constCategory": "Theorem"},
 {"references": ["exists_apply_eq_apply", "eq_true"],
  "name":
  "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate._simp_1_2",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} (f : Î± â†’ Î²) (a' : Î±), (âˆƒ a, f a = f a') = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "âˆ€ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "le_of_lt", "lt_of_lt_of_le"],
  "name": "lt_trans",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b c : Î±}, a < b â†’ b < c â†’ a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_ne_zero", "Nat.cast", "Iff.mpr", "Ne", "NeZero.ne", "OfNat.ofNat"],
  "name": "OfNat.ofNat_ne_zero",
  "constType":
  "âˆ€ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] (n : â„•) [inst_2 : n.AtLeastTwo], OfNat.ofNat n â‰  0",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.isboundedlinearmap_of_glued_map._simp_2",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Group.Basic.0.add_add_add_comm._proof_1_1"],
  "name": "add_add_add_comm",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddCommSemigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidHomClass.isometry_of_norm",
   "LinearIsometry.toLinearMap",
   "LinearIsometry.norm_map",
   "DFunLike.coe"],
  "name": "LinearIsometry.isometry",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup Eâ‚‚] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module Râ‚‚ Eâ‚‚] (f : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚), Isometry â‡‘f",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Metric.closedBall",
   "Trans.trans",
   "add_le_add",
   "Set",
   "Iff.mpr",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "Bornology.IsBounded",
   "dist_triangle_right",
   "Metric.isBounded_iff"],
  "name": "Metric.isBounded_closedBall",
  "constType":
  "âˆ€ {Î± : Type u} {x : Î±} {r : â„} [inst : PseudoMetricSpace Î±], Bornology.IsBounded (Metric.closedBall x r)",
  "constCategory": "Theorem"},
 {"references": ["OrderBot.bot_le"],
  "name": "bot_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderBot Î±] {a : Î±}, âŠ¥ â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["iSup", "Set"],
  "name": "Set.iUnion",
  "constType": "{Î± : Type u} â†’ {Î¹ : Sort v} â†’ (Î¹ â†’ Set Î±) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SProd.sprod",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : SProd Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references": ["trivial"],
  "name": "Set.mem_univ",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), x âˆˆ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Cardinal.toNat", "Module.rank", "Cardinal", "DFunLike.coe"],
  "name": "Module.finrank",
  "constType":
  "(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommMonoid M] â†’ [_root_.Module R M] â†’ â„•",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_add",
   "HAdd.hAdd",
   "Nat.cast",
   "Nat.add",
   "Eq.symm",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNat_add.match_1_1"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] {f : Î± â†’ Î± â†’ Î±} {a b : Î±} {a' b' c : â„•},\n  f = HAdd.hAdd â†’\n    Mathlib.Meta.NormNum.IsNat a a' â†’\n      Mathlib.Meta.NormNum.IsNat b b' â†’ a'.add b' = c â†’ Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_3",
  "constType": "âˆ€ {a : Prop}, (Â¬Â¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "LT.lt",
   "mul_le_mul_iff_rightâ‚€",
   "LE.le",
   "id",
   "HMul.hMul",
   "mul_one",
   "Eq.mpr",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg"],
  "name": "mul_le_iff_le_one_right",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : MulOneClass Î±] [inst_1 : Zero Î±] {a b : Î±} [inst_2 : Preorder Î±] [PosMulMono Î±]\n  [PosMulReflectLE Î±], 0 < a â†’ (a * b â‰¤ a â†” b â‰¤ 1)",
  "constCategory": "Theorem"},
 {"references":
  ["isometry_neg",
   "Set.neg",
   "Eq.trans",
   "Metric.infDist_eq_iInf",
   "HasQuotient.Quotient",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "Set.image_neg_eq_neg",
   "funext",
   "Dist.dist",
   "QuotientAddGroup.mk'_apply",
   "InfSet.sInf",
   "HSub.hSub",
   "sInf_image'",
   "Eq.symm",
   "neg_coe_set",
   "Metric.infDist",
   "iInf",
   "add_comm",
   "QuotientAddGroup.norm_mk",
   "QuotientAddGroup.mk'",
   "Norm.norm",
   "Set",
   "Neg.neg",
   "sub_neg_eq_add",
   "HAdd.hAdd",
   "eq_self",
   "dist_eq_norm'",
   "Set.image",
   "SetLike.coe",
   "of_eq_true",
   "Metric.infDist_image",
   "id",
   "QuotientAddGroup.mk",
   "Eq.mpr"],
  "name": "quotient_norm_mk_eq",
  "constType":
  "âˆ€ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (m : M),\n  â€–(QuotientAddGroup.mk' S) mâ€– = sInf ((fun x â†¦ â€–m + xâ€–) '' â†‘S)",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.trichotomy",
   "Eq.trans",
   "Singleton.singleton",
   "SummationFilter.unconditional",
   "Real.zero_rpow",
   "memâ„“p_zero",
   "Set.range",
   "Set.range_const_subset",
   "congrArg",
   "LT.lt.ne'",
   "BddAbove.mono",
   "Memâ„“p",
   "funext",
   "memâ„“p_gen",
   "ENNReal.toReal",
   "Eq.symm",
   "not_true_eq_false",
   "_private.Mathlib.Analysis.Normed.Lp.lpSpace.0.zero_memâ„“p._simp_1_1",
   "Eq.ndrec",
   "norm_zero",
   "Not",
   "Norm.norm",
   "Set",
   "HPow.hPow",
   "OfNat.ofNat",
   "BddAbove",
   "Summable",
   "LT.lt",
   "Or.casesOn",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "Set.finite_empty._simp_1",
   "id",
   "Top.top",
   "bddAbove_singleton",
   "Eq.mpr",
   "Set.Finite",
   "memâ„“p_infty",
   "setOf"],
  "name": "zero_memâ„“p",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)], Memâ„“p 0 p",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_13",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSub.hSub",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HSub Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "PreLp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "Set",
   "lp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Exists.choose",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.SphericalCompletion",
   "ENNReal",
   "Maximal",
   "Top.top",
   "inferInstance",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceSphericalCompletion",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace (SphericallyCompleteSpace.SphericalCompletion ğ•œ E)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsInt.to_isNat.match_1_1",
   "Int.cast_natCast",
   "Int.cast",
   "congrArg"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a : Î±} {n : â„•},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) â†’ Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "SemilinearMapClass.semilinearMap._proof_2",
   "SemilinearMapClass.semilinearMap._proof_1",
   "DFunLike.coe"],
  "name": "SemilinearMapClass.semilinearMap",
  "constType":
  "{R : Type u_1} â†’\n  {S : Type u_5} â†’\n    {M : Type u_8} â†’\n      {Mâ‚ƒ : Type u_11} â†’\n        {F : Type u_14} â†’\n          [inst : Semiring R] â†’\n            [inst_1 : Semiring S] â†’\n              [inst_2 : AddCommMonoid M] â†’\n                [inst_3 : AddCommMonoid Mâ‚ƒ] â†’\n                  [inst_4 : _root_.Module R M] â†’\n                    [inst_5 : _root_.Module S Mâ‚ƒ] â†’\n                      {Ïƒ : R â†’+* S} â†’ F â†’ [inst_6 : FunLike F M Mâ‚ƒ] â†’ [SemilinearMapClass F Ïƒ M Mâ‚ƒ] â†’ M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ",
  "constCategory": "Definition"},
 {"references":
  ["LE.le", "_private.Mathlib.Order.Defs.LinearOrder.0.max_eq_left._proof_1_1"],
  "name": "max_eq_left",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, b â‰¤ a â†’ max a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval_inv",
   "Inv.inv",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.inv_eq_eval",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] {l : Mathlib.Tactic.FieldSimp.NF M} {x : M}, x = l.eval â†’ xâ»Â¹ = lâ»Â¹.eval",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Top.top", "eq_true", "Submodule.mem_top"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_5",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x âˆˆ âŠ¤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl", "Nat.cast", "LE.le", "Nat.ceil_le", "Iff.mp", "Nat.ceil"],
  "name": "Nat.le_ceil",
  "constType":
  "âˆ€ {R : Type u_1} [inst : Semiring R] [inst_1 : LinearOrder R] [inst_2 : FloorSemiring R] (a : R), a â‰¤ â†‘âŒˆaâŒ‰â‚Š",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "NegMemClass.neg_mem",
  "constType":
  "âˆ€ {S : Type u_3} {G : outParam (Type u_4)} {inst : Neg G} {inst_1 : SetLike S G} [self : NegMemClass S G] {s : S}\n  {x : G}, x âˆˆ s â†’ -x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Not", "by_contra"],
  "name": "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
  "constType": "âˆ€ {p q : Prop}, (Â¬q â†’ p) â†’ Â¬p â†’ q",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv",
   "HAdd.hAdd",
   "Nat.cast",
   "NNDist.nndist",
   "NNReal",
   "HMul.hMul",
   "Prod.snd",
   "GT.gt",
   "Exists.choose",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "OfNat.ofNat",
   "Prod.fst"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
  "constType":
  "(Î± : Type u_1) â†’\n  [inst : PseudoMetricSpace Î±] â†’ [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] â†’ [nemp : Nonempty Î±] â†’ â„• â†’ NNReal",
  "constCategory": "Definition"},
 {"references": ["forall_apply_eq_imp_iffâ‚‚", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_8",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  (âˆ€ (b : Î²) (a : Î±), p a â†’ f a = b â†’ q b) = âˆ€ (a : Î±), p a â†’ q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Isometry.injective", "LinearIsometry.isometry", "DFunLike.coe"],
  "name": "LinearIsometry.injective",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {Eâ‚‚ : Type u_6} {F : Type u_9} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_2 : SeminormedAddCommGroup Eâ‚‚] [inst_3 : _root_.Module Râ‚‚ Eâ‚‚] [inst_4 : NormedAddCommGroup F]\n  [inst_5 : _root_.Module R F] (fâ‚ : F â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚), Function.Injective â‡‘fâ‚",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Inter.inter", "Set.ext", "and_comm"],
  "name": "Set.inter_comm",
  "constType": "âˆ€ {Î± : Type u} (a b : Set Î±), a âˆ© b = b âˆ© a",
  "constCategory": "Theorem"},
 {"references":
  ["mul_inv_cancelâ‚€",
   "Eq.trans",
   "Membership.mem",
   "Classical.propDecidable",
   "HMul.hMul",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop._simp_1_1",
   "Subtype.val",
   "Set.Elem",
   "RingHom.id",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Eq.symm",
   "mul_comm",
   "Eq.ndrec",
   "ContinuousLinearMap.map_smul",
   "Exists.choose_spec",
   "Norm.norm",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "smul_sub",
   "add_zero",
   "map_add",
   "mul_le_mul_iff_of_pos_left",
   "norm_pos_iff",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "zero_smul",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "mul_assoc",
   "DFunLike.coe",
   "congrArg",
   "congr",
   "propext",
   "Not",
   "Set.Nonempty",
   "Inv.inv",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "norm_smul",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "smul_smul",
   "smul_add",
   "Ne",
   "MulAction.one_smul",
   "dite"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (ha1 : a âˆ‰ D) {F : Type u_3}\n  [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ğ•œ F]\n  [hsc : SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) {ğ’° : Set (E â†’L[ğ•œ] F)} (hğ’° : ğ’°.Nonempty) {Îµ : â†‘ğ’° â†’ â„}\n  (hÎµ1 : âˆ€ (T : â†‘ğ’°), 0 < Îµ T) (hÎµ2 : âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V))\n  (hÎµ3 : âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–) (x : â†¥D) (l : ğ•œ) (U : â†‘ğ’°),\n  â€–S x + l â€¢ â‹¯.choose - â†‘U (â†‘x + l â€¢ a)â€– â‰¤ Îµ U * â€–â†‘x + l â€¢ aâ€–",
  "constCategory": "Theorem"},
 {"references": ["AddZeroClass.add_zero"],
  "name": "add_zero",
  "constType": "âˆ€ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.ker",
   "sub_eq_zero",
   "Membership.mem",
   "Iff.rfl",
   "DFunLike.coe",
   "OfNat.ofNat",
   "map_sub",
   "congrArg",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "propext",
   "LinearMap.mem_ker"],
  "name": "LinearMap.sub_mem_ker_iff",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : Ring R] [inst_1 : Ring Râ‚‚]\n  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {x y : M}, x - y âˆˆ f.ker â†” f x = f y",
  "constCategory": "Theorem"},
 {"references": ["zero_le", "LE.le", "eq_true", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.câ‚€._simp_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddZeroClass Î±] [inst_1 : LE Î±] [CanonicallyOrderedAdd Î±] (a : Î±), (0 â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name": "Set.mem_iInter._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_1",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 â‰¤ â€–aâ€–) = True",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "LinearIsometry.isometry",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "Eq.symm",
   "SemilinearMapClass.semilinearMap",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Isometry.isometryEquivOnRange",
   "LinearIsometry.comp",
   "Exists.choose",
   "Function.Surjective",
   "Exists.casesOn",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "LinearMap.range_comp_le_range",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective",
   "LE.le",
   "id",
   "Top.top",
   "Eq.mpr",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_unique",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [IsUltrametricDist F] [SphericallyCompleteSpace F] {f : E â†’â‚—áµ¢[ğ•œ] F},\n  (âˆ€ (M : Submodule ğ•œ F), f.range â‰¤ M â†’ SphericallyCompleteSpace â†¥M â†’ M = âŠ¤) â†’\n    Nonempty (SphericallyCompleteSpace.SphericalCompletion ğ•œ E â‰ƒâ‚—áµ¢[ğ•œ] F)",
  "constCategory": "Theorem"},
 {"references":
  ["id",
   "HMul.hMul",
   "Eq.mpr",
   "HPow.hPow",
   "Eq.ndrec",
   "mul_left_comm",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_pf_right",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a bâ‚ƒ c : R} (bâ‚ : R) (bâ‚‚ : â„•), a * bâ‚ƒ = c â†’ a * (bâ‚ ^ bâ‚‚ * bâ‚ƒ) = bâ‚ ^ bâ‚‚ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.mk.injEq",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "eq_true",
   "le_sup_left._simp_1",
   "Submodule.mem_sup_left",
   "Set.iInter",
   "Membership.mem.out",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.not_morth_iff_exists_dist_lt_norm",
   "RingHom.id",
   "Submodule.mem_span_singleton",
   "StrictAnti.antitone",
   "Eq.symm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "Eq.ndrec",
   "norm_zero",
   "norm_eq_of_norm_sub_lt_left",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_4",
   "sub_sub_eq_add_sub",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_21",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Norm.norm",
   "sub_neg_eq_add",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_3",
   "Submodule.smul_mem",
   "NNReal",
   "Mathlib.Tactic.Abel.term_add_constg",
   "true_and",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "Set.nonempty_iff_ne_empty",
   "max_lt",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SetLike.coe",
   "LinearIsometry.toLinearMap",
   "IsUltrametricDist.dist_triangle_max",
   "eq_false",
   "Antitone",
   "Classical.byContradiction",
   "NNDist.nndist",
   "Int.negOfNat",
   "zero_smul",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_5",
   "Metric.mem_closedBall_self",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_16",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "max_le",
   "dist_eq_norm",
   "EmptyCollection.emptyCollection",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Subspace",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_23",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Submodule.mem_sup",
   "congr",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "neg_smul",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Metric.infDist_zero_of_mem",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_1",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_22",
   "IsUltrametricDist.norm_add_eq_max_of_norm_ne_norm",
   "OfNat.ofNat",
   "le_sup_of_le_left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "not_le_of_gt",
   "eq_self",
   "Metric.closedBall",
   "Max.max",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_9",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_19",
   "smul_add",
   "Submodule.sub_mem",
   "Ne",
   "eq_of_le_of_ge",
   "dite",
   "And.casesOn",
   "Mathlib.Tactic.Push.not_forall_eq",
   "Membership.mem",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_14",
   "Submodule.span",
   "Submodule.subtype",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "not_false_eq_true",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_11",
   "add_comm",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "max_comm",
   "LinearMap.toAddMonoidHom",
   "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
   "Neg.neg",
   "lt_of_le_of_lt",
   "And.right",
   "add_zero",
   "Submodule.mk_eq_zero._simp_1",
   "Exists.casesOn",
   "zero_add",
   "mt",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "Iff.of_eq",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_12",
   "max_self",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "SphericallyCompleteSpace.smul_morth_of_morth",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_2",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "LinearMap.range",
   "le_trans",
   "NNReal.toReal",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_20",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "DFunLike.coe",
   "Metric.le_infDist",
   "congrArg",
   "add_sub",
   "SetLike.mem_coe",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_13",
   "Subtype.prop",
   "inv_smul_smulâ‚€",
   "le_of_eq",
   "NNReal.zero_le_coe",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_18",
   "Set.not_nonempty_iff_eq_empty._simp_1",
   "Not",
   "Inv.inv",
   "Classical.not_imp._simp_2",
   "Set.Nonempty",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_6",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_15",
   "Exists.choose",
   "Mathlib.Tactic.Abel.term_neg",
   "exists_prop_congr",
   "sub_sub_sub_cancel_right",
   "LT.lt",
   "StrictAnti",
   "ZeroMemClass.zero_mem._simp_1",
   "SetLike.mem_coe._simp_1",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_10",
   "Mathlib.Tactic.Contrapose.contraposeâ‚"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (Eâ‚€ : Type u_3) [inst_4 : NormedAddCommGroup Eâ‚€]\n  [inst_5 : NormedSpace ğ•œ Eâ‚€] [iud : IsUltrametricDist Eâ‚€] [hsc : SphericallyCompleteSpace Eâ‚€] (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€),\n  SphericallyCompleteSpace â†¥â‹¯.choose",
  "constCategory": "Theorem"},
 {"references": ["implies_dep_congr_ctx"],
  "name": "implies_congr_ctx",
  "constType":
  "âˆ€ {pâ‚ pâ‚‚ qâ‚ qâ‚‚ : Prop}, pâ‚ = pâ‚‚ â†’ (pâ‚‚ â†’ qâ‚ = qâ‚‚) â†’ (pâ‚ â†’ qâ‚) = (pâ‚‚ â†’ qâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "HSMul.hSMul",
   "add_zero",
   "one_zsmul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.term_atomg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (x : Î±), x = Mathlib.Tactic.Abel.termg 1 x 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_1",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_5",
   "eq_true",
   "GT.gt",
   "Subtype.val",
   "funext",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_4",
   "And.left",
   "And.right",
   "lt_of_le_of_lt",
   "Exists.casesOn",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "Set.image",
   "SetLike.coe",
   "Iff.of_eq",
   "IsUltrametricDist.dist_triangle_max",
   "Iff.mpr",
   "id",
   "Set.ext",
   "Eq.mpr",
   "Submodule.nonempty",
   "FiniteDimensional",
   "le_sup_iff",
   "Eq.mp",
   "le_trans",
   "and_true",
   "Subspace",
   "congrArg",
   "congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_2",
   "Dist.dist",
   "Metric.infDist",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
   "propext",
   "Set",
   "dist_comm",
   "exists_prop_congr",
   "LT.lt",
   "Or.casesOn",
   "Metric.closedBall",
   "Max.max",
   "Metric.infDist_lt_iff",
   "le_of_lt",
   "LE.le",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_3"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [iud : IsUltrametricDist E] (F : Subspace ğ•œ E) [SphericallyCompleteSpace â†¥F]\n  [FiniteDimensional ğ•œ E] (a : E),\n  âˆ€ s > Metric.infDist a â†‘F, âˆƒ z, Metric.closedBall a s âˆ© â†‘F = (fun x â†¦ â†‘x) '' Metric.closedBall z s",
  "constCategory": "Theorem"},
 {"references": ["Prod.forall", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± Ã— Î² â†’ Prop}, (âˆ€ (x : Î± Ã— Î²), p x) = âˆ€ (a : Î±) (b : Î²), p (a, b)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "norm_pos_iff'._simp_2",
   "Classical.propDecidable",
   "HMul.hMul",
   "sub_zero",
   "Subtype.val",
   "Set.Elem",
   "not_false_eq_true",
   "RingHom.id",
   "funext",
   "forall_congr",
   "Eq.symm",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_4",
   "HSub.hSub",
   "norm_zero",
   "forall_prop_domain_congr",
   "And.left",
   "Norm.norm",
   "And.right",
   "ContinuousLinearMap.norm_def",
   "true_and",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_1",
   "Exists.casesOn",
   "implies_true",
   "Iff.mpr",
   "eq_false",
   "max_self",
   "lowerBounds",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_3",
   "setOf",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_2",
   "forall_eq._simp_1",
   "Eq.mp",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.exists_extension_opNorm_le",
   "Subtype.prop",
   "csInf_le_csInf",
   "congr",
   "InfSet.sInf",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_5",
   "Not",
   "Set.Nonempty",
   "ContinuousLinearMap.le_opNorm",
   "Set",
   "norm_nonneg'._simp_2",
   "OfNat.ofNat",
   "LT.lt",
   "eq_self",
   "and_self",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "Subtype.forall._simp_1",
   "ContinuousLinearMap.opNorm_le_iff",
   "Set.singleton_nonempty._simp_1",
   "Ne",
   "eq_of_le_of_ge",
   "Set.mem_singleton_iff._simp_1",
   "dite",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.hahn_banach'",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [IsUltrametricDist E] (D : Submodule ğ•œ E) {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [IsUltrametricDist F] [hf : SphericallyCompleteSpace F] (f : â†¥D â†’L[ğ•œ] F),\n  âˆƒ f', (âˆ€ (v : E) (hv : v âˆˆ D), f' v = f âŸ¨v, hvâŸ©) âˆ§ â€–f'â€– = â€–fâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["sub_self",
   "eq_of_sub_eq_zero",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "sub_eq_zero",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 â†” a = b",
  "constCategory": "Theorem"},
 {"references": ["MulDivCancelClass.mul_div_cancel", "Ne", "OfNat.ofNat"],
  "name": "mul_div_cancel_rightâ‚€",
  "constType":
  "âˆ€ {Mâ‚€ : Type u_1} [inst : MonoidWithZero Mâ‚€] [inst_1 : Div Mâ‚€] [MulDivCancelClass Mâ‚€] (a : Mâ‚€) {b : Mâ‚€},\n  b â‰  0 â†’ a * b / b = a",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Eq.trans",
   "sub_add_cancel",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Submodule.span",
   "Subtype.val",
   "Set.Elem",
   "RingHom.id",
   "eq_of_heq",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "And.left",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Norm.norm",
   "Exists.choose_spec",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "outParam",
   "And.right",
   "max_mul_of_nonneg",
   "Set.Nonempty.some_mem",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop",
   "Set.Nonempty.some",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "lt_max_of_lt_left",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "max_le_max",
   "le_trans",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear",
   "DFunLike.coe",
   "congrArg",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Not",
   "ContinuousLinearMap.le_opNorm",
   "Set.Nonempty",
   "Set",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Exists.choose",
   "Eq.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "norm_nonneg"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_boundedlinear",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (ha1 : a âˆ‰ D) {F : Type u_3}\n  [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ğ•œ F]\n  [hsc : SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) {ğ’° : Set (E â†’L[ğ•œ] F)} (hğ’° : ğ’°.Nonempty) {Îµ : â†‘ğ’° â†’ â„}\n  (hÎµ1 : âˆ€ (T : â†‘ğ’°), 0 < Îµ T) (hÎµ2 : âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V))\n  (hÎµ3 : âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–),\n  IsBoundedLinearMap ğ•œ (SphericallyCompleteSpace.rooij_lemma_4_4_T ha1 S hğ’° hÎµ1 hÎµ2 hÎµ3)",
  "constCategory": "Definition"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "LinearMap.comp",
   "ContinuousLinearMap.comp._proof_1"],
  "name": "ContinuousLinearMap.comp",
  "constType":
  "{Râ‚ : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {Râ‚ƒ : Type u_3} â†’\n      [inst : Semiring Râ‚] â†’\n        [inst_1 : Semiring Râ‚‚] â†’\n          [inst_2 : Semiring Râ‚ƒ] â†’\n            {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} â†’\n                {Ïƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ} â†’\n                  {Mâ‚ : Type u_4} â†’\n                    [inst_3 : TopologicalSpace Mâ‚] â†’\n                      [inst_4 : AddCommMonoid Mâ‚] â†’\n                        {Mâ‚‚ : Type u_6} â†’\n                          [inst_5 : TopologicalSpace Mâ‚‚] â†’\n                            [inst_6 : AddCommMonoid Mâ‚‚] â†’\n                              {Mâ‚ƒ : Type u_7} â†’\n                                [inst_7 : TopologicalSpace Mâ‚ƒ] â†’\n                                  [inst_8 : AddCommMonoid Mâ‚ƒ] â†’\n                                    [inst_9 : _root_.Module Râ‚ Mâ‚] â†’\n                                      [inst_10 : _root_.Module Râ‚‚ Mâ‚‚] â†’\n                                        [inst_11 : _root_.Module Râ‚ƒ Mâ‚ƒ] â†’\n                                          [RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] â†’\n                                            (Mâ‚‚ â†’SL[Ïƒâ‚‚â‚ƒ] Mâ‚ƒ) â†’ (Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) â†’ Mâ‚ â†’SL[Ïƒâ‚â‚ƒ] Mâ‚ƒ",
  "constCategory": "Definition"},
 {"references": ["ZeroMemClass.zero_mem"],
  "name": "Submodule.zero_mem",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M), 0 âˆˆ p",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Int.natCast_nonneg",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_12",
  "constType": "âˆ€ n â‰¥ 1, âˆ€ (k : â„•), k + 1 â‰¥ n + 1 â†’ Â¬k - 1 + 1 = k â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_13",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x âˆˆ p), (âŸ¨x, hâŸ© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["exists_true_left", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_7",
  "constType": "âˆ€ {p : True â†’ Prop}, Exists p = p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "ite",
   "SummationFilter.unconditional",
   "HPow.hPow",
   "OfNat.ofNat",
   "BddAbove",
   "Set.range",
   "Summable",
   "ENNReal",
   "Top.top",
   "ENNReal.toReal",
   "Ne",
   "Set.Finite",
   "setOf"],
  "name": "Memâ„“p",
  "constType":
  "{Î± : Type u_3} â†’ {E : Î± â†’ Type u_4} â†’ [(i : Î±) â†’ NormedAddCommGroup (E i)] â†’ ((i : Î±) â†’ E i) â†’ ENNReal â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Set.image", "Set", "HSMul.hSMul"],
  "name": "Set.smulSet",
  "constType": "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [SMul Î± Î²] â†’ SMul Î± (Set Î²)",
  "constCategory": "Definition"},
 {"references": ["Eq.symm", "HSub.hSub", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "âˆ€ {R : Type u_2} [inst : CommRing R] {a a' b b' c : R}, a = a' â†’ b = b' â†’ a' - b' = c â†’ a - b = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkStr2",
  "constType": "String â†’ String â†’ Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PreLp",
  "constType":
  "{Î± : Type u_3} â†’ (E : Î± â†’ Type u_5) â†’ [(i : Î±) â†’ NormedAddCommGroup (E i)] â†’ Type (max u_3 u_5)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "inv_pos._simp_1",
   "Inv.inv",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "LE.le",
   "_private.Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic.0.inv_nonneg._simp_1_1",
   "OfNat.ofNat",
   "_private.Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic.0.inv_nonneg._simp_1_2",
   "congrArg"],
  "name": "inv_nonneg",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a : Gâ‚€}, 0 â‰¤ aâ»Â¹ â†” 0 â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["LE.le.eq_or_lt", "LT.lt", "Not", "LE.le", "Or.resolve_right"],
  "name": "eq_of_le_of_not_lt",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ Â¬a < b â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.IsImmediate", "RingHom.id"],
  "name": "SphericallyCompleteSpace.IsImmediate.eq_1",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : SeminormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [inst_6 : IsUltrametricDist F] (f : E â†’â‚—áµ¢[ğ•œ] F),\n  SphericallyCompleteSpace.IsImmediate f = âˆ€ (v : F), SphericallyCompleteSpace.MOrth ğ•œ v f.range â†’ v = 0",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_6",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.OrthComp._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], IsScalarTower ğ•œ ğ•œ E",
  "constCategory": "Theorem"},
 {"references": ["Quotient"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Inter.inter",
   "Membership.mem",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "HDiv.hDiv",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_9",
   "Eq.symm",
   "Eq.ndrec",
   "NNReal.exists_add_one_div_pow_two_lt",
   "Nat.casesAuxOn",
   "And.left",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
   "Exists.choose_spec",
   "And.right",
   "lt_of_le_of_lt",
   "NNReal",
   "Prod.snd",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_2",
   "Unit",
   "Exists.casesOn",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.match_1",
   "HasSubset.Subset",
   "inf_le_left",
   "id",
   "Eq.mpr",
   "setOf",
   "NNReal.toReal",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_3",
   "Prod.fst",
   "congrArg",
   "InfSet.sInf",
   "Set.Nonempty",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_4",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.eq_def",
   "Set",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.smaller_radius",
   "HPow.hPow",
   "Exists.choose",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_10",
   "OfNat.ofNat",
   "Nonempty.some",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_8",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "le_of_lt",
   "Min.min",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_1",
   "LE.le",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric"],
  "name":
  "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.cofinal_of_countable_chain_of_ball",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] [IsUltrametricDist Î±] [SphericallyCompleteSpace Î±] {S : Set (Î± Ã— NNReal)}\n  [hS : Nonempty â†‘S],\n  (âˆ€ (w1 w2 : â†‘S), (Metric.closedBall (â†‘w1).1 â†‘(â†‘w1).2 âˆ© Metric.closedBall (â†‘w2).1 â†‘(â†‘w2).2).Nonempty) â†’\n    âˆ€ (hw : âˆ€ w âˆˆ S, sInf {x | âˆƒ w âˆˆ S, w.2 = x} < w.2),\n      âˆ€ s âˆˆ S,\n        âˆƒ n,\n          Metric.closedBall (â†‘(SphericallyCompleteSpace.countable_chain_of_ballâœ hw n)).1\n              â†‘(â†‘(SphericallyCompleteSpace.countable_chain_of_ballâœÂ¹ hw n)).2 âŠ†\n            Metric.closedBall s.1 â†‘s.2",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mpr",
   "_private.Init.PropLemmas.0.exists_prop_congr.match_1_3",
   "Iff.mp",
   "_private.Init.PropLemmas.0.exists_prop_congr.match_1_1"],
  "name": "exists_prop_congr",
  "constType":
  "âˆ€ {p p' : Prop} {q q' : p â†’ Prop}, (âˆ€ (h : p), q h â†” q' h) â†’ âˆ€ (hp : p â†” p'), Exists q â†” âˆƒ (h : p'), q' â‹¯",
  "constCategory": "Theorem"},
 {"references": ["NormSMulClass.norm_smul"],
  "name": "norm_smul",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Norm Î±] [inst_1 : Norm Î²] [inst_2 : SMul Î± Î²] [NormSMulClass Î± Î²] (r : Î±)\n  (x : Î²), â€–r â€¢ xâ€– = â€–râ€– * â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Iff.trans",
   "Max.max",
   "not_congr",
   "LE.le",
   "LE.le.lt_iff_ne",
   "left_eq_sup",
   "Ne",
   "le_sup_left"],
  "name": "left_lt_sup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a < a âŠ” b â†” Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["Nat.ge_of_not_lt"],
  "name": "Nat.le_of_not_lt",
  "constType": "âˆ€ {a b : â„•}, Â¬a < b â†’ b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["ProperSpace.of_locallyCompactSpace", "inferInstance"],
  "name":
  "SphericallyCompleteSpace.SphericallyComplete.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E] [NormedSpace ğ•œ E]\n  [LocallyCompactSpace E], SphericallyCompleteSpace E",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Min.min",
  "constType": "{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["id",
   "HMul.hMul",
   "mul_assoc",
   "Eq.mpr",
   "HPow.hPow",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_pf_left",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {aâ‚ƒ b c : R} (aâ‚ : R) (aâ‚‚ : â„•), aâ‚ƒ * b = c â†’ aâ‚ ^ aâ‚‚ * aâ‚ƒ * b = aâ‚ ^ aâ‚‚ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Dvd.dvd",
   "dvd_rfl",
   "outParam",
   "Iff.mpr",
   "CharP.cast_eq_zero_iff",
   "OfNat.ofNat"],
  "name": "CharP.cast_eq_zero",
  "constType":
  "âˆ€ (R : Type u_1) [inst : AddMonoidWithOne R] (p : â„•) [CharP R p], â†‘p = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "add_left_comm",
   "Eq.trans",
   "of_eq_true",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a bâ‚‚ c : R} (bâ‚ : R), a + bâ‚‚ = c â†’ a + (bâ‚ + bâ‚‚) = bâ‚ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_bound",
   "HMul.hMul",
   "ContinuousLinearMap.le_of_opNorm_le",
   "DFunLike.coe",
   "OfNat.ofNat"],
  "name": "ContinuousLinearMap.opNorm_le_iff",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] {f : E â†’SL[Ïƒâ‚â‚‚] F}\n  {M : â„}, 0 â‰¤ M â†’ (â€–fâ€– â‰¤ M â†” âˆ€ (x : E), â€–f xâ€– â‰¤ M * â€–xâ€–)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_add",
   "Nat.cast_one",
   "HAdd.hAdd",
   "Nat.cast",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Decidable.decide",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "congrArg"],
  "name": "one_add_one_eq_two",
  "constType": "âˆ€ {R : Type u_1} [inst : AddMonoidWithOne R], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references": ["Set.univ", "Equiv.Set.univ", "Equiv.finite_iff", "Set.Elem"],
  "name": "Set.finite_univ_iff",
  "constType": "âˆ€ {Î± : Type u}, Set.univ.Finite â†” Finite Î±",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Set", "Membership.mem", "Eq.ndrec"],
  "name": "AddSubsemigroup.mk.congr_simp",
  "constType":
  "âˆ€ {M : Type u_3} [inst : Add M] (carrier carrier_1 : Set M) (e_carrier : carrier = carrier_1)\n  (add_mem' : âˆ€ {a b : M}, a âˆˆ carrier â†’ b âˆˆ carrier â†’ a + b âˆˆ carrier),\n  { carrier := carrier, add_mem' := add_mem' } = { carrier := carrier_1, add_mem' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "HasQuotient.Quotient",
   "Membership.mem",
   "NNReal.toReal",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh",
   "Subtype.val",
   "DFunLike.coe",
   "congrArg",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_3",
   "Subtype.prop",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_4",
   "Dist.dist",
   "HSub.hSub",
   "QuotientAddGroup.mk'",
   "dist_self",
   "Exists.choose_spec",
   "Norm.norm",
   "Set",
   "NNReal",
   "And.right",
   "Submodule.toAddSubgroup",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "Metric.closedBall",
   "StrictAnti",
   "lt_add_one",
   "Nat.le_succ",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhh",
   "of_eq_true",
   "Antitone",
   "LE.le",
   "id",
   "QuotientAddGroup.mk"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh_prop",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Submodule ğ•œ E} â¦ƒc : â„• â†’ E â§¸ Fâ¦„ â¦ƒr : â„• â†’ NNRealâ¦„\n  (hr : StrictAnti r) (hanti : Antitone fun i â†¦ Metric.closedBall (c i) â†‘(r i)) (i' : â„•),\n  â€–â†‘(SphericallyCompleteSpace.hhhhâœ ğ•œ hr hanti (i' + 2)) - â†‘(SphericallyCompleteSpace.hhhhâœÂ¹ ğ•œ hr hanti (i' + 1))â€– <\n    â†‘(r i')",
  "constCategory": "Theorem"},
 {"references": ["Submodule.mem_bot", "DFunLike.coe"],
  "name": "LinearMap.mem_ker",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {y : M}, y âˆˆ f.ker â†” f y = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "div_one", "id", "Eq.mpr", "OfNat.ofNat", "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
  "constType":
  "âˆ€ {M : Type u_1} [inst : DivInvOneMonoid M] {l l_n n : M}, l = l_n / 1 â†’ l_n = n â†’ l = n",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "Function.invFun", "Function.invFun_eq", "Function.Injective"],
  "name": "Function.leftInverse_invFun",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} [inst : Nonempty Î±] {f : Î± â†’ Î²},\n  Function.Injective f â†’ Function.LeftInverse (Function.invFun f) f",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id", "SphericallyCompleteSpace.OrthProj", "Membership.mem"],
  "name": "SphericallyCompleteSpace.OrthProj.congr_simp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F],\n  SphericallyCompleteSpace.OrthProj ğ•œ F = SphericallyCompleteSpace.OrthProj ğ•œ F",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    {motive : SphericallyCompleteSpace.IsSphericallyDense Î± â†’ Sort u} â†’\n      ((spherically_dense : âˆ€ (c : Î±) (r : NNReal), Metric.diam (Metric.closedBall c â†‘r) = â†‘r) â†’ motive â‹¯) â†’\n        (t : SphericallyCompleteSpace.IsSphericallyDense Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Mathlib.Tactic.Linarith.lt_of_lt_of_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "Submodule.span",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Module.finrank_prod",
   "Module.finrank",
   "RingHom.id",
   "sub_eq_zero_of_eq",
   "Eq.symm",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.sub_pf",
   "add_comm",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.MOrth",
   "Neg.neg",
   "Submodule.module._proof_1",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth",
   "Exists.casesOn",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.mpr",
   "id",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "FiniteDimensional.nonempty_continuousLinearEquiv_iff_finrank_eq",
   "Nat.cast",
   "Mathlib.Tactic.Zify.natCast_eq._simp_1",
   "Eq.mp",
   "FiniteDimensional",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "finrank_span_singleton",
   "Subspace",
   "congrArg",
   "LinearIsometryEquiv.toContinuousLinearEquiv",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "lt_of_not_ge",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "_private.SphericalCompleteness.NormedVectorSpace.Basic.0.SphericallyCompleteSpace.induction_sphericallyCompleteSpace_of_finiteDimensional._simp_1_1",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "LinearIsometryEquiv.toIsometryEquiv",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Ne",
   "neg_neg_of_pos",
   "And.casesOn"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Basic.0.SphericallyCompleteSpace.induction_sphericallyCompleteSpace_of_finiteDimensional",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] [SphericallyCompleteSpace ğ•œ] (E : Type u_2)\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] [IsUltrametricDist E] [FiniteDimensional ğ•œ E],\n  âˆ€ n < Module.finrank ğ•œ E,\n    (âˆƒ M, Module.finrank ğ•œ â†¥M = n âˆ§ SphericallyCompleteSpace â†¥M) â†’\n      âˆƒ M', Module.finrank ğ•œ â†¥M' = n + 1 âˆ§ SphericallyCompleteSpace â†¥M'",
  "constCategory": "Theorem"},
 {"references": ["mt"],
  "name": "Mathlib.Tactic.Contrapose.contraposeâ‚„",
  "constType": "âˆ€ {p q : Prop}, (q â†’ p) â†’ Â¬p â†’ Â¬q",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "NNReal.toReal",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball._proof_1",
   "GT.gt",
   "Subtype.val",
   "Set.Countable",
   "Set.Elem",
   "congrArg",
   "Dense",
   "Prod.fst",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball._proof_3",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball",
   "Eq.symm",
   "Denumerable.ofNat",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "Not",
   "Set",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
   "NNReal",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "eq_self",
   "Metric.closedBall",
   "of_eq_true",
   "HasSubset.Subset",
   "NNDist.nndist",
   "id",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball.eq_def",
   "Eq.mpr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball.match_1",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "TopologicalSpace.SeparableSpace.exists_countable_dense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_radius_eq",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [hiud : IsUltrametricDist Î±]\n  [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] [nemp : Nonempty Î±] [hsep : TopologicalSpace.SeparableSpace Î±]\n  (hÎ±' : Denumerable â†‘â‹¯.choose) (n : â„•),\n  (SphericallyCompleteSpace.funk_chain_of_ballâœ hÎ±' n).2 = SphericallyCompleteSpace.funk_radiusâœ Î± n",
  "constCategory": "Theorem"},
 {"references": ["Metric.ediam", "Set", "ENNReal.toReal"],
  "name": "Metric.diam",
  "constType": "{Î± : Type u} â†’ [PseudoMetricSpace Î±] â†’ Set Î± â†’ â„",
  "constCategory": "Definition"},
 {"references": ["Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons",
  "constType":
  "{M : Type u_1} â†’ â„¤ Ã— M â†’ Mathlib.Tactic.FieldSimp.NF M â†’ Mathlib.Tactic.FieldSimp.NF M",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.T",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’\n        [inst_2 : IsUltrametricDist E] â†’\n          [inst_3 : NormedSpace ğ•œ E] â†’\n            {D : Submodule ğ•œ E} â†’\n              {F : Type u_3} â†’\n                [inst_4 : SeminormedAddCommGroup F] â†’\n                  [inst_5 : IsUltrametricDist F] â†’\n                    [inst_6 : NormedSpace ğ•œ F] â†’\n                      [inst_7 : SphericallyCompleteSpace F] â†’\n                        {S : â†¥D â†’L[ğ•œ] F} â†’\n                          {ğ’° : Set (E â†’L[ğ•œ] F)} â†’\n                            {hğ’° : ğ’°.Nonempty} â†’\n                              {Îµ : â†‘ğ’° â†’ â„} â†’\n                                (self : SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ) â†’\n                                  â†¥(SphericallyCompleteSpace.PartialExtension.Mâœ self) â†’L[ğ•œ] F",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Norm.norm",
   "LinearMap.range",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "HAdd.hAdd",
   "LinearIsometry.toLinearMap",
   "RingHom.id",
   "LE.le",
   "Subtype.property",
   "HSMul.hSMul"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) (M : Submodule ğ•œ Eâ‚€) (hc : f.range â‰¤ M) (x : â†¥f.range),\n  â€–{ toFun := fun x â†¦ âŸ¨â†‘x, â‹¯âŸ©, map_add' := â‹¯, map_smul' := â‹¯ } xâ€– =\n    â€–{ toFun := fun x â†¦ âŸ¨â†‘x, â‹¯âŸ©, map_add' := â‹¯, map_smul' := â‹¯ } xâ€–",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name": "SphericallyCompleteSpace.câ‚€._simp_2",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LT Î±] {x y : Î±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id._proof_3",
   "RingHom.id._proof_4",
   "id",
   "RingHom.id._proof_2",
   "RingHom.id._proof_1"],
  "name": "RingHom.id",
  "constType": "(Î± : Type u_5) â†’ [inst : NonAssocSemiring Î±] â†’ Î± â†’+* Î±",
  "constCategory": "Definition"},
 {"references": ["rfl"],
  "name": "Eq.symm",
  "constType": "âˆ€ {Î± : Sort u} {a b : Î±}, a = b â†’ b = a",
  "constCategory": "Theorem"},
 {"references": ["CommMagma.mul_comm"],
  "name": "mul_comm",
  "constType": "âˆ€ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.normalize_sat",
   "Lean.Omega.normalizeCoeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.tidyCoeffs",
   "Prod.fst",
   "congrArg",
   "Lean.Omega.positivize?_eq_some",
   "Lean.Omega.positivizeConstraint",
   "Lean.Omega.positivizeCoeffs",
   "Eq.symm",
   "Eq.ndrec",
   "Lean.Omega.normalize",
   "Lean.Omega.normalizeConstraint",
   "Lean.Omega.positivize?",
   "Lean.Omega.normalize?",
   "Lean.Omega.positivize_sat",
   "Lean.Omega.tidy?.match_1",
   "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
   "Option.getD",
   "Lean.Omega.tidyConstraint",
   "Prod.snd",
   "Unit",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.normalize?_eq_some",
   "id",
   "Lean.Omega.Constraint.sat'",
   "And.casesOn"],
  "name": "Lean.Omega.tidy_sat",
  "constType":
  "âˆ€ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true â†’ (Omega.tidyConstraint s x).sat' (Omega.tidyCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddHom.toFun",
  "constType":
  "{M : Type u_10} â†’ {N : Type u_11} â†’ [inst : Add M] â†’ [inst_1 : Add N] â†’ (M â†’â‚™+ N) â†’ M â†’ N",
  "constCategory": "Definition"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) (M : Submodule ğ•œ Eâ‚€), f.range â‰¤ M â†’ âˆ€ (x : â†¥f.range), â†‘x âˆˆ M",
  "constCategory": "Theorem"},
 {"references": ["rfl", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
  "constType":
  "âˆ€ (M : Type u_1) [inst : GroupWithZero M], 1 = Mathlib.Tactic.FieldSimp.NF.eval []",
  "constCategory": "Theorem"},
 {"references": ["Submodule.comap", "Bot.bot"],
  "name": "LinearMap.ker",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {M : Type u_5} â†’\n      {Mâ‚‚ : Type u_7} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            [inst_2 : AddCommMonoid M] â†’\n              [inst_3 : AddCommMonoid Mâ‚‚] â†’\n                [inst_4 : _root_.Module R M] â†’\n                  [inst_5 : _root_.Module Râ‚‚ Mâ‚‚] â†’ {Ï„â‚â‚‚ : R â†’+* Râ‚‚} â†’ (M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) â†’ Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_finiteDimensional._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, (dist x y â‰¤ â†‘c) = (nndist x y â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "invertibleOne",
   "Nat.cast",
   "Invertible.invOf",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "invOf_one'",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNNRat.to_isNat.match_1_1",
   "OfNat.ofNat",
   "congrArg",
   "Invertible.congr",
   "eq_self",
   "of_eq_true"],
  "name": "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] {a : Î±} {n : â„•},\n  Mathlib.Meta.NormNum.IsNNRat a n 1 â†’ Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["congrArg"],
  "name": "congr_arg",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Membership.mem.out",
   "Subtype.val",
   "DFunLike.coe",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.IsImmediate",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LE.le",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_3",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  âŸ¨(SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) (x + x_1), â‹¯âŸ© =\n    âŸ¨(SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) (x + x_1), â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Submodule.toAddSubmonoid",
   "AddSubmonoid.coe_iSup_of_directed",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "Set.iUnion",
   "Directed",
   "le_iSup",
   "iSup_le",
   "AddSubsemigroup.carrier",
   "Set.mem_iUnion",
   "iSup",
   "SetLike.coe",
   "Submodule.smul_mem'",
   "Iff.mpr",
   "HSMul.hSMul",
   "LE.le",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0.Submodule.coe_iSup_of_directed.match_1_1",
   "Eq.symm",
   "Set.iUnion_subset",
   "AddSubmonoid.toAddSubsemigroup",
   "le_antisymm",
   "AddSubmonoid.copy"],
  "name": "Submodule.coe_iSup_of_directed",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {Î¹ : Sort u_9} [Nonempty Î¹] (S : Î¹ â†’ Submodule R M), Directed (fun x1 x2 â†¦ x1 â‰¤ x2) S â†’ â†‘(iSup S) = â‹ƒ i, â†‘(S i)",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Int.natCast_nonneg",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_11",
  "constType": "âˆ€ n â‰¥ 1, âˆ€ (k : â„•), k + 1 â‰¥ n + 1 â†’ Â¬k - 1 + 2 = k + 1 â†’ False",
  "constCategory": "Theorem"},
 {"references": ["And.right", "trivial", "propext"],
  "name": "true_and",
  "constType": "âˆ€ (p : Prop), (True âˆ§ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "norm_eq_zero",
   "Eq.mp",
   "Metric.infDist_zero_of_mem",
   "Membership.mem",
   "Iff.mp",
   "Subspace",
   "OfNat.ofNat",
   "congrArg",
   "SetLike.coe",
   "id",
   "Eq.symm",
   "Metric.infDist",
   "SphericallyCompleteSpace.MOrth"],
  "name": "SphericallyCompleteSpace.eq_zero_of_morth_of_mem",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ğ•œ E},\n  x âˆˆ F â†’ SphericallyCompleteSpace.MOrth ğ•œ x F â†’ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "sub_neg_eq_add",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "zero_add",
   "dist_triangle",
   "congr",
   "LE.le",
   "Dist.dist",
   "HSub.hSub",
   "dist_eq_norm_sub"],
  "name": "norm_add_le",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), â€–a + bâ€– â‰¤ â€–aâ€– + â€–bâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "IsBoundedLinearMap.toContinuousLinearMap.match_1",
   "HMul.hMul",
   "LinearMap.toAddHom",
   "IsBoundedLinearMap.bound",
   "AddMonoidHomClass.continuous_of_bound",
   "DFunLike.coe",
   "OfNat.ofNat",
   "IsBoundedLinearMap.toLinearMap",
   "LT.lt",
   "RingHom.id",
   "LE.le",
   "AddHom.toFun"],
  "name": "IsBoundedLinearMap.toContinuousLinearMap._proof_1",
  "constType":
  "âˆ€ {ğ•œ : Type u_3} {E : Type u_1} {F : Type u_2} [inst : Semiring ğ•œ] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : _root_.Module ğ•œ E] [inst_3 : SeminormedAddCommGroup F] [inst_4 : _root_.Module ğ•œ F] (f : E â†’ F)\n  (hf : IsBoundedLinearMap ğ•œ f), Continuous (IsBoundedLinearMap.toLinearMap f hf).toFun",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "AddHomClass.map_add"],
  "name": "map_add",
  "constType":
  "âˆ€ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Add M] [inst_1 : Add N] [inst_2 : FunLike F M N]\n  [AddHomClass F M N] (f : F) (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "trivial"],
  "name": "implies_true",
  "constType": "âˆ€ (Î± : Sort u), (âˆ€ (a : Î±), True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Exists.choose_spec",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthProj",
   "And.right",
   "Exists.choose",
   "Subtype.val",
   "DFunLike.coe",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "RingHom.id",
   "LE.le",
   "id"],
  "name": "SphericallyCompleteSpace.norm_OrthProj_le_one",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F],\n  â€–SphericallyCompleteSpace.OrthProj ğ•œ Fâ€– â‰¤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_5",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LE.le", "setOf"],
  "name": "Set.Ioc",
  "constType": "{Î± : Type u_1} â†’ [Preorder Î±] â†’ Î± â†’ Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_3",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_4",
   "LinearIsometry.toLinearMap",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "RingHom.id",
   "LinearMap.range",
   "Membership.mem",
   "Function.invFun",
   "Set.rangeFactorization",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_1",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_2",
   "DFunLike.coe"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {F : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup F] â†’ [inst_4 : NormedSpace ğ•œ F] â†’ (f : E â†’â‚—áµ¢[ğ•œ] F) â†’ â†¥f.range â†’â‚—áµ¢[ğ•œ] E",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top.top",
  "constType": "{Î± : Type u_1} â†’ [self : Top Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_5",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.mpr",
  "constType": "{Î± Î² : Sort u} â†’ Î± = Î² â†’ Î² â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_5",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, (dist x y â‰¤ â†‘c) = (nndist x y â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "Membership.mem",
   "LE.le",
   "id",
   "Eq.mpr",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Metric.mem_closedBall_self",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, 0 â‰¤ Îµ â†’ x âˆˆ Metric.closedBall x Îµ",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Elem"],
  "name": "Set.Finite",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Bind.bind",
   "Lean.MonadRef.withRef",
   "Lean.MonadRef.getRef",
   "Lean.replaceRef"],
  "name": "Lean.withRef",
  "constType":
  "{m : Type â†’ Type} â†’ [Monad m] â†’ [MonadRef m] â†’ {Î± : Type} â†’ Syntax â†’ m Î± â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["iff_self",
   "Eq.trans",
   "of_eq_true",
   "SetLike.coe_eq_coe",
   "Membership.mem",
   "Eq.symm",
   "Subtype.val",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "AddSubmonoid.mk_eq_zero",
  "constType":
  "âˆ€ {M : Type u_4} [inst : AddZeroClass M] (S : AddSubmonoid M) {a : M} {ha : a âˆˆ S}, âŸ¨a, haâŸ© = 0 â†” a = 0",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "StrictMono",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [Preorder Î±] â†’ [Preorder Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["HDiv.hDiv",
   "HAdd.hAdd",
   "Eq.symm",
   "id",
   "add_div",
   "add_self_div_two",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "add_halves",
  "constType":
  "âˆ€ {K : Type u_1} [inst : DivisionSemiring K] [NeZero 2] (a : K), a / 2 + a / 2 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Submodule.mem_bot", "Bot.bot", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_3",
  "constType":
  "âˆ€ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x âˆˆ âŠ¥) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "forall_eq._simp_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) = p a'",
  "constCategory": "Theorem"},
 {"references": ["LinearIsometry.coe_injective", "funext", "DFunLike.coe"],
  "name": "LinearIsometry.ext",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup Eâ‚‚] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module Râ‚‚ Eâ‚‚] {f g : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚}, (âˆ€ (x : E), f x = g x) â†’ f = g",
  "constCategory": "Theorem"},
 {"references":
  ["PadicAlgCl",
   "NNReal",
   "PadicComplex",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric",
   "Padic",
   "Nat.Prime"],
  "name":
  "SphericallyCompleteSpace.instPadicComplex_not_sphercallyCompleteSpace",
  "constType":
  "âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)], Â¬SphericallyCompleteSpace â„‚_[p]",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "Neg.neg",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "mul_assoc",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.zpow'_neg",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "mul_inv",
   "congrArg",
   "Prod.fst",
   "HDiv.hDiv",
   "eq_self",
   "of_eq_true",
   "congr",
   "Eq.symm",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.div_eq_evalâ‚ƒ",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] {aâ‚ : â„¤ Ã— M} (aâ‚‚ : â„¤ Ã— M) {lâ‚ lâ‚‚ l : Mathlib.Tactic.FieldSimp.NF M},\n  (aâ‚ ::áµ£ lâ‚).eval / lâ‚‚.eval = l.eval â†’ (aâ‚ ::áµ£ lâ‚).eval / (aâ‚‚ ::áµ£ lâ‚‚).eval = ((-aâ‚‚.1, aâ‚‚.2) ::áµ£ l).eval",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isInt_neg.match_1_1",
   "Neg.neg",
   "Eq.symm",
   "Int.neg",
   "Int.cast",
   "Int.cast_neg"],
  "name": "Mathlib.Meta.NormNum.isInt_neg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {f : Î± â†’ Î±} {a : Î±} {a' b : â„¤},\n  f = Neg.neg â†’ Mathlib.Meta.NormNum.IsInt a a' â†’ a'.neg = b â†’ Mathlib.Meta.NormNum.IsInt (-a) b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LinearIsometry.toLinearMap",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) (M : Submodule ğ•œ Eâ‚€), f.range â‰¤ M â†’ âˆ€ (x x_1 : â†¥f.range), â†‘(x + x_1) âˆˆ M",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_14",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "le_of_not_gt",
   "StrictAnti.antitone",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "norm_zero",
   "rfl",
   "sub_self",
   "Norm.norm",
   "NNReal",
   "Nat.recAux",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_11",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.mk_eq_and_norm_sub_lt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_15",
   "Nat.le_succ",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "Nat.rawCast",
   "max_le",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "HasQuotient.Quotient",
   "Mathlib.Tactic.Ring.add_mul",
   "Nat.le_add_left",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "congr",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_9",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_8",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "ENNReal.top_ne_zero",
   "Memâ„“p.neg",
   "HPow.hPow",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Max.max",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_10",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "QuotientAddGroup.mk",
   "inferInstance",
   "dite",
   "neg_neg_of_pos",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "HMul.hMul",
   "Int.rawCast",
   "SphericallyCompleteSpace.câ‚€",
   "sub_add_sub_cancel",
   "GE.ge",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_13",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "zero_memâ„“p",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "QuotientAddGroup.mk'",
   "And.left",
   "Memâ„“p.add",
   "Neg.neg",
   "And.right",
   "lt_of_le_of_lt",
   "Mathlib.Tactic.Ring.mul_zero",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "Submodule.toAddSubgroup",
   "BddAbove",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "lp.norm_apply_le_norm",
   "Nat.cast_zero",
   "Iff.mpr",
   "id",
   "memâ„“p_infty",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_6",
   "Nat.cast",
   "IsUltrametricDist.norm_add_le_max",
   "lp",
   "Eq.mp",
   "Metric.mem_closedBall",
   "le_trans",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "bddAbove_def",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_12",
   "Subtype.prop",
   "Memâ„“p",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "dist_self",
   "PreLp",
   "Set.Nonempty",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "lt_add_one",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_7",
   "Mathlib.Tactic.Ring.neg_congr",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Nat.le_add_right"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_2) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] [âˆ€ (i : â„•), IsUltrametricDist (E i)],\n  SphericallyCompleteSpace (â†¥(lp E âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ E)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Memâ„“p",
   "zero_memâ„“p",
   "forall_congr",
   "funext",
   "Set.range_const",
   "PreLp",
   "Memâ„“p.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Memâ„“p.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "Iff.mpr",
   "LE.le",
   "HSMul.hSMul",
   "id",
   "Top.top",
   "Eq.mpr",
   "memâ„“p_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_6",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (c : ğ•œ) (x : E), (fun x_1 â†¦ c â€¢ x) âˆˆ lp (fun x â†¦ E) âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm", "dist_zero_left", "Dist.dist", "funext", "OfNat.ofNat"],
  "name": "dist_zero",
  "constType": "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E], dist 0 = norm",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Top.top", "lt_top_iff_ne_top", "Iff.not_left"],
  "name": "not_lt_top_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PartialOrder Î±] [inst_1 : OrderTop Î±] {a : Î±}, Â¬a < âŠ¤ â†” a = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap.bound",
   "RingHom.id",
   "DFunLike.coe",
   "LinearMap.isLinear"],
  "name": "ContinuousLinearMap.isBoundedLinearMap",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (f : E â†’L[ğ•œ] F), IsBoundedLinearMap ğ•œ â‡‘f",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_11",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.PropLemmas.0.exists_and_left.match_1_1",
   "_private.Init.PropLemmas.0.exists_and_left.match_1_3"],
  "name": "exists_and_left",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, b âˆ§ p x) â†” b âˆ§ âˆƒ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set.Nonempty",
   "Set",
   "Antitone",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter"],
  "name": "SphericallyCompleteSpace.recOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    {motive : SphericallyCompleteSpace Î± â†’ Sort u} â†’\n      (t : SphericallyCompleteSpace Î±) â†’\n        ((isSphericallyComplete :\n              âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n                (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’\n                  (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty) â†’\n            motive â‹¯) â†’\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_iUnion", "Set", "Membership.mem", "Set.iUnion", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_6",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹ƒ i, s i) = âˆƒ i, x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_prop", "Set", "Membership.mem", "eq_true", "Subtype.val"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_8",
  "constType":
  "âˆ€ {Î± : Type u_1} {S : Set Î±} (a : { a // a âˆˆ S }), (â†‘a âˆˆ S) = True",
  "constCategory": "Theorem"},
 {"references": ["Left.mul_nonneg"],
  "name": "mul_nonneg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : MulZeroClass Î±] {a b : Î±} [inst_1 : Preorder Î±] [PosMulMono Î±], 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 â‰¤ a * b",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl", "GE.ge"],
  "name": "ge_iff_le",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, x â‰¥ y â†” y â‰¤ x",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "LinearIsometry.isometry",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€",
   "DFunLike.coe",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.sphericalCompletion_minimal",
   "LinearIsometryEquiv.symm",
   "RingHom.id",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Isometry.isometryEquivOnRange",
   "LinearIsometryEquiv.toIsometryEquiv",
   "Exists.choose",
   "Function.Surjective",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_eq_sphericalCompletion",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace E â†” Function.Surjective â‡‘(SphericallyCompleteSpace.SphericalCompletionEmbedding ğ•œ E)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_8",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_or", "propext"],
  "name": "not_or._simp_2",
  "constType": "âˆ€ {p q : Prop}, (Â¬(p âˆ¨ q)) = (Â¬p âˆ§ Â¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Norm.norm",
   "ite",
   "ENNReal.top_ne_zero._simp_1",
   "SummationFilter.unconditional",
   "ite_cond_eq_true",
   "HPow.hPow",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "BddAbove",
   "Set.range",
   "congrArg",
   "Summable",
   "eq_self",
   "ENNReal",
   "iff_self",
   "of_eq_true",
   "ENNReal.toReal",
   "Top.top",
   "Ne",
   "Set.Finite",
   "setOf"],
  "name": "memâ„“p_infty_iff",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {f : (i : Î±) â†’ E i},\n  Memâ„“p f âŠ¤ â†” BddAbove (Set.range fun i â†¦ â€–f iâ€–)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.ndrec"],
  "name": "AddHom.mk.congr_simp",
  "constType":
  "âˆ€ {M : Type u_10} {N : Type u_11} [inst : Add M] [inst_1 : Add N] (toFun toFun_1 : M â†’ N) (e_toFun : toFun = toFun_1)\n  (map_add' : âˆ€ (x y : M), toFun (x + y) = toFun x + toFun y),\n  { toFun := toFun, map_add' := map_add' } = { toFun := toFun_1, map_add' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references":
  ["not_le_of_gt", "LT.lt", "le_of_lt", "le_trans", "LE.le", "lt_of_le_not_ge"],
  "name": "lt_of_lt_of_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b c : Î±}, a < b â†’ b â‰¤ c â†’ a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.biUnion_of_singleton",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq.symm",
   "id",
   "Set.Finite.isClosed_biUnion",
   "Set.iUnion",
   "Eq.mpr",
   "Set.Finite",
   "isClosed_singleton",
   "congrArg"],
  "name": "Set.Finite.isClosed",
  "constType":
  "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [T1Space X] {s : Set X}, s.Finite â†’ IsClosed s",
  "constCategory": "Theorem"},
 {"references": ["rfl", "eq_true"],
  "name": "eq_self",
  "constType": "âˆ€ {Î± : Sort u_1} (a : Î±), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Metric.diam",
   "csInf_le_csInf'",
   "Set.iInter",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "dist_le_coe",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_4",
   "le_of_not_gt",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "rfl",
   "NNReal",
   "IsUltrametricDist.dist_triangle_max",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "NNDist.nndist",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "diam_le_radius_of_ultrametric",
   "Mathlib.Tactic.Ring.add_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_6",
   "Metric.dist_le_diam_of_mem",
   "and_true",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "InfSet.sInf",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_2",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_7",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_8",
   "HPow.hPow",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "Nat.cast_add",
   "eq_self",
   "Metric.closedBall",
   "Max.max",
   "OrderBot.bddBelow",
   "antitone_nat_of_succ_le",
   "neg_neg_of_pos",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_10",
   "And.casesOn",
   "Mathlib.Tactic.Ring.zero_mul",
   "Nat.cast_one",
   "le_refl",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Metric.isBounded_closedBall",
   "Membership.mem",
   "Int.rawCast",
   "HMul.hMul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_5",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_3",
   "csInf_le",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_9",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Exists.casesOn",
   "Mathlib.Tactic.Ring.atom_pf",
   "HasSubset.Subset",
   "Iff.mpr",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "max_le_iff",
   "NNReal.toReal",
   "le_csInf_iff''",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "dist_self",
   "Set.Nonempty",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.add_congr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_1",
   "LT.lt",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [iud : IsUltrametricDist Î±],\n  SphericallyCompleteSpace Î± â†”\n    âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n      Antitone ri â†’\n        (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.node5",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "SphericallyCompleteSpace._aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___unexpand_SphericallyCompleteSpace_Orth_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_22",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, (dist x y â‰¤ â†‘c) = (nndist x y â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Subtype.prop",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "id",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_2",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (z : â†¥(ğ•œ âˆ™ x) Ã— â†¥F), â†‘z.1 + â†‘z.2 âˆˆ ğ•œ âˆ™ x + F",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "NNReal",
   "NNDist.nndist",
   "NNReal.coe_eq_zero",
   "NNReal.toReal",
   "Iff.mp",
   "OfNat.ofNat"],
  "name": "nndist_self",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (a : Î±), nndist a a = 0",
  "constCategory": "Theorem"},
 {"references": ["le_antisymm"],
  "name": "eq_of_le_of_ge",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["Module.add_smul"],
  "name": "add_smul",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (r s : R)\n  (x : M), (r + s) â€¢ x = r â€¢ x + s â€¢ x",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_forall", "propext"],
  "name": "Mathlib.Tactic.Push.not_forall_eq",
  "constType": "âˆ€ {Î± : Sort u_1} (s : Î± â†’ Prop), (Â¬âˆ€ (x : Î±), s x) = âˆƒ x, Â¬s x",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_15",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp", "Membership.mem", "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.OrthComp.congr_simp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F F_1 : Submodule ğ•œ E) (e_F : F = F_1)\n  [inst_3 : SphericallyCompleteSpace â†¥F],\n  SphericallyCompleteSpace.OrthComp ğ•œ F = SphericallyCompleteSpace.OrthComp ğ•œ F_1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "IsLinearMap.mk'",
   "Eq.trans",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_4",
   "Classical.propDecidable",
   "LinearMap.toAddHom",
   "Set.iInter",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "StrictAnti.comp_strictMono",
   "zero_le",
   "RingHom.id",
   "congrFun",
   "Eq.symm",
   "Classical.not_not._simp_3",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_7",
   "AddHom.toFun",
   "Eq.ndrec",
   "norm_zero",
   "rfl",
   "sub_self",
   "Norm.norm",
   "Exists.choose_spec",
   "NNReal",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_6",
   "MulZeroClass.mul_zero",
   "true_and",
   "implies_true",
   "Filter.atTop",
   "Antitone",
   "Submodule.mem_bot",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "Exists.choose.congr_simp",
   "StrictMono",
   "dist_eq_norm",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_5",
   "congr",
   "Nat.lt_succ_self",
   "map_zero",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_2",
   "propext",
   "exists_bijective_subseq_of_finite_duplication",
   "Set",
   "dist_comm",
   "StrictMono.tendsto_atTop",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Set.univ",
   "eq_self",
   "Metric.closedBall",
   "and_self",
   "Max.max",
   "inferInstance",
   "Ne",
   "dite",
   "Mathlib.Tactic.Push.not_forall_eq",
   "Function.Injective",
   "And.casesOn",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "GT.gt",
   "trichotomous",
   "eq_of_heq",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "max_eq_left",
   "Filter.Tendsto",
   "And.left",
   "binderNameHint",
   "lt_of_le_of_lt",
   "And.right",
   "add_zero",
   "Bot.bot",
   "Exists.casesOn",
   "Set.image",
   "max_self",
   "HSMul.hSMul",
   "id",
   "smul_zero",
   "Eq.mp",
   "Metric.mem_closedBall",
   "NNReal.toReal",
   "DFunLike.coe",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "SphericallyCompleteSpace.exists_extension_opNorm_le",
   "Subtype.prop",
   "Dist.dist",
   "continuous_of_const",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_1",
   "Not",
   "dist_self",
   "Classical.not_imp._simp_2",
   "Set.Nonempty",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_3",
   "Function.comp",
   "StrictMono.monotone",
   "Exists.choose",
   "Eq.casesOn",
   "LT.lt",
   "Or.casesOn",
   "StrictAnti",
   "of_eq_true",
   "le_of_lt",
   "Filter.tendsto_atTop_atTop_iff_of_monotone",
   "LE.le",
   "max_eq_right"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] {F : Type u_3} [inst_4 : SeminormedAddCommGroup F]\n  [IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F] [SphericallyCompleteSpace F], SphericallyCompleteSpace (E â†’L[ğ•œ] F)",
  "constCategory": "Theorem"},
 {"references": ["Left.add_pos'"],
  "name": "add_pos'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : Preorder Î±] [AddLeftMono Î±] {a b : Î±}, 0 < a â†’ 0 < b â†’ 0 < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "zero_add",
   "Eq.trans",
   "of_eq_true",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "âˆ€ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "le_of_le_of_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} {a b c : Î±} [inst : LE Î±], a â‰¤ b â†’ b = c â†’ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inter.inter",
  "constType": "{Î± : Type u} â†’ [self : Inter Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’\n        [inst_2 : IsUltrametricDist E] â†’\n          [inst_3 : NormedSpace ğ•œ E] â†’\n            {D : Submodule ğ•œ E} â†’\n              {F : Type u_3} â†’\n                [inst_4 : SeminormedAddCommGroup F] â†’\n                  [inst_5 : IsUltrametricDist F] â†’\n                    [inst_6 : NormedSpace ğ•œ F] â†’\n                      [inst_7 : SphericallyCompleteSpace F] â†’\n                        {S : â†¥D â†’L[ğ•œ] F} â†’\n                          {ğ’° : Set (E â†’L[ğ•œ] F)} â†’\n                            {hğ’° : ğ’°.Nonempty} â†’\n                              {Îµ : â†‘ğ’° â†’ â„} â†’ SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ â†’ Submodule ğ•œ E",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "lp",
   "Membership.mem",
   "GT.gt",
   "GE.ge",
   "Subtype.val",
   "congrArg",
   "SphericallyCompleteSpace.câ‚€._simp_2",
   "funext",
   "forall_congr",
   "norm_zero",
   "PreLp",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.câ‚€._simp_3",
   "SphericallyCompleteSpace.câ‚€._simp_4",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.câ‚€._simp_1",
   "LT.lt",
   "ENNReal",
   "le_of_lt",
   "LE.le",
   "Top.top",
   "id",
   "Eq.mpr",
   "setOf"],
  "name": "SphericallyCompleteSpace.câ‚€._proof_3",
  "constType":
  "âˆ€ (E : â„• â†’ Type u_1) [inst : (i : â„•) â†’ NormedAddCommGroup (E i)], 0 âˆˆ {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ}",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Iff.rfl",
   "Set.singleton_subset_iff",
   "congrArg",
   "SetLike.mem_coe",
   "SetLike.coe",
   "HasSubset.Subset",
   "Submodule.span_le",
   "LE.le",
   "id",
   "Eq.mpr",
   "propext"],
  "name": "Submodule.span_singleton_le_iff_mem",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (m : M)\n  (p : Submodule R M), R âˆ™ m â‰¤ p â†” m âˆˆ p",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.coe_eq_zero",
   "Membership.mem",
   "Subtype.val",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_14",
  "constType":
  "âˆ€ {A : Type u_3} {Mâ‚ : Type u_4} [inst : SetLike A Mâ‚] [inst_1 : Zero Mâ‚] [hA : ZeroMemClass A Mâ‚] {S' : A} {x : â†¥S'},\n  (â†‘x = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec"],
  "name": "Subtype.mk.congr_simp",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} (val val_1 : Î±) (e_val : val = val_1) (property : p val), âŸ¨val, propertyâŸ© = âŸ¨val_1, â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "HasQuotient.Quotient",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Memâ„“p",
   "zero_memâ„“p",
   "forall_congr",
   "funext",
   "Set.range_const",
   "QuotientAddGroup.mk'",
   "rfl",
   "PreLp",
   "Memâ„“p.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Memâ„“p.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "HAdd.hAdd",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "Iff.mpr",
   "LE.le",
   "Top.top",
   "id",
   "Eq.mpr",
   "memâ„“p_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_5",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x y : E),\n  (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup) âŸ¨fun x_1 â†¦ x + y, â‹¯âŸ© =\n    (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup) âŸ¨fun x_1 â†¦ x + y, â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "left_eq_sup", "propext"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (a = a âŠ” b) = (b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "Submodule.toAddSubmonoid",
   "HasQuotient.Quotient",
   "lp",
   "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€._proof_1",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "AddSubsemigroup.carrier",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
   "Top.top",
   "inferInstance",
   "AddSubmonoid.toAddSubsemigroup"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u_2) â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’ NormedAddCommGroup (â†¥(lp (fun x â†¦ E) âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E)",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "PreLp",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.câ‚€",
   "Submodule.toAddSubgroup"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_2",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup.Normal",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "add_left_comm",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {aâ‚ aâ‚‚ bâ‚ bâ‚‚ câ‚ câ‚‚ : R},\n  aâ‚ + bâ‚ = câ‚ â†’ aâ‚‚ + bâ‚‚ = câ‚‚ â†’ aâ‚ + aâ‚‚ + (bâ‚ + bâ‚‚) = câ‚ + câ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "id",
   "iff_true",
   "Eq.mpr",
   "eq_iff_iff._simp_1",
   "iff_false"],
  "name": "Lean.Grind.eq_false_of_imp_eq_true",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) = True â†’ b = False â†’ a = False",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "Eq.mp",
   "SphericallyCompleteSpace.sorth_symm",
   "Membership.mem",
   "SphericallyCompleteSpace.SOrth",
   "propext",
   "congrArg",
   "SphericallyCompleteSpace.sorth_orthcomp"],
  "name": "SphericallyCompleteSpace.morth_of_mem_orthComp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F]\n  {x : E}, x âˆˆ SphericallyCompleteSpace.OrthComp ğ•œ F â†’ SphericallyCompleteSpace.MOrth ğ•œ x F",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "LinearIsometry.toLinearMap",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "HSMul.hSMul",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) (M : Submodule ğ•œ Eâ‚€) (hc : f.range â‰¤ M) (x : ğ•œ) (x_1 : â†¥f.range), âŸ¨â†‘(x â€¢ x_1), â‹¯âŸ© = âŸ¨â†‘(x â€¢ x_1), â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_11",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {x : Mâ‚‚}, (x âˆˆ f.range) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace",
  "constType": "(Î± : Type u_1) â†’ [PseudoMetricSpace Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references": ["SetLike.coe", "Norm.norm", "Metric.infDist", "Subspace"],
  "name": "SphericallyCompleteSpace.MOrth",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’ [inst_2 : NormedSpace ğ•œ E] â†’ [IsUltrametricDist E] â†’ E â†’ Subspace ğ•œ E â†’ Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And.left",
  "constType": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "LE.le",
   "Submodule.span_singleton_le_iff_mem",
   "Submodule.span",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_7",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (m : M)\n  (p : Submodule R M), (R âˆ™ m â‰¤ p) = (m âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul.match_1", "Nat.add", "Nat.below", "Nat.brecOn", "OfNat.ofNat"],
  "name": "Nat.mul",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["Left.add_nonneg"],
  "name": "add_nonneg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : Preorder Î±] [AddLeftMono Î±] {a b : Î±}, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 â‰¤ a + b",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate._simp_1_2",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_5",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "Subtype.mk.injEq",
   "Submodule.ext",
   "Eq.trans",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_5",
   "SphericallyCompleteSpace.câ‚€",
   "heq_of_eq",
   "Membership.mem.out",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "funext",
   "eq_of_heq",
   "Eq.symm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "AddHom.toFun",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "Eq.ndrec",
   "SphericallyCompleteSpace.MOrth",
   "HEq.casesOn",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_3",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_7",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "Exists.casesOn",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "Iff.of_eq",
   "LinearIsometry.toLinearMap",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_12",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Top.top",
   "Eq.mpr",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_20",
   "DFunLike.coe",
   "Subspace",
   "congrArg",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
   "congr",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "propext",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Exists.choose",
   "Eq.casesOn",
   "exists_prop_congr",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_8",
   "ENNReal",
   "of_eq_true",
   "LE.le",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_19",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_3",
   "QuotientAddGroup.mk",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_1",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace.IsImmediate (SphericallyCompleteSpace.SphericalCompletionEmbedding ğ•œ E)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "ENNReal.trichotomy",
   "Eq.trans",
   "NNReal.coe_nonneg",
   "Singleton.singleton",
   "Membership.mem",
   "Memâ„“p.summable",
   "Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg",
   "HMul.hMul",
   "Real.rpow_le_rpow",
   "Union.union",
   "NNNorm.nnnorm",
   "NNReal.coe_le_coe",
   "Fin.instUnique._proof_1",
   "HSub.hSub",
   "ENNReal.toReal",
   "Eq.symm",
   "Finset.sum",
   "Classical.not_not._simp_3",
   "Eq.ndrec",
   "rfl",
   "Norm.norm",
   "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
   "NNReal",
   "add_zero",
   "norm_add_le",
   "BddAbove",
   "_private.Mathlib.Analysis.Normed.Lp.lpSpace.0.Memâ„“p.add._simp_1_1",
   "Exists.casesOn",
   "if_neg",
   "Summable.of_nonneg_of_le",
   "upperBounds",
   "Iff.mpr",
   "Matrix.vecEmpty",
   "id",
   "Top.top",
   "Eq.mpr",
   "Fin.sum_univ_succ",
   "memâ„“p_infty",
   "one_mul",
   "Memâ„“p.finite_dsupport",
   "Fin.succ",
   "setOf",
   "Nat.cast",
   "Matrix.vecCons",
   "Summable.add",
   "Eq.mp",
   "SummationFilter.unconditional",
   "le_trans",
   "NNReal.toReal",
   "memâ„“p_zero",
   "Set.range",
   "LE.le.trans",
   "congrArg",
   "Finset.sum_congr",
   "Fintype.card",
   "Memâ„“p.bddAbove",
   "Fintype.card_fin",
   "add_le_add",
   "Memâ„“p",
   "Finset.univ_unique",
   "Set.Finite.union",
   "congr",
   "memâ„“p_gen",
   "ge_iff_le._simp_1",
   "LT.lt.le",
   "Not",
   "Finset.univ",
   "Set.Finite.subset",
   "Set",
   "ite",
   "Finset.card",
   "Real.rpow_nonneg",
   "NNReal.rpow_add_le_add_rpow",
   "HPow.hPow",
   "Summable.mul_left",
   "not_or._simp_2",
   "OfNat.ofNat",
   "Or.casesOn",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "LE.le",
   "_private.Mathlib.Analysis.Normed.Lp.lpSpace.0.Memâ„“p.add._simp_1_2",
   "norm_nonneg",
   "Ne",
   "dite",
   "Finset.sum_singleton",
   "if_pos",
   "And.casesOn"],
  "name": "Memâ„“p.add",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {f g : (i : Î±) â†’ E i},\n  Memâ„“p f p â†’ Memâ„“p g p â†’ Memâ„“p (f + g) p",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le", "PosMulMono.mul_le_mul_of_nonneg_left", "OfNat.ofNat"],
  "name": "mul_le_mul_of_nonneg_left",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Mul Î±] [inst_1 : Zero Î±] [inst_2 : Preorder Î±] {a b c : Î±} [PosMulMono Î±],\n  b â‰¤ c â†’ 0 â‰¤ a â†’ a * b â‰¤ a * c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "âˆ€ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "AddSubgroup.mem_mk",
   "Neg.neg",
   "Set",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddGroup G] {s : AddSubmonoid G} {x : G} (h_neg : âˆ€ {x : G}, x âˆˆ s.carrier â†’ -x âˆˆ s.carrier),\n  (x âˆˆ { toAddSubmonoid := s, neg_mem' := h_neg }) = (x âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": ["Iff.mpr", "trivial", "propext"],
  "name": "iff_true",
  "constType": "âˆ€ (p : Prop), (p â†” True) = p",
  "constCategory": "Theorem"},
 {"references": ["rfl", "HasSubset.Subset", "Set"],
  "name": "Set.subset_def",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, (s âŠ† t) = âˆ€ x âˆˆ s, x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Int.rawCast",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "le_of_not_gt",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.sub_pf",
   "Metric.nonempty_closedBall",
   "Neg.neg",
   "NNReal",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.mpr",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "id",
   "Int.negOfNat",
   "Metric.isClosed_closedBall",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Tactic.Ring.add_mul",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.sub_congr",
   "ProperSpace.isCompact_closedBall",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Set.Nonempty",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed",
   "neg_neg_of_pos"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpaceOfProperSpace",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [ProperSpace Î±], SphericallyCompleteSpace Î±",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists.casesOn",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {motive : Exists p â†’ Prop} (t : Exists p), (âˆ€ (w : Î±) (h : p w), motive â‹¯) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Subtype.prop",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "id",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_3",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (x_1 y : â†¥(ğ•œ âˆ™ x) Ã— â†¥F), â†‘(x_1 + y).1 + â†‘(x_1 + y).2 âˆˆ ğ•œ âˆ™ x + F",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.Orth"],
  "name": "SphericallyCompleteSpace.Orth.congr_simp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  x = x_1 â†’ âˆ€ (y y_1 : E), y = y_1 â†’ (x âŸ‚[ğ•œ] y) = (x_1 âŸ‚[ğ•œ] y_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "not_le",
   "norm_le_zero_iff",
   "Norm.norm",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Ne",
   "propext"],
  "name": "norm_pos_iff",
  "constType":
  "âˆ€ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, 0 < â€–aâ€– â†” a â‰  0",
  "constCategory": "Theorem"},
 {"references":
  ["IsometryEquiv.symm._proof_1", "IsometryEquiv.toEquiv", "Equiv.symm"],
  "name": "IsometryEquiv.symm",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [inst : PseudoEMetricSpace Î±] â†’ [inst_1 : PseudoEMetricSpace Î²] â†’ Î± â‰ƒáµ¢ Î² â†’ Î² â‰ƒáµ¢ Î±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "AddMemClass.add_mem",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Add M} {inst_1 : SetLike S M} [self : AddMemClass S M] {s : S}\n  {a b : M}, a âˆˆ s â†’ b âˆˆ s â†’ a + b âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_3",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Left.one_le_inv_iff._simp_2",
   "Neg.neg",
   "Eq.mp",
   "HMul.hMul",
   "mul_nonneg_of_nonpos_of_nonpos",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "le_of_lt",
   "neg_mul",
   "LE.le",
   "neg_neg_of_pos",
   "ge_iff_le._simp_1"],
  "name": "Mathlib.Tactic.Linarith.mul_nonpos",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Ring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] {a b : Î±}, a â‰¤ 0 â†’ 0 < b â†’ b * a â‰¤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.ediam",
   "Metric.ediam_le_of_forall_dist_le",
   "Set",
   "Dist.dist",
   "Membership.mem",
   "LE.le",
   "ENNReal.toReal_le_of_le_ofReal",
   "OfNat.ofNat"],
  "name": "Metric.diam_le_of_forall_dist_le",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} [inst : PseudoMetricSpace Î±] {C : â„},\n  0 â‰¤ C â†’ (âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, dist x y â‰¤ C) â†’ Metric.diam s â‰¤ C",
  "constCategory": "Theorem"},
 {"references": ["NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} â†’ [NatCast R] â†’ â„• â†’ R",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_7",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.casesOn",
   "HAdd.hAdd",
   "LT.lt",
   "AddLeftReflectLT",
   "LE.le",
   "Eq.symm",
   "Eq.ndrec",
   "pos_of_lt_add_right",
   "le_of_forall_gt_imp_ge_of_dense",
   "OfNat.ofNat",
   "LT.lt.le",
   "ExistsAddOfLE.exists_add_of_le"],
  "name": "le_of_forall_pos_le_add",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] [DenselyOrdered Î±] [inst_2 : AddMonoid Î±] [ExistsAddOfLE Î±] [AddLeftReflectLT Î±]\n  {a b : Î±}, (âˆ€ (Îµ : Î±), 0 < Îµ â†’ a â‰¤ b + Îµ) â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_6",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Int.sub_self", "id", "HSub.hSub", "Eq.mpr", "OfNat.ofNat", "congrArg"],
  "name": "Int.sub_eq_zero_of_eq",
  "constType": "âˆ€ {a b : â„¤}, a = b â†’ a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "LE.le",
   "HMul.hMul",
   "Real.sInf_nonneg",
   "DFunLike.coe",
   "OfNat.ofNat",
   "And.left",
   "setOf"],
  "name": "ContinuousLinearMap.opNorm_nonneg",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F), 0 â‰¤ â€–fâ€–",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Elem"],
  "name": "Set.Countable",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ne.lt_top'",
   "Eq.trans",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.isboundedlinearmap_of_glued_map._simp_2",
   "Singleton.singleton",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
   "Membership.mem",
   "HMul.hMul",
   "eq_true",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.T",
   "Submodule.span",
   "GT.gt",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_2",
   "congrFun",
   "RingHom.id",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "rfl",
   "zorn_le_nonempty",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_1",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hDM",
   "Norm.norm",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "LinearEquiv.ofTop",
   "And.right",
   "Exists.casesOn",
   "implies_true",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hT",
   "SetLike.coe",
   "HSMul.hSMul",
   "Classical.byContradiction",
   "id",
   "Top.top",
   "Eq.mpr",
   "one_mul",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_4",
   "IsChain",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_1",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "DFunLike.coe",
   "Submodule.mem_top",
   "congrArg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_2",
   "ContinuousLinearMap.isBoundedLinearMap",
   "Subtype.prop",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_1",
   "Submodule.mem_sup",
   "congr",
   "IsMax",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1",
   "propext",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_3",
   "Not",
   "Set.exists_of_ssubset",
   "Set.Nonempty",
   "Set",
   "Submodule.add_eq_sup",
   "Function.comp",
   "LinearEquiv.symm",
   "OfNat.ofNat",
   "IsBoundedLinearMap.comp",
   "not_le_of_gt",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension",
   "Max.max",
   "and_self",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
   "of_eq_true",
   "le_of_lt",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hU",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_iff",
   "Ne",
   "trivial",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] (D : Submodule ğ•œ E) {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F]\n  [SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) {ğ’° : Set (E â†’L[ğ•œ] F)},\n  ğ’°.Nonempty â†’\n    âˆ€ (Îµ : â†‘ğ’° â†’ â„),\n      (âˆ€ (T : â†‘ğ’°), 0 < Îµ T) â†’\n        (âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V)) â†’\n          (âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–) â†’ âˆƒ T, (âˆ€ (x : â†¥D), T â†‘x = S x) âˆ§ âˆ€ (U : â†‘ğ’°), â€–T - â†‘Uâ€– â‰¤ Îµ U",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "Nat.cast",
   "Nat.cast_zero",
   "LE.le",
   "Nat.zero_le",
   "Nat.mono_cast",
   "OfNat.ofNat"],
  "name": "Nat.cast_nonneg'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] (n : â„•),\n  0 â‰¤ â†‘n",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_10",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, (x â‰¥ y) = (y â‰¤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "eq_self", "Eq.trans", "of_eq_true", "add_assoc", "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {aâ‚‚ b c : R} (aâ‚ : R), aâ‚‚ + b = c â†’ aâ‚ + aâ‚‚ + b = aâ‚ + c",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.SOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.SOrth.eq_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (F1 F2 : Subspace ğ•œ E),\n  SphericallyCompleteSpace.SOrth ğ•œ F1 F2 = âˆ€ x âˆˆ F1, SphericallyCompleteSpace.MOrth ğ•œ x F2",
  "constCategory": "Theorem"},
 {"references":
  ["Isometry.preimage_closedBall",
   "Metric.closedBall",
   "Set.preimage",
   "Set",
   "IsometryEquiv.symm",
   "IsometryEquiv.apply_symm_apply",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "IsometryEquiv.isometry",
   "DFunLike.coe",
   "congrArg"],
  "name": "IsometryEquiv.preimage_closedBall",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] (h : Î± â‰ƒáµ¢ Î²) (x : Î²) (r : â„),\n  â‡‘h â»Â¹' Metric.closedBall x r = Metric.closedBall (h.symm x) r",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "sub_eq_zero",
   "Eq.mp",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Classical.propDecidable",
   "Submodule.span",
   "congrArg",
   "False.elim",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "HSub.hSub",
   "add_comm",
   "propext",
   "rfl",
   "Not",
   "Inv.inv",
   "sub_eq_sub_iff_add_eq_add",
   "Set",
   "Submodule.smul_mem",
   "Submodule.sub_mem_iff_left",
   "OfNat.ofNat",
   "eq_inv_smul_iffâ‚€",
   "HAdd.hAdd",
   "Exists.casesOn",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "zero_smul",
   "Eq.mpr",
   "dite"],
  "name": "eq_and_eq_of_add_eq_add_of_not_mem_submodule_span_singleton",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : Field ğ•œ] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : _root_.Module ğ•œ V]\n  {D : Submodule ğ•œ V} {a : V},\n  a âˆ‰ D â†’ âˆ€ d1 âˆˆ D, âˆ€ la1 âˆˆ ğ•œ âˆ™ a, âˆ€ d2 âˆˆ D, âˆ€ la2 âˆˆ ğ•œ âˆ™ a, d1 + la1 = d2 + la2 â†’ d1 = d2 âˆ§ la1 = la2",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "IsMax",
  "constType": "{Î± : Type u_1} â†’ [LE Î±] â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "mul_inv_rev",
   "Inv.inv",
   "Nat.cast",
   "Nat.cast_ne_zero",
   "Eq.trans",
   "Invertible.invOf",
   "invOf_eq_inv",
   "Mathlib.Meta.NormNum.IsNNRat.casesOn",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "Nat.cast_add",
   "HAdd.hAdd",
   "eq_self",
   "inv_inv",
   "invertibleOfNonzero",
   "of_eq_true",
   "congr",
   "Iff.mpr",
   "Nat.succ_ne_zero",
   "Eq.symm",
   "Ne",
   "Eq.ndrec"],
  "name": "Mathlib.Meta.NormNum.isNNRat_inv_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : DivisionSemiring Î±] [CharZero Î±] {a : Î±} {n d : â„•},\n  Mathlib.Meta.NormNum.IsNNRat a n.succ d â†’ Mathlib.Meta.NormNum.IsNNRat aâ»Â¹ d n.succ",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLeftReflectLE",
  "constType": "(M : Type u_1) â†’ [Add M] â†’ [LE M] â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set.univ", "Set", "Membership.mem", "eq_true", "Set.mem_univ"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_1",
  "constType": "âˆ€ {Î± : Type u} (x : Î±), (x âˆˆ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Not",
  "constType": "Prop â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "norm_nonneg'._simp_2",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 â‰¤ â€–aâ€–) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Nat.rawCast",
   "add_zero",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.cast_pos.match_1_1",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : â„•}, Mathlib.Meta.NormNum.IsNat a n â†’ a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "SProd.sprod", "Iff.rfl"],
  "name": "Set.mem_prod",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {s : Set Î±} {t : Set Î²} {p : Î± Ã— Î²}, p âˆˆ s Ã—Ë¢ t â†” p.1 âˆˆ s âˆ§ p.2 âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Submodule.neg_mem",
   "Neg.neg",
   "Membership.mem",
   "Submodule.add_mem_iff_left",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "congrArg"],
  "name": "Submodule.sub_mem_iff_left",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x y : M}, y âˆˆ p â†’ (x - y âˆˆ p â†” x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "sub_neg_eq_add",
   "neg_sub",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "sub_add_sub_cancel",
   "congrArg"],
  "name": "sub_sub_sub_cancel_right",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - c - (b - c) = a - b",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "forall_const._simp_1",
  "constType":
  "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆ€ (a : Î±), b) = b",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt_of_ge", "le_of_not_gt", "LE.le"],
  "name": "not_lt",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, Â¬a < b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["sub_nonpos_of_le", "LE.le"],
  "name": "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Ring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] {a b : Î±}, a â‰¤ b â†’ a - b â‰¤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.OrthComp",
   "Eq.trans",
   "LinearIsometry.isometry",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€",
   "Submodule.ne_bot_iff",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.isCompl_orthcomp",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "False.elim",
   "LinearIsometryEquiv.symm",
   "RingHom.id",
   "funext",
   "SphericallyCompleteSpace.morth_of_mem_orthComp",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_4",
   "And.right",
   "Bot.bot",
   "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_1",
   "Exists.casesOn",
   "SphericallyCompleteSpace.SphericalCompletion",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "sup_of_le_left",
   "LinearIsometry.toLinearMap",
   "Iff.of_eq",
   "Iff.mpr",
   "LinearIsometryEquiv.ofSurjective",
   "Classical.byContradiction",
   "Top.top",
   "id",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "IsCompl.sup_eq_top",
   "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_2",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "SphericallyCompleteSpace.MaximallyComplete",
   "HasQuotient.Quotient",
   "lp",
   "Eq.mp",
   "LinearMap.range",
   "DFunLike.coe",
   "congrArg",
   "propext",
   "Not",
   "PreLp",
   "Classical.not_imp._simp_2",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Isometry.isometryEquivOnRange",
   "LinearIsometryEquiv.toIsometryEquiv",
   "Exists.choose",
   "Function.Surjective",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "ENNReal",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "Ne",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding",
   "And.casesOn",
   "Mathlib.Tactic.Push.not_forall_eq"],
  "name": "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace E â†” SphericallyCompleteSpace.MaximallyComplete ğ•œ E",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Omega.LinearCombo.coeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.const",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.eval",
  "constType": "Omega.LinearCombo â†’ Omega.Coeffs â†’ â„¤",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "False.elim", "lt_irrefl"],
  "name": "lt_self_iff_false",
  "constType": "âˆ€ {Î± : Type u_2} [inst : Preorder Î±] (x : Î±), x < x â†” False",
  "constCategory": "Theorem"},
 {"references": ["Not", "by_contra"],
  "name": "Mathlib.Tactic.Contrapose.contraposeâ‚",
  "constType": "âˆ€ {p q : Prop}, (Â¬q â†’ Â¬p) â†’ p â†’ q",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Exists.choose_spec",
   "Set",
   "And.right",
   "NNReal",
   "Membership.mem",
   "NNReal.toReal",
   "zero_lt_one",
   "Prod.snd",
   "Membership.mem.out",
   "GT.gt",
   "Exists.choose",
   "OfNat.ofNat",
   "Nonempty.some",
   "one_lt_two",
   "Prod.fst",
   "LT.lt",
   "Metric.closedBall",
   "Set.Ioc",
   "LE.le",
   "NNDist.nndist",
   "And.left",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] [nemp : Nonempty Î±],\n  âˆƒ z, nndist z.1 z.2 > 0",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_15",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references":
  ["iSup.eq_1",
   "iSup",
   "Set",
   "SupSet.sSup",
   "Singleton.singleton",
   "id",
   "Set.range_const",
   "csSup_singleton",
   "Eq.mpr",
   "Set.range",
   "congrArg"],
  "name": "ciSup_const",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : ConditionallyCompleteLattice Î±] [hÎ¹ : Nonempty Î¹] {a : Î±}, â¨† x, a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Function.leftInverse_invFun",
   "Function.invFun.congr_simp",
   "Eq.substr",
   "Eq.trans",
   "Set.rangeFactorization_injective",
   "LinearMap.range",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_3",
   "Membership.mem",
   "LinearIsometry.norm_map",
   "Subtype.mk.congr_simp",
   "map_smul",
   "DFunLike.coe",
   "Subtype.val",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "RingHom.id",
   "congr",
   "forall_congr",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "forall_prop_domain_congr",
   "Subtype.val_injective",
   "Norm.norm",
   "Set",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "Set.rangeFactorization_surjective",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_2",
   "Eq.casesOn",
   "HAdd.hAdd",
   "map_add",
   "eq_self",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_1",
   "Function.RightInverse",
   "of_eq_true",
   "LinearIsometry.toLinearMap",
   "Function.rightInverse_invFun",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_4",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’â‚—áµ¢[ğ•œ] F)\n  (x : â†¥f.range), â€–{ toFun := Function.invFun (Set.rangeFactorization â‡‘f), map_add' := â‹¯, map_smul' := â‹¯ } xâ€– = â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["iff_self",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "_private.Init.PropLemmas.0.forall_apply_eq_imp_iff._simp_1_1",
   "forall_eq'._simp_1",
   "congrArg"],
  "name": "forall_apply_eq_imp_iff",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆ€ (b : Î²) (a : Î±), f a = b â†’ p b) â†” âˆ€ (a : Î±), p (f a)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "exists_eq",
  "constType": "âˆ€ {Î± : Sort u_1} {a' : Î±}, âˆƒ a, a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["List.getLastD",
   "implies_congr",
   "List.getLastD_mem_cons",
   "_private.Mathlib.Data.List.TFAE.0.List.tfae_of_cycle._simp_1_1",
   "Eq.trans",
   "Eq.mp",
   "_private.Mathlib.Data.List.TFAE.0.List.tfae_of_cycle._simp_1_2",
   "Iff.mp",
   "eq_true",
   "List.tfae_singleton._simp_1",
   "and_true",
   "List.getLast?",
   "congrArg",
   "congr",
   "forall_congr",
   "List.TFAE",
   "List.IsChain.singleton._simp_1",
   "List.getLastD_cons",
   "List.getLastD_eq_getLast?",
   "_private.Mathlib.Data.List.TFAE.0.List.tfae_of_cycle._simp_1_3",
   "And.right",
   "Option.getD",
   "Function.comp",
   "implies_true",
   "and_self",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "List.isChain_cons_cons._simp_1",
   "And.casesOn"],
  "name": "List.tfae_of_cycle",
  "constType":
  "âˆ€ {a b : Prop} {l : List Prop},\n  List.IsChain (fun x1 x2 â†¦ x1 â†’ x2) (a :: b :: l) â†’ (l.getLastD b â†’ a) â†’ (a :: b :: l).TFAE",
  "constCategory": "Theorem"},
 {"references": ["Set", "iInf"],
  "name": "Set.iInter",
  "constType": "{Î± : Type u} â†’ {Î¹ : Sort v} â†’ (Î¹ â†’ Set Î±) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mp",
   "LE.le",
   "mul_le_mul_of_nonneg_left",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Left.mul_nonneg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : MulZeroClass Î±] {a b : Î±} [inst_1 : Preorder Î±] [PosMulMono Î±], 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 â‰¤ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_4",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, (dist x y â‰¤ â†‘c) = (nndist x y â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Elem",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Type u",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "Membership.mem",
   "AddMemClass.add_mem",
   "Submodule.mem_sup_right",
   "Submodule.mem_sup_left"],
  "name": "Submodule.add_mem_sup",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S T : Submodule R M} {s t : M}, s âˆˆ S â†’ t âˆˆ T â†’ s + t âˆˆ S âŠ” T",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "NNReal", "NNReal.toReal", "Iff.rfl"],
  "name": "NNReal.coe_le_coe",
  "constType": "âˆ€ {râ‚ râ‚‚ : NNReal}, â†‘râ‚ â‰¤ â†‘râ‚‚ â†” râ‚ â‰¤ râ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.OrthComp",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.isCompl_orthcomp",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "funext",
   "SphericallyCompleteSpace.morth_of_mem_orthComp",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.MOrth",
   "SphericallyCompleteSpace.sphericalCompletion_minimal._simp_1_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "Submodule.eq_bot_iff",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "SphericallyCompleteSpace.Orth",
   "Bot.bot",
   "Exists.casesOn",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "sup_of_le_left",
   "LinearIsometry.toLinearMap",
   "Iff.not",
   "Classical.byContradiction",
   "Top.top",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "IsCompl.sup_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "Eq.mp",
   "LinearMap.range",
   "Subspace",
   "congrArg",
   "propext",
   "SphericallyCompleteSpace.morth_iff_forall_orth",
   "Not",
   "PreLp",
   "Classical.not_imp._simp_2",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "ENNReal",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "Ne",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding",
   "Mathlib.Tactic.Push.not_forall_eq",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_minimal",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E]\n  (M : Submodule ğ•œ (SphericallyCompleteSpace.SphericalCompletion ğ•œ E)),\n  (SphericallyCompleteSpace.SphericalCompletionEmbedding ğ•œ E).range â‰¤ M â†’ SphericallyCompleteSpace â†¥M â†’ M = âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_5",
   "SphericallyCompleteSpace.câ‚€",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_7",
   "Submodule.toAddSubgroup",
   "DFunLike.coe",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_8",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_2",
   "RingHom.id",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_3",
   "Top.top",
   "QuotientAddGroup.mk'"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u_2) â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’ E â†’â‚—áµ¢[ğ•œ] â†¥(lp (fun x â†¦ E) âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False.elim",
  "constType": "{C : Sort u} â†’ False â†’ C",
  "constCategory": "Definition"},
 {"references":
  ["LinearIsometryEquiv.symm._proof_1",
   "LinearIsometryEquiv.toLinearEquiv",
   "LinearEquiv.symm"],
  "name": "LinearIsometryEquiv.symm",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n                [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n                  [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                    [inst_4 : SeminormedAddCommGroup E] â†’\n                      [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                        [inst_6 : _root_.Module R E] â†’\n                          [inst_7 : _root_.Module Râ‚‚ Eâ‚‚] â†’ (E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ Eâ‚‚ â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚â‚] E",
  "constCategory": "Definition"},
 {"references": ["Nat.ofNat_pos", "LT.lt", "eq_true", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_17",
  "constType":
  "âˆ€ {Î± : Type u_3} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] [Nontrivial Î±] {n : â„•}\n  [inst_4 : n.AtLeastTwo], (0 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Singleton.singleton",
   "Submodule.smul_mem",
   "Membership.mem",
   "HMul.hMul",
   "Submodule.span",
   "Submodule.span_induction",
   "Eq.casesOn",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Exists.casesOn",
   "eq_self",
   "of_eq_true",
   "smul_smul",
   "HSMul.hSMul",
   "one_smul",
   "Eq.symm",
   "zero_smul",
   "Set.mem_singleton_iff._simp_1",
   "Eq.ndrec",
   "Submodule.subset_span",
   "add_smul"],
  "name": "Submodule.mem_span_singleton",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x y : M},\n  x âˆˆ R âˆ™ y â†” âˆƒ a, a â€¢ y = x",
  "constCategory": "Theorem"},
 {"references": ["IsometryEquiv.toEquiv", "Equiv.apply_symm_apply"],
  "name": "IsometryEquiv.apply_symm_apply",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] (h : Î± â‰ƒáµ¢ Î²) (y : Î²),\n  h (h.symm y) = y",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.add_overlap_pf_zero._simp_1_3",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "Nat.cast_zero",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1_1"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : â„•),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 â†’ Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Set.range_eq_singleton"],
  "name": "Set.range_const",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [Nonempty Î¹] {c : Î±}, (Set.range fun x â†¦ c) = {c}",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Subspace",
   "congrArg",
   "Exists.casesOn",
   "HSMul.hSMul",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "id",
   "SphericallyCompleteSpace.smul_morth_of_morth",
   "Eq.mpr",
   "SphericallyCompleteSpace.MOrth"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.smul_morth_of_morth'",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ğ•œ E),\n  SphericallyCompleteSpace.MOrth ğ•œ x F â†’ âˆ€ a âˆˆ ğ•œ âˆ™ x, SphericallyCompleteSpace.MOrth ğ•œ a F",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Set.mem_pi._simp_1",
   "dist_pi_le_iff",
   "Eq.trans",
   "Set",
   "Set.pi",
   "Membership.mem",
   "Set.mem_univ._simp_1",
   "Metric.mem_closedBall._simp_1",
   "OfNat.ofNat",
   "congrArg",
   "Set.univ",
   "Metric.closedBall",
   "forall_const._simp_1",
   "iff_self",
   "of_eq_true",
   "congr",
   "forall_congr",
   "LE.le",
   "Dist.dist",
   "Set.ext",
   "propext"],
  "name": "closedBall_pi",
  "constType":
  "âˆ€ {Î² : Type u_2} {X : Î² â†’ Type u_3} [inst : Fintype Î²] [inst_1 : (b : Î²) â†’ PseudoMetricSpace (X b)] (x : (b : Î²) â†’ X b)\n  {r : â„}, 0 â‰¤ r â†’ Metric.closedBall x r = Set.univ.pi fun b â†¦ Metric.closedBall (x b) r",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq.casesOn",
  "constType":
  "{Î± : Sort u} â†’\n  {a : Î±} â†’\n    {motive : {Î² : Sort u} â†’ (a_1 : Î²) â†’ a â‰ a_1 â†’ Sort u_1} â†’\n      {Î² : Sort u} â†’ {a_1 : Î²} â†’ (t : a â‰ a_1) â†’ motive a â‹¯ â†’ motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "add_assoc",
   "congr",
   "HSub.hSub",
   "neg_neg",
   "neg_add_rev",
   "congrArg"],
  "name": "sub_sub_eq_add_sub",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SubtractionMonoid Î±] (a b c : Î±), a - (b - c) = a + c - b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "congrArg",
   "Submodule.add_mem_sup",
   "Prod.fst",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "Subtype.prop",
   "of_eq_true",
   "SMulMemClass.smul_mem",
   "HSMul.hSMul",
   "id",
   "smul_add",
   "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_7",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (m : ğ•œ) (a : â†¥(ğ•œ âˆ™ x) Ã— â†¥F),\n  âŸ¨m â€¢ â†‘a.1 + m â€¢ â†‘a.2, â‹¯âŸ© = âŸ¨m â€¢ (â†‘a.1 + â†‘a.2), â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "add_neg_cancel",
   "OfNat.ofNat",
   "congrArg"],
  "name": "sub_self",
  "constType": "âˆ€ {G : Type u_1} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Norm.norm",
  "constType": "{E : Type u_8} â†’ [self : Norm E] â†’ E â†’ â„",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "OfNat.ofNat"],
  "name": "Nat.recAux",
  "constType":
  "{motive : â„• â†’ Sort u} â†’ motive 0 â†’ ((n : â„•) â†’ motive n â†’ motive (n + 1)) â†’ (t : â„•) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.symm"],
  "name": "forall_eq",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) â†” p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "sup_le_iff", "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_7",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, (a âŠ” b â‰¤ c) = (a â‰¤ c âˆ§ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Trans.trans",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "add_left_cancel_iff",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "add_eq_left",
  "constType":
  "âˆ€ {M : Type u_4} [inst : AddMonoid M] [IsLeftCancelAdd M] {a b : M}, a + b = a â†” b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hT",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F]\n  [inst_7 : SphericallyCompleteSpace F] {S : â†¥D â†’L[ğ•œ] F} {ğ’° : Set (E â†’L[ğ•œ] F)} {hğ’° : ğ’°.Nonempty} {Îµ : â†‘ğ’° â†’ â„}\n  (self : SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ) (x : â†¥D),\n  (SphericallyCompleteSpace.PartialExtension.Tâœ self) âŸ¨â†‘x, â‹¯âŸ© = S x",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "PreLp",
   "HasQuotient.Quotient",
   "lp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.SphericalCompletion",
   "ENNReal",
   "RingHom.id",
   "Top.top",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_universal_property",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [IsUltrametricDist F] [SphericallyCompleteSpace F] (f : E â†’â‚—áµ¢[ğ•œ] F),\n  âˆƒ T, T.comp (SphericallyCompleteSpace.SphericalCompletionEmbedding ğ•œ E) = f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_1",
  "constType":
  "âˆ€ {F : Type u_1} [inst : SeminormedAddCommGroup F] [iud : IsUltrametricDist F], IsTopologicalAddGroup F",
  "constCategory": "Theorem"},
 {"references": ["Set", "LE.le", "Membership.mem", "setOf"],
  "name": "lowerBounds",
  "constType": "{Î± : Type u_1} â†’ [LE Î±] â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["Set", "funext", "Membership.mem", "propext"],
  "name": "Set.ext",
  "constType":
  "âˆ€ {Î± : Type u} {a b : Set Î±}, (âˆ€ (x : Î±), x âˆˆ a â†” x âˆˆ b) â†’ a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "setOf",
  "constType": "{Î± : Type u} â†’ (Î± â†’ Prop) â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SphericallyCompleteSpace.Orth",
   "SphericallyCompleteSpace.MOrth",
   "propext",
   "Subspace",
   "SphericallyCompleteSpace.morth_iff_forall_orth"],
  "name": "SphericallyCompleteSpace.sorth_iff_forall_orth._simp_1_2",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ğ•œ E),\n  SphericallyCompleteSpace.MOrth ğ•œ x F = âˆ€ y âˆˆ F, x âŸ‚[ğ•œ] y",
  "constCategory": "Theorem"},
 {"references": ["le_rfl", "LE.le", "sup_le_sup"],
  "name": "sup_le_sup_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ b â†’ âˆ€ (c : Î±), a âŠ” c â‰¤ b âŠ” c",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono", "Nat.strictMono_cast", "Nat.cast", "StrictMono.lt_iff_lt"],
  "name": "Nat.cast_lt",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] [CharZero Î±]\n  {m n : â„•}, â†‘m < â†‘n â†” m < n",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Ne"],
  "name": "Ne.symm",
  "constType": "âˆ€ {Î± : Sort u} {a b : Î±}, a â‰  b â†’ b â‰  a",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd"],
  "name": "Int.natCast_nonneg",
  "constType": "âˆ€ (n : â„•), 0 â‰¤ â†‘n",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "HMul.hMul",
   "Filter.Eventually.of_forall",
   "Set.mem_smul_set_iff_inv_smul_memâ‚€",
   "IsCompact.smul",
   "False.elim",
   "iff_self",
   "eq_of_heq",
   "Eq.symm",
   "Filter.Tendsto.atTop_mul_const",
   "Eq.ndrec",
   "norm_zero",
   "Filter.Tendsto",
   "Metric.exists_isCompact_closedBall",
   "ProperSpace.of_seq_closedBall",
   "pow_ne_zero",
   "Norm.norm",
   "Exists.casesOn",
   "Filter.atTop",
   "IsCompact",
   "norm_pos_iff",
   "eq_false",
   "Iff.mpr",
   "HSMul.hSMul",
   "Set.ext",
   "Eq.mpr",
   "inv_mul_le_iffâ‚€",
   "Eq.mp",
   "congrArg",
   "norm_mul",
   "LE.le.not_gt",
   "congr",
   "norm_pow",
   "Dist.dist",
   "Set.smulSet",
   "propext",
   "Inv.inv",
   "Set",
   "zero_le_one",
   "NormedField.exists_one_lt_norm",
   "HPow.hPow",
   "dist_zero_right",
   "Eq.casesOn",
   "OfNat.ofNat",
   "LT.lt",
   "Metric.closedBall",
   "of_eq_true",
   "tendsto_pow_atTop_atTop_of_one_lt",
   "LE.le",
   "_private.Mathlib.Analysis.Normed.Field.ProperSpace.0.ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace._simp_1_1",
   "Ne",
   "norm_inv",
   "And.casesOn"],
  "name": "ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] [WeaklyLocallyCompactSpace ğ•œ], ProperSpace ğ•œ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "Lean.Syntax.node1",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "SphericallyCompleteSpace.Â«_aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___macroRules_SphericallyCompleteSpace_term_âŸ‚â‚›__1Â»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["NNReal", "NNReal.coe_eq_zero", "NNReal.toReal", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_25",
  "constType": "âˆ€ {r : NNReal}, (â†‘r = 0) = (r = 0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{Î± : Type u} â†’ [self : EmptyCollection Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "AddSubmonoid.mem_mk",
   "propext",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
  "constType":
  "âˆ€ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubsemigroup M} {x : M} (h_zero : 0 âˆˆ s.carrier),\n  (x âˆˆ { toAddSubsemigroup := s, zero_mem' := h_zero }) = (x âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subspace",
  "constType":
  "(R : Type u) â†’ (M : Type v) â†’ [inst : DivisionRing R] â†’ [inst_1 : AddCommGroup M] â†’ [_root_.Module R M] â†’ Type v",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Nat.cast",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "add_add_add_comm",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.IsNat.out",
   "id",
   "Eq.mpr",
   "Eq.ndrec",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {aâ‚ aâ‚‚ bâ‚ bâ‚‚ c : R},\n  Mathlib.Meta.NormNum.IsNat (aâ‚ + bâ‚) 0 â†’ aâ‚‚ + bâ‚‚ = c â†’ aâ‚ + aâ‚‚ + (bâ‚ + bâ‚‚) = c",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "eq_true", "SetLike.coe_mem", "Subtype.val"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_23",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : â†¥p), (â†‘x âˆˆ p) = True",
  "constCategory": "Theorem"},
 {"references": ["ne_of_gt"],
  "name": "LT.lt.ne'",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, b < a â†’ a â‰  b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "le_refl",
   "AddRightMono",
   "LE.le",
   "le_imp_le_of_le_of_le",
   "add_le_add_left",
   "add_le_add_right"],
  "name": "add_le_add",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Add Î±] [inst_1 : Preorder Î±] [AddLeftMono Î±] [AddRightMono Î±] {a b c d : Î±},\n  a â‰¤ b â†’ c â‰¤ d â†’ a + c â‰¤ b + d",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le", "OfNat.ofNat", "MulPosMono.mul_le_mul_of_nonneg_right"],
  "name": "mul_le_mul_of_nonneg_right",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Mul Î±] [inst_1 : Zero Î±] [inst_2 : Preorder Î±] {a b c : Î±} [MulPosMono Î±],\n  b â‰¤ c â†’ 0 â‰¤ a â†’ b * a â‰¤ c * a",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_5",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["HasDistribNeg.neg_mul"],
  "name": "neg_mul",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Mul Î±] [inst_1 : HasDistribNeg Î±] (a b : Î±), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_17",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsLinearMap.map_add",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} {Mâ‚‚ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid Mâ‚‚]\n  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R Mâ‚‚] {f : M â†’ Mâ‚‚},\n  IsLinearMap R f â†’ âˆ€ (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "mul_add",
   "HMul.hMul",
   "add_zero",
   "Eq.ndrec",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a bâ‚ bâ‚‚ câ‚ câ‚‚ d : R},\n  a * bâ‚ = câ‚ â†’ a * bâ‚‚ = câ‚‚ â†’ câ‚ + 0 + câ‚‚ = d â†’ a * (bâ‚ + bâ‚‚) = d",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_7",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references": ["Metric.closedBall", "NNReal", "NNReal.toReal", "Metric.diam"],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.casesOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    {motive : SphericallyCompleteSpace.IsSphericallyDense Î± â†’ Sort u} â†’\n      (t : SphericallyCompleteSpace.IsSphericallyDense Î±) â†’\n        ((spherically_dense : âˆ€ (c : Î±) (r : NNReal), Metric.diam (Metric.closedBall c â†‘r) = â†‘r) â†’ motive â‹¯) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "Membership.mem",
   "id",
   "HSub.hSub",
   "AddMemClass.add_mem",
   "Eq.mpr",
   "NegMemClass.neg_mem",
   "congrArg"],
  "name": "sub_mem",
  "constType":
  "âˆ€ {M : Type u_3} {S : Type u_4} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [hSM : AddSubgroupClass S M] {H : S}\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x - y âˆˆ H",
  "constCategory": "Theorem"},
 {"references": ["inferInstance"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpaceComplex",
  "constType": "SphericallyCompleteSpace â„‚",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_cancel",
   "HAdd.hAdd",
   "eq_neg_of_add_eq_zero_left",
   "Neg.neg",
   "HSMul.hSMul",
   "Eq.symm",
   "id",
   "zero_smul",
   "Eq.mpr",
   "add_smul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "neg_smul",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] (r : R) (x : M),\n  -r â€¢ x = -(r â€¢ x)",
  "constCategory": "Theorem"},
 {"references": ["exists_imp"],
  "name": "not_exists",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆƒ x, p x) â†” âˆ€ (x : Î±), Â¬p x",
  "constCategory": "Theorem"},
 {"references": ["PseudoMetricSpace.dist_comm"],
  "name": "dist_comm",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (x y : Î±), dist x y = dist y x",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "Eq.symm", "neg_neg"],
  "name": "neg_eq_iff_eq_neg",
  "constType":
  "âˆ€ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = b â†” a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.sorth_of_sorth",
   "SphericallyCompleteSpace.SOrth",
   "Subspace"],
  "name": "SphericallyCompleteSpace.sorth_symm",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F1 F2 : Subspace ğ•œ E},\n  SphericallyCompleteSpace.SOrth ğ•œ F1 F2 â†” SphericallyCompleteSpace.SOrth ğ•œ F2 F1",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_3",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach._simp_1_2",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["LinearEquiv.toEquiv",
   "LinearIsometryEquiv.toLinearEquiv",
   "LinearIsometryEquiv.isometry"],
  "name": "LinearIsometryEquiv.toIsometryEquiv",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n                [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n                  [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                    [inst_4 : SeminormedAddCommGroup E] â†’\n                      [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                        [inst_6 : _root_.Module R E] â†’ [inst_7 : _root_.Module Râ‚‚ Eâ‚‚] â†’ (E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â‰ƒáµ¢ Eâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_5",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "Classical.propDecidable",
   "LinearIsometry.norm_map",
   "HMul.hMul",
   "sub_zero",
   "Subtype.val",
   "False.elim",
   "RingHom.id",
   "HSub.hSub",
   "Eq.symm",
   "Classical.not_not._simp_3",
   "norm_eq_of_norm_sub_lt_left",
   "norm_zero",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "rfl",
   "LinearIsometry.toContinuousLinearMap",
   "Norm.norm",
   "And.right",
   "lt_of_le_of_lt",
   "LinearIsometry.norm_toContinuousLinearMap",
   "LinearIsometry.comp",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_4",
   "Bot.bot",
   "Exists.casesOn",
   "SphericallyCompleteSpace.IsImmediate",
   "SetLike.coe",
   "LinearIsometry.toLinearMap",
   "eq_false",
   "Iff.mpr",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv",
   "id",
   "Eq.mpr",
   "one_mul",
   "dist_eq_norm",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_3",
   "Submodule.nonempty",
   "Classical.not_not",
   "Eq.mp",
   "LinearMap.range",
   "lt_of_le_of_ne",
   "DFunLike.coe",
   "map_sub",
   "ContinuousLinearMap.comp",
   "Subspace",
   "congrArg",
   "norm_sub_rev",
   "ZeroMemClass.zero_mem",
   "congr",
   "Dist.dist",
   "Metric.infDist",
   "map_zero",
   "Metric.infDist_le_dist_of_mem",
   "propext",
   "le_refl._simp_1",
   "Not",
   "ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap.le_opNorm",
   "Set",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_1",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "zero_le_one",
   "dist_zero_right",
   "OfNat.ofNat",
   "LT.lt",
   "eq_self",
   "Metric.infDist_lt_iff",
   "of_eq_true",
   "LE.le",
   "and_false",
   "Ne",
   "ContinuousLinearMap.opNorm_le_iff",
   "eq_of_le_of_ge",
   "Submodule.nontrivial_iff_ne_bot",
   "dite"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [inst_6 : IsUltrametricDist F] {H : Type u_4} [inst_7 : NormedAddCommGroup H]\n  [inst_8 : NormedSpace ğ•œ H] [IsUltrametricDist H] [SphericallyCompleteSpace H] (f : E â†’â‚—áµ¢[ğ•œ] F),\n  SphericallyCompleteSpace.IsImmediate f â†’\n    âˆ€ (g : E â†’â‚—áµ¢[ğ•œ] H) (h : F â†’L[ğ•œ] H),\n      â€–hâ€– = â€–g.toContinuousLinearMap.comp (SphericallyCompleteSpace.LinearIsometry.weakInvâœ f).toContinuousLinearMapâ€– â†’\n        (âˆ€ (v : F) (x : E) (h_1 : f x = v), h v = g ((SphericallyCompleteSpace.LinearIsometry.weakInvâœÂ¹ f) âŸ¨v, â‹¯âŸ©)) â†’\n          âˆ€ (v : F), â€–â†‘h vâ€– = â€–vâ€–",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Surjective",
  "constType": "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Not", "LT.lt", "lt_iff_le_not_ge", "LE.le", "And.right", "Iff.mp"],
  "name": "not_le_of_gt",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, a < b â†’ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Max.max",
  "constType": "{Î± : Type u} â†’ [self : Max Î±] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.cast", "Iff.mpr", "Int.ofNat_lt"],
  "name": "Lean.Omega.Int.ofNat_lt_of_lt",
  "constType": "âˆ€ {x y : â„•}, x < y â†’ â†‘x < â†‘y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "mul_one",
   "List.prod",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
  "constType":
  "âˆ€ {M : Type u_1} [inst : GroupWithZero M] (x : M), x = Mathlib.Tactic.FieldSimp.NF.eval [(1, x)]",
  "constCategory": "Theorem"},
 {"references": ["congrArgâ‚‚"],
  "name": "congr_argâ‚‚",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} (f : Î± â†’ Î² â†’ Î³) {x x' : Î±} {y y' : Î²}, x = x' â†’ y = y' â†’ f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{Î± : Sort u} â†’ [i : Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pure.pure",
  "constType":
  "{f : Type u â†’ Type v} â†’ [self : Pure f] â†’ {Î± : Type u} â†’ Î± â†’ f Î±",
  "constCategory": "Definition"},
 {"references":
  ["dist_nonneg",
   "Norm.norm",
   "Dist.dist",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dist_zero_right",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_nonneg",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), 0 â‰¤ â€–aâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Commute.right_comm",
   "Nat.cast",
   "Invertible.invOf",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNNRat.casesOn",
   "Eq.mp",
   "HMul.hMul",
   "congrArg",
   "congr",
   "Eq.symm",
   "Nat.cast_mul",
   "Eq.ndrec",
   "mul_invOf_cancel_right'",
   "Nat.mul",
   "Nat.cast_commute",
   "Commute.invOf_right",
   "congr_arg",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNNRat_mul._simp_1_1",
   "Commute.invOf_left",
   "invertibleMul",
   "eq_self",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.invertibleOfMul'"],
  "name": "Mathlib.Meta.NormNum.isNNRat_mul",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] {f : Î± â†’ Î± â†’ Î±} {a b : Î±} {na nb nc da db dc k : â„•},\n  f = HMul.hMul â†’\n    Mathlib.Meta.NormNum.IsNNRat a na da â†’\n      Mathlib.Meta.NormNum.IsNNRat b nb db â†’\n        na.mul nb = k.mul nc â†’ da.mul db = k.mul dc â†’ Mathlib.Meta.NormNum.IsNNRat (f a b) nc dc",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "SphericallyCompleteSpace.OrthComp",
   "LinearMap.ker",
   "Norm.norm",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthProj",
   "Exists.choose",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Subtype.val",
   "DFunLike.coe",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "OfNat.ofNat",
   "RingHom.id",
   "LE.le",
   "id"],
  "name": "SphericallyCompleteSpace.orthcomp_eq_ker_OrthProj",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F],\n  SphericallyCompleteSpace.OrthComp ğ•œ F = (â†‘(SphericallyCompleteSpace.OrthProj ğ•œ F)).ker",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1_1",
   "Nat.rawCast"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "âˆ€ {Î± : Type u} {a : Î±} {n : â„•} [inst : AddMonoidWithOne Î±], Mathlib.Meta.NormNum.IsNat a n â†’ a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "AddLeftReflectLT",
   "AddLeftStrictMono",
   "lt_add_iff_pos_right",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : LT Î±] [AddLeftStrictMono Î±] [AddLeftReflectLT Î±] (a : Î±) {b : Î±},\n  (a < a + b) = (0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval.match_1",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "List.map",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "HPow.hPow",
   "List.prod",
   "Mathlib.Tactic.FieldSimp.zpow'_of_ne_zero_left",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "mul_pos",
   "congrArg",
   "LT.lt",
   "LT.lt.ne'",
   "zpow_pos",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons_pos",
  "constType":
  "âˆ€ {M : Type u_1} [inst : GroupWithZero M] [inst_1 : PartialOrder M] [PosMulStrictMono M] [PosMulReflectLT M]\n  [ZeroLEOneClass M] (r : â„¤) {x : M},\n  0 < x â†’ âˆ€ {l : Mathlib.Tactic.FieldSimp.NF M}, 0 < l.eval â†’ 0 < ((r, x) ::áµ£ l).eval",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl", "Norm.norm", "LE.le", "ContinuousLinearMap.le_of_opNorm_le_of_le"],
  "name": "ContinuousLinearMap.le_of_opNorm_le",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F)\n  {c : â„}, â€–fâ€– â‰¤ c â†’ âˆ€ (x : E), â€–f xâ€– â‰¤ c * â€–xâ€–",
  "constCategory": "Theorem"},
 {"references": ["IsTrichotomous.trichotomous"],
  "name": "trichotomous",
  "constType":
  "âˆ€ {Î± : Sort u_1} {r : Î± â†’ Î± â†’ Prop} [IsTrichotomous Î± r] (a b : Î±), r a b âˆ¨ a = b âˆ¨ r b a",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Bot.bot"],
  "name": "Disjoint",
  "constType":
  "{Î± : Type u_1} â†’ [inst : PartialOrder Î±] â†’ [OrderBot Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_9",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Quot.sound", "id", "Quot.liftOn", "congrArg"],
  "name": "funext",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x}, (âˆ€ (x : Î±), f x = g x) â†’ f = g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±],\n  (âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n      (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty) â†’\n    SphericallyCompleteSpace Î±",
  "constCategory": "Other"},
 {"references":
  ["Int.add_assoc",
   "Eq.trans",
   "Lean.Omega.Coeffs",
   "congrArg",
   "HAdd.hAdd",
   "congr",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Eq.mpr",
   "Lean.Omega.LinearCombo.casesOn",
   "Int.add_left_comm",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.add_eval",
  "constType":
  "âˆ€ (lâ‚ lâ‚‚ : Omega.LinearCombo) (v : Omega.Coeffs), (lâ‚ + lâ‚‚).eval v = lâ‚.eval v + lâ‚‚.eval v",
  "constCategory": "Theorem"},
 {"references": ["Set", "top_disjoint"],
  "name": "Set.univ_disjoint",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Disjoint Set.univ s â†” s = âˆ…",
  "constCategory": "Theorem"},
 {"references": ["inferInstance", "Padic", "Nat.Prime"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpacePadic",
  "constType":
  "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], SphericallyCompleteSpace â„š_[p]",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_3",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_4",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {x : Mâ‚‚}, (x âˆˆ f.range) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "And.right",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "HAdd.hAdd",
   "HSMul.hSMul",
   "Submodule.mem_span_singleton",
   "And.left"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (M : â†¥(D + ğ•œ âˆ™ a)) (this : âˆƒ y âˆˆ D, âˆƒ z âˆˆ ğ•œ âˆ™ a, y + z = â†‘M),\n  âˆƒ a_1, a_1 â€¢ a = â‹¯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name": "Set.mem_range._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±} {x : Î±}, (x âˆˆ Set.range f) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_10",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": ["not_le", "LT.lt", "Not", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, (Â¬a â‰¤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubgroupClass.toAddGroup._proof_1",
  "constType":
  "âˆ€ {G : Type u_2} [inst : AddGroup G] {S : Type u_1} [inst_1 : SetLike S G] [AddSubgroupClass S G], AddSubmonoidClass S G",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_7",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast_nonneg"],
  "name": "Mathlib.Tactic.Linarith.natCast_nonneg",
  "constType":
  "âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] (n : â„•), 0 â‰¤ â†‘n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_2",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {x : Mâ‚‚}, (x âˆˆ f.range) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Unit"],
  "name": "cond",
  "constType": "{Î± : Sort u} â†’ Bool â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Eq.mp", "HMul.hMul", "one_mul", "OfNat.ofNat", "congrArg"],
  "name": "Mathlib.Tactic.Linarith.without_one_mul",
  "constType":
  "âˆ€ {M : Type u_1} [inst : MulOneClass M] {a b : M}, 1 * a = b â†’ a = b",
  "constCategory": "Theorem"},
 {"references": ["Set.Nonempty", "upperBounds", "Set"],
  "name": "BddAbove",
  "constType": "{Î± : Type u_1} â†’ [LE Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.PropLemmas.0.exists_prop.match_1_3",
   "_private.Init.PropLemmas.0.exists_prop.match_1_1"],
  "name": "exists_prop",
  "constType": "âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) â†” a âˆ§ b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "absurd", "Not", "_private.Init.Core.0.if_neg.match_1_1", "ite"],
  "name": "if_neg",
  "constType":
  "âˆ€ {c : Prop} {h : Decidable c}, Â¬c â†’ âˆ€ {Î± : Sort u} {t e : Î±}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Iff.mpr",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ b â†’ a",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne.natCast_zero"],
  "name": "Nat.cast_zero",
  "constType": "âˆ€ {R : Type u_1} [inst : AddMonoidWithOne R], â†‘0 = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSMul.hSMul",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HSMul Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_4",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "âˆ€ (Î± : Type u) [inst : AddMonoidWithOne Î±] {a : Î±} {n : â„•}, â†‘n = a â†’ Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "Maximal",
   "Set",
   "RingHom.id",
   "Membership.mem",
   "inferInstance",
   "Exists.choose"],
  "name": "SphericallyCompleteSpace.instNormedAddCommGroupSphericalCompletion",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u_2) â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [inst_3 : IsUltrametricDist E] â†’\n            (Eâ‚€ : Type u_3) â†’\n              [inst_4 : NormedAddCommGroup Eâ‚€] â†’\n                [inst_5 : NormedSpace ğ•œ Eâ‚€] â†’\n                  [inst_6 : IsUltrametricDist Eâ‚€] â†’\n                    [inst_7 : SphericallyCompleteSpace Eâ‚€] â†’ (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) â†’ NormedAddCommGroup â†¥â‹¯.choose",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "add_eq_left", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_1",
  "constType":
  "âˆ€ {M : Type u_4} [inst : AddMonoid M] [IsLeftCancelAdd M] {a b : M}, (a + b = a) = (b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe", "Set", "Membership.mem", "OfNat.ofNat", "Submodule.zero_mem"],
  "name": "Submodule.nonempty",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M), (â†‘p).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_3",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x âˆˆ p), (âŸ¨x, hâŸ© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_2",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "id", "Eq.mpr", "congrArg"],
  "name": "Mathlib.Tactic.Abel.subst_into_addg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (l r tl tr t : Î±), l = tl â†’ r = tr â†’ tl + tr = t â†’ l + r = t",
  "constCategory": "Theorem"},
 {"references": ["IsometryEquiv.isometry_toFun"],
  "name": "IsometryEquiv.isometry",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] (h : Î± â‰ƒáµ¢ Î²), Isometry â‡‘h",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "lt_self_iff_false", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_16",
  "constType": "âˆ€ {Î± : Type u_2} [inst : Preorder Î±] (x : Î±), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "closure"],
  "name": "Dense",
  "constType": "{X : Type u} â†’ [TopologicalSpace X] â†’ Set X â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Max.max", "LE.le", "sup_le_iff", "propext"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€._simp_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, (a âŠ” b â‰¤ c) = (a â‰¤ c âˆ§ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_2",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (i : â„•), IsBoundedSMul ğ•œ E",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Classical.propDecidable",
   "lt_of_le_of_ne",
   "GE.ge",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "strictMono_nat_of_lt_succ",
   "strictAnti_nat_of_succ_lt",
   "False.elim",
   "congr",
   "forall_congr",
   "funext",
   "Eq.symm",
   "not_true_eq_false",
   "Eq.ndrec",
   "eventually_stable_or_exists_strictanti_of_antitone._simp_1_4",
   "And.left",
   "Not",
   "eventually_stable_or_exists_strictanti_of_antitone._simp_1_5",
   "_private.SphericalCompleteness.External.Sequence.0.esoesoa._proof_2",
   "binderNameHint",
   "_private.SphericalCompleteness.External.Sequence.0.esoesoa",
   "Classical.not_imp._simp_2",
   "Exists.choose_spec",
   "And.right",
   "Function.comp",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "StrictAnti",
   "Antitone",
   "LE.le",
   "id",
   "and_false",
   "Ne",
   "dite",
   "Exists.choose.congr_simp",
   "StrictMono",
   "Mathlib.Tactic.Push.not_forall_eq"],
  "name": "eventually_stable_or_exists_strictanti_of_antitone",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {f : â„• â†’ Î±},\n  Antitone f â†’ (âˆƒ N, âˆ€ n â‰¥ N, f n = f N) âˆ¨ âˆƒ Ï†, StrictMono Ï† âˆ§ StrictAnti (f âˆ˜ Ï†)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_4",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, (x â‰¥ y) = (y â‰¤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul",
   "Int.cast_mul",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isInt_mul.match_1_1",
   "Eq.symm",
   "HMul.hMul",
   "Int.cast"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {f : Î± â†’ Î± â†’ Î±} {a b : Î±} {a' b' c : â„¤},\n  f = HMul.hMul â†’\n    Mathlib.Meta.NormNum.IsInt a a' â†’\n      Mathlib.Meta.NormNum.IsInt b b' â†’ a'.mul b' = c â†’ Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth",
   "SphericallyCompleteSpace.orth_symm",
   "Eq.mp",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.Orth",
   "propext",
   "congrArg"],
  "name": "SphericallyCompleteSpace.orth_smul_of_orth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x y : E} (a : ğ•œ), (x âŸ‚[ğ•œ] y) â†’ x âŸ‚[ğ•œ] a â€¢ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bind.bind",
  "constType":
  "{m : Type u â†’ Type v} â†’ [self : Bind m] â†’ {Î± Î² : Type u} â†’ m Î± â†’ (Î± â†’ m Î²) â†’ m Î²",
  "constCategory": "Definition"},
 {"references": ["Set", "Singleton.singleton", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_singleton_iff",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, a âˆˆ {b} â†” a = b",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_3",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆ€ (a : Î±), a = a' â†’ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast", "LE.le", "propext", "Mathlib.Tactic.Zify.natCast_le"],
  "name": "Mathlib.Tactic.Zify.natCast_le._simp_1",
  "constType": "âˆ€ (a b : â„•), (a â‰¤ b) = (â†‘a â‰¤ â†‘b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.subsingleton_singleton",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq.symm",
   "Set.Subsingleton.eq_singleton_of_mem",
   "Set.Subsingleton"],
  "name": "Set.subsingleton_iff_singleton",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {x : Î±}, x âˆˆ s â†’ (s.Subsingleton â†” s = {x})",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.casesOn",
  "constType":
  "{Î± : Sort u_1} â†’\n  {a : Î±} â†’ {motive : (a_1 : Î±) â†’ a = a_1 â†’ Sort u} â†’ {a_1 : Î±} â†’ (t : a = a_1) â†’ motive a â‹¯ â†’ motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_right_neg",
   "Int.add_le_add_right",
   "HAdd.hAdd",
   "Eq.mp",
   "Neg.neg",
   "LE.le",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.sub_nonneg_of_le",
  "constType": "âˆ€ {a b : â„¤}, b â‰¤ a â†’ 0 â‰¤ a - b",
  "constCategory": "Theorem"},
 {"references": ["ite", "Classical.propDecidable", "HPow.hPow", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.zpow'",
  "constType": "{Î± : Type u_1} â†’ [GroupWithZero Î±] â†’ Î± â†’ â„¤ â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.câ‚€._simp_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, (x â‰¥ y) = (y â‰¤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_3",
   "Eq.trans",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension._simp_1_9",
   "Membership.mem",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
   "Iff.mp",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.T",
   "HMul.hMul",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_4",
   "Subtype.val",
   "Set.Elem",
   "iSup",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
   "RingHom.id",
   "forall_congr",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "Submodule.mem_iSup_of_directed",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hDM",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_1",
   "Set.Nonempty.to_subtype",
   "Norm.norm",
   "Exists.choose_spec",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "Set.Nonempty.some_mem",
   "Set.Nonempty.some",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.glued_map._proof_2",
   "Submodule.mem_iSup",
   "Exists.casesOn",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hT",
   "Iff.of_eq",
   "upperBounds",
   "Iff.mpr",
   "id",
   "Eq.mpr",
   "IsChain",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_7",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.isboundedlinearmap_of_glued_map",
   "le_trans",
   "IsChain.directed",
   "DFunLike.coe",
   "congrArg",
   "Subtype.prop",
   "congr",
   "Preorder.mk.congr_simp",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.directed_chain",
   "Submodule.mem_iSup_of_mem",
   "propext",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension._simp_1_5",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.glued_map",
   "Not",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_6",
   "Set.Nonempty",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension._simp_1_8",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hU",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.glued_map._proof_1",
   "And.casesOn"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F]\n  [inst_7 : SphericallyCompleteSpace F] {S : â†¥D â†’L[ğ•œ] F} {ğ’° : Set (E â†’L[ğ•œ] F)} (hğ’° : ğ’°.Nonempty) (Îµ : â†‘ğ’° â†’ â„),\n  (âˆ€ (T : â†‘ğ’°), 0 < Îµ T) â†’\n    âˆ€ (P : Set (SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ)),\n      IsChain (fun x1 x2 â†¦ x1 â‰¤ x2) P â†’ P.Nonempty â†’ BddAbove P",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ], RingHomInvPair (RingHom.id ğ•œ) (RingHom.id ğ•œ)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.neg_eval",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.sub_eq_add_neg",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.eval",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.sub_eval",
  "constType":
  "âˆ€ (lâ‚ lâ‚‚ : Omega.LinearCombo) (v : Omega.Coeffs), (lâ‚ - lâ‚‚).eval v = lâ‚.eval v - lâ‚‚.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SetLike.mem_coe._simp_1",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "rfl", "Nat.cast"],
  "name": "Int.natCast_add",
  "constType": "âˆ€ (n m : â„•), â†‘(n + m) = â†‘n + â†‘m",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_2",
   "Eq.mp",
   "Membership.mem",
   "NNReal.toReal",
   "Iff.mp",
   "SProd.sprod",
   "and_true",
   "Set.iInter",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_4",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_1",
   "Prod.fst",
   "congrArg",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_6",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "congr",
   "forall_congr",
   "funext",
   "Dist.dist",
   "Eq.symm",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_5",
   "And.left",
   "dist_self",
   "Set.Nonempty",
   "Set",
   "And.right",
   "NNReal",
   "Prod.snd",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_3",
   "true_and",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_7",
   "Set.mem_prod",
   "OfNat.ofNat",
   "Exists.casesOn",
   "closedBall_prod_same",
   "Metric.closedBall",
   "HasSubset.Subset",
   "Antitone",
   "NNDist.nndist",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace",
  "constType":
  "âˆ€ {E : Type u_1} {F : Type u_2} [inst : PseudoMetricSpace E] [inst_1 : PseudoMetricSpace F]\n  [hse : SphericallyCompleteSpace E] [hsf : SphericallyCompleteSpace F], SphericallyCompleteSpace (E Ã— F)",
  "constCategory": "Theorem"},
 {"references": ["HSMul.hSMul", "AddHom.toFun", "Eq.ndrec", "DFunLike.coe"],
  "name": "LinearMap.mk.congr_simp",
  "constType":
  "âˆ€ {R : Type u_14} {S : Type u_15} [inst : Semiring R] [inst_1 : Semiring S] {Ïƒ : R â†’+* S} {M : Type u_16}\n  {Mâ‚‚ : Type u_17} [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M]\n  [inst_5 : _root_.Module S Mâ‚‚] (toAddHom toAddHom_1 : M â†’â‚™+ Mâ‚‚) (e_toAddHom : toAddHom = toAddHom_1)\n  (map_smul' : âˆ€ (m : R) (x : M), toAddHom.toFun (m â€¢ x) = Ïƒ m â€¢ toAddHom.toFun x),\n  { toAddHom := toAddHom, map_smul' := map_smul' } = { toAddHom := toAddHom_1, map_smul' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.add",
   "Nat.le_succ_of_le",
   "_private.Init.Data.Nat.Basic.0.Nat.le_add_right.match_1_1",
   "Nat.below",
   "LE.le",
   "Nat.le_refl",
   "Nat.brecOn",
   "OfNat.ofNat"],
  "name": "Nat.le_add_right",
  "constType": "âˆ€ (n k : â„•), n â‰¤ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "Metric.isBounded_closedBall",
   "Membership.mem",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_3",
   "Metric.dist_le_diam_of_mem",
   "Or.resolve_right",
   "NNReal.toReal",
   "Metric.diam",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_1",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "Subtype.prop",
   "forall_congr",
   "Dist.dist",
   "Eq.symm",
   "Not",
   "binderNameHint",
   "LT.lt.not_ge",
   "Set",
   "NNReal",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_4",
   "OfNat.ofNat",
   "LT.lt",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "Metric.closedBall",
   "Set.Ioc",
   "NNDist.nndist",
   "Classical.byContradiction",
   "SphericallyCompleteSpace.IsSphericallyDense.spherically_dense",
   "LE.le",
   "id",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_2",
   "Mathlib.Tactic.Push.not_and_eq",
   "Eq.mpr",
   "Metric.diam_le_of_forall_dist_le"],
  "name": "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±],\n  SphericallyCompleteSpace.IsSphericallyDense Î± â†’\n    âˆ€ (z : Î±) â¦ƒr r' : NNRealâ¦„,\n      r' < r â†’ âˆƒ x y, x âˆˆ Metric.closedBall z â†‘r âˆ§ y âˆˆ Metric.closedBall z â†‘r âˆ§ nndist x y âˆˆ Set.Ioc r' r",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_2",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero.mul_inv_cancel", "Ne", "OfNat.ofNat"],
  "name": "mul_inv_cancelâ‚€",
  "constType":
  "âˆ€ {Gâ‚€ : Type u} [inst : GroupWithZero Gâ‚€] {a : Gâ‚€}, a â‰  0 â†’ a * aâ»Â¹ = 1",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "implies_congr",
  "constType":
  "âˆ€ {pâ‚ pâ‚‚ : Sort u} {qâ‚ qâ‚‚ : Sort v}, pâ‚ = pâ‚‚ â†’ qâ‚ = qâ‚‚ â†’ (pâ‚ â†’ qâ‚) = (pâ‚‚ â†’ qâ‚‚)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "SetLike.ext"],
  "name": "Submodule.ext",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M}, (âˆ€ (x : M), x âˆˆ p â†” x âˆˆ q) â†’ p = q",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ", "dense_iff_closure_eq", "Set", "Iff.mp", "closure", "Dense"],
  "name": "Dense.closure_eq",
  "constType":
  "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, Dense s â†’ closure s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "neg_add_cancel_right",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "congrArg"],
  "name": "sub_add_cancel",
  "constType": "âˆ€ {G : Type u_1} [inst : AddGroup G] (a b : G), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_4",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "one_ne_zero._simp_1",
   "Eq.trans",
   "of_eq_true",
   "ite",
   "Classical.propDecidable",
   "and_false",
   "HPow.hPow",
   "zpow_one",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.zpow'_one",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : GroupWithZero Î±] (a : Î±), Mathlib.Tactic.FieldSimp.zpow' a 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "norm_pos_iff", "Norm.norm", "Ne", "OfNat.ofNat", "propext"],
  "name": "norm_pos_iff'._simp_2",
  "constType":
  "âˆ€ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, (0 < â€–aâ€–) = (a â‰  0)",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.imm_ext_in_sph_comp", "RingHom.id"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp.congr_simp",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (Eâ‚€ : Type u_3) [inst_4 : NormedAddCommGroup Eâ‚€]\n  [inst_5 : NormedSpace ğ•œ Eâ‚€] [inst_6 : IsUltrametricDist Eâ‚€] [inst_7 : SphericallyCompleteSpace Eâ‚€]\n  (f f_1 : E â†’â‚—áµ¢[ğ•œ] Eâ‚€),\n  f = f_1 â†’\n    âˆ€ (a a_1 : Submodule ğ•œ Eâ‚€),\n      a = a_1 â†’\n        SphericallyCompleteSpace.imm_ext_in_sph_comp E Eâ‚€ f a =\n          SphericallyCompleteSpace.imm_ext_in_sph_comp E Eâ‚€ f_1 a_1",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "ite", "ite_congr", "congrArg"],
  "name": "ite_cond_eq_true",
  "constType":
  "âˆ€ {Î± : Sort u} {c : Prop} {x : Decidable c} (a b : Î±), c = True â†’ (if c then a else b) = a",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "forall_apply_eq_imp_iffâ‚‚",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  (âˆ€ (b : Î²) (a : Î±), p a â†’ f a = b â†’ q b) â†” âˆ€ (a : Î±), p a â†’ q (f a)",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "propext"],
  "name": "Classical.not_not._simp_3",
  "constType": "âˆ€ {a : Prop}, (Â¬Â¬a) = a",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_1",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_5",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_15",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± Ã— Î² â†’ Prop}, (âˆƒ x, p x) = âˆƒ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "lp.instNormedSpace._proof_1",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {Î± : Type u_3} {E : Î± â†’ Type u_2} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] [inst_1 : NormedField ğ•œ]\n  [inst_2 : (i : Î±) â†’ NormedSpace ğ•œ (E i)] (i : Î±), IsBoundedSMul ğ•œ (E i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_2",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["neg_mem_iff", "Neg.neg", "Membership.mem", "neg_sub", "HSub.hSub"],
  "name": "sub_mem_comm_iff",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddGroup G] {S : Type u_6} {H : S} [inst_1 : SetLike S G] [AddSubgroupClass S G] {a b : G},\n  a - b âˆˆ H â†” b - a âˆˆ H",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "HSMul.hSMul",
   "Eq.symm",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.term_add_constg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (n : â„¤) (x a k a' : Î±),\n  a + k = a' â†’ Mathlib.Tactic.Abel.termg n x a + k = Mathlib.Tactic.Abel.termg n x a'",
  "constCategory": "Theorem"},
 {"references": ["Set.image", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_image",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), y âˆˆ f '' s â†” âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs.set", "OfNat.ofNat"],
  "name": "Lean.Omega.LinearCombo.coordinate",
  "constType": "â„• â†’ Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, (Â¬a < b) = (b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_15",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_11",
   "Submodule.span",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_8",
   "Subtype.val",
   "Subspace",
   "Prod.fst",
   "RingHom.id",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_4",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_12",
   "SphericallyCompleteSpace.MOrth",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_7",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_16",
   "Set",
   "Prod.snd",
   "Exists.choose",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_13",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_1",
   "Max.max",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_9",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_10",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_2",
   "Eq.mpr"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [inst_3 : IsUltrametricDist E] â†’\n            (x : E) â†’ (F : Subspace ğ•œ E) â†’ SphericallyCompleteSpace.MOrth ğ•œ x F â†’ â†¥(ğ•œ âˆ™ x) Ã— â†¥F â‰ƒâ‚—áµ¢[ğ•œ] â†¥(ğ•œ âˆ™ x + F)",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Subtype.val"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (M : â†¥(D + ğ•œ âˆ™ a)), âˆƒ y âˆˆ D, âˆƒ z âˆˆ ğ•œ âˆ™ a, y + z = â†‘M",
  "constCategory": "Theorem"},
 {"references": ["Set.Ici", "iInf", "Filter.principal"],
  "name": "Filter.atTop",
  "constType": "{Î± : Type u_3} â†’ [Preorder Î±] â†’ Filter Î±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "HAdd.hAdd"],
  "name": "AddLeftReflectLT",
  "constType": "(M : Type u_1) â†’ [Add M] â†’ [LT M] â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "And.left"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_10",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (z : â†¥(ğ•œ âˆ™ x âŠ” F)), â‹¯.choose âˆˆ ğ•œ âˆ™ x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.ext_iff", "Membership.mem", "Subtype.val", "Iff.symm"],
  "name": "SetLike.coe_eq_coe",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : â†¥p}, â†‘x = â†‘y â†” x = y",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "Antitone",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [Preorder Î±] â†’ [Preorder Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["MulAction.one_smul"],
  "name": "one_smul",
  "constType":
  "âˆ€ (M : Type u_1) {Î± : Type u_5} [inst : Monoid M] [inst_1 : MulAction M Î±] (b : Î±), 1 â€¢ b = b",
  "constCategory": "Theorem"},
 {"references": ["Set.mem_singleton_iff", "OfNat.ofNat"],
  "name": "Submodule.mem_bot",
  "constType":
  "âˆ€ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  x âˆˆ âŠ¥ â†” x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_14",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "SphericallyCompleteSpace.MOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.SOrth",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’ [IsUltrametricDist E] â†’ Subspace ğ•œ E â†’ Subspace ğ•œ E â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["inferInstance"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpaceReal",
  "constType": "SphericallyCompleteSpace â„",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Order.Defs.LinearOrder.0.max_le._proof_1_1", "LE.le"],
  "name": "max_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b c : Î±}, a â‰¤ c â†’ b â‰¤ c â†’ max a b â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["neg_mem_iff", "Neg.neg", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth._simp_1_2",
  "constType":
  "âˆ€ {S : Type u_3} {G : Type u_4} [inst : InvolutiveNeg G] {x : SetLike S G} [NegMemClass S G] {H : S} {x_1 : G},\n  (-x_1 âˆˆ H) = (x_1 âˆˆ H)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "left_distrib",
   "HMul.hMul",
   "congrArg"],
  "name": "CancelDenoms.add_subst",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {n e1 e2 t1 t2 : Î±}, n * e1 = t1 â†’ n * e2 = t2 â†’ n * (e1 + e2) = t1 + t2",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_5",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "dist_triangle",
   "dist_comm",
   "Dist.dist",
   "_private.Mathlib.Topology.MetricSpace.Pseudo.Defs.0.dist_nonneg'"],
  "name": "dist_nonneg",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±}, 0 â‰¤ dist x y",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HasQuotient.Quotient",
  "constType":
  "(A : outParam (Type u)) â†’ {B : Type v} â†’ [self : HasQuotient A B] â†’ B â†’ Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["_private.Mathlib.Order.Lattice.0.le_sup_iff._proof_1_1"],
  "name": "le_sup_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b c : Î±}, a â‰¤ max b c â†” a â‰¤ b âˆ¨ a â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "Eq.ndrec",
   "add_mul",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {aâ‚ aâ‚‚ b câ‚ câ‚‚ d : R},\n  aâ‚ * b = câ‚ â†’ aâ‚‚ * b = câ‚‚ â†’ câ‚ + câ‚‚ = d â†’ (aâ‚ + aâ‚‚) * b = d",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_6",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, (dist x y â‰¤ â†‘c) = (nndist x y â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.dist_le_diam_of_mem'",
   "Set",
   "Membership.mem",
   "Bornology.IsBounded",
   "Bornology.IsBounded.ediam_ne_top"],
  "name": "Metric.dist_le_diam_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} {x y : Î±} [inst : PseudoMetricSpace Î±],\n  Bornology.IsBounded s â†’ x âˆˆ s â†’ y âˆˆ s â†’ dist x y â‰¤ Metric.diam s",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "Prod.snd",
   "SProd.sprod",
   "Set.mem_prod",
   "propext",
   "Prod.fst"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {s : Set Î±} {t : Set Î²} {p : Î± Ã— Î²}, (p âˆˆ s Ã—Ë¢ t) = (p.1 âˆˆ s âˆ§ p.2 âˆˆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.rangeFactorization_injective",
   "LinearMap.range",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "map_smul",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "RingHom.id",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Subtype.val_injective",
   "Set",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "Set.rangeFactorization_surjective",
   "Eq.casesOn",
   "Function.RightInverse",
   "LinearIsometry.toLinearMap",
   "Function.rightInverse_invFun",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_3",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] (f : E â†’â‚—áµ¢[ğ•œ] F)\n  (c : ğ•œ) (x : â†¥f.range),\n  Function.invFun (Set.rangeFactorization â‡‘f) (c â€¢ x) = (RingHom.id ğ•œ) c â€¢ Function.invFun (Set.rangeFactorization â‡‘f) x",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "dist_comm",
   "Eq.mp",
   "congr",
   "Dist.dist",
   "HSub.hSub",
   "dist_eq_norm_sub",
   "congrArg"],
  "name": "norm_sub_rev",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), â€–a - bâ€– = â€–b - aâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "eq_true",
   "ite_cond_eq_true",
   "Subtype.val",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_7",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_1",
   "SphericallyCompleteSpace.câ‚€._simp_2",
   "iSup",
   "Eq.symm",
   "Eq.ndrec",
   "norm_zero",
   "mem_lowerBounds",
   "rfl",
   "Norm.norm",
   "Exists.choose_spec",
   "Set.Nonempty.some_mem",
   "Set.mem_image",
   "add_neg_cancel",
   "Nat.not_lt",
   "SetLike.coe",
   "eq_false",
   "lowerBounds",
   "Top.top",
   "norm_neg",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "exists_apply_eq_apply._simp_1",
   "setOf",
   "HasQuotient.Quotient",
   "AddSubsemigroup.carrier",
   "InfSet.sInf",
   "propext",
   "lp.norm_eq_ciSup",
   "Set",
   "ite",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_8",
   "memâ„“p_infty_iff",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "ENNReal",
   "norm_nonneg",
   "dite",
   "if_pos",
   "mem_upperBounds",
   "SphericallyCompleteSpace.câ‚€._proof_2",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€._proof_3",
   "SphericallyCompleteSpace.câ‚€",
   "GT.gt",
   "GE.ge",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_4",
   "quotient_norm_mk_eq",
   "SphericallyCompleteSpace.câ‚€._proof_1",
   "funext",
   "forall_congr",
   "AddSubmonoid.mk.congr_simp",
   "QuotientAddGroup.mk'",
   "Submodule.mk.congr_simp",
   "csInf_le",
   "Neg.neg",
   "Set.mem_range._simp_1",
   "And.right",
   "Submodule.toAddSubgroup",
   "add_zero",
   "Set.Nonempty.some",
   "BddAbove",
   "ite_cond_eq_false",
   "Exists.casesOn",
   "Set.image",
   "if_neg",
   "upperBounds",
   "Iff.mpr",
   "HSMul.hSMul",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_6",
   "id",
   "memâ„“p_infty",
   "Eq.mp",
   "lp",
   "le_trans",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "SphericallyCompleteSpace.câ‚€._proof_4",
   "Subtype.prop",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_5",
   "Memâ„“p",
   "Not",
   "ciSup_le",
   "PreLp",
   "Exists.choose",
   "SphericallyCompleteSpace.câ‚€._simp_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_3",
   "AddSubsemigroup.mk.congr_simp"],
  "name": "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_2) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] [âˆ€ (i : â„•), IsUltrametricDist (E i)] (A : â†¥(lp E âŠ¤)),\n  âˆ€ C > 0,\n    âˆ€ (N : â„•), (âˆ€ n â‰¥ N, â€–â†‘A nâ€– â‰¤ C) â†’ â€–(QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ E).toAddSubgroup) Aâ€– â‰¤ C",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.prop",
   "RingHom.id",
   "SetLike.coe_eq_coe",
   "SphericallyCompleteSpace.OrthProj",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.OrthProj_id",
   "DFunLike.coe",
   "Subtype.val"],
  "name": "SphericallyCompleteSpace.orthproj_idempotent",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F]\n  (x : E),\n  (SphericallyCompleteSpace.OrthProj ğ•œ F) â†‘((SphericallyCompleteSpace.OrthProj ğ•œ F) x) =\n    (SphericallyCompleteSpace.OrthProj ğ•œ F) x",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_iff_orth_of_nonzero",
   "SphericallyCompleteSpace.orth_symm",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "Ne",
   "SphericallyCompleteSpace.Orth",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "SphericallyCompleteSpace.orth_smul_iff_orth_of_nonzero",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x y : E} {a : ğ•œ}, a â‰  0 â†’ ((x âŸ‚[ğ•œ] y) â†” x âŸ‚[ğ•œ] a â€¢ y)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype.property",
  "constType": "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} (self : Subtype p), p â†‘self",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.coe_inj",
   "NNReal",
   "Eq.symm",
   "id",
   "NNReal.toReal",
   "Eq.mpr",
   "Iff.rfl",
   "NNReal.coe_zero",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "NNReal.coe_eq_zero",
  "constType": "âˆ€ {r : NNReal}, â†‘r = 0 â†” r = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_9",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT"],
  "name": "Lean.MacroM",
  "constType": "Type â†’ Type",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "neg_smul",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "congr",
   "HSMul.hSMul",
   "HSub.hSub",
   "add_smul",
   "congrArg"],
  "name": "sub_smul",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] (r s : R)\n  (y : M), (r - s) â€¢ y = r â€¢ y - s â€¢ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ContinuousLinearMap.toLinearMap",
  "constType":
  "{R : Type u_1} â†’\n  {S : Type u_2} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring S] â†’\n        {Ïƒ : R â†’+* S} â†’\n          {M : Type u_3} â†’\n            [inst_2 : TopologicalSpace M] â†’\n              [inst_3 : AddCommMonoid M] â†’\n                {Mâ‚‚ : Type u_4} â†’\n                  [inst_4 : TopologicalSpace Mâ‚‚] â†’\n                    [inst_5 : AddCommMonoid Mâ‚‚] â†’\n                      [inst_6 : _root_.Module R M] â†’ [inst_7 : _root_.Module S Mâ‚‚] â†’ (M â†’SL[Ïƒ] Mâ‚‚) â†’ M â†’â‚›â‚—[Ïƒ] Mâ‚‚",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name.mkStr1",
  "constType": "String â†’ Name",
  "constCategory": "Definition"},
 {"references":
  ["SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Singleton.singleton",
   "Membership.mem",
   "HMul.hMul",
   "Submodule.span",
   "Subtype.val",
   "DFunLike.coe",
   "Set.Elem",
   "RingHom.id",
   "HSub.hSub",
   "Not",
   "Set.Nonempty",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Norm.norm",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "Set",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Exists.choose",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "LT.lt",
   "HAdd.hAdd",
   "Max.max",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_1",
   "LE.le",
   "HSMul.hSMul"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’\n        [iude : IsUltrametricDist E] â†’\n          [inst_2 : NormedSpace ğ•œ E] â†’\n            {D : Submodule ğ•œ E} â†’\n              {a : E} â†’\n                a âˆ‰ D â†’\n                  {F : Type u_3} â†’\n                    [inst_3 : SeminormedAddCommGroup F] â†’\n                      [iud : IsUltrametricDist F] â†’\n                        [inst_4 : NormedSpace ğ•œ F] â†’\n                          [hsc : SphericallyCompleteSpace F] â†’\n                            (S : â†¥D â†’L[ğ•œ] F) â†’\n                              {ğ’° : Set (E â†’L[ğ•œ] F)} â†’\n                                ğ’°.Nonempty â†’\n                                  {Îµ : â†‘ğ’° â†’ â„} â†’\n                                    (âˆ€ (T : â†‘ğ’°), 0 < Îµ T) â†’\n                                      (âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V)) â†’\n                                        (âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–) â†’ â†¥(D + ğ•œ âˆ™ a) â†’ F",
  "constCategory": "Definition"},
 {"references":
  ["smul_zero",
   "Eq.trans",
   "smul_closedBall'",
   "Eq.mp",
   "HMul.hMul",
   "Filter.Eventually.of_forall",
   "congrArg",
   "IsCompact.smul",
   "False.elim",
   "LE.le.not_gt",
   "norm_pow",
   "congr",
   "Set.smulSet",
   "Filter.Tendsto.atTop_mul_const",
   "Filter.Tendsto",
   "norm_zero",
   "Metric.exists_isCompact_closedBall",
   "ProperSpace.of_seq_closedBall",
   "pow_ne_zero",
   "Norm.norm",
   "Set",
   "zero_le_one",
   "NormedField.exists_one_lt_norm",
   "HPow.hPow",
   "OfNat.ofNat",
   "LT.lt",
   "Exists.casesOn",
   "Metric.closedBall",
   "Filter.atTop",
   "IsCompact",
   "tendsto_pow_atTop_atTop_of_one_lt",
   "eq_false",
   "HSMul.hSMul",
   "Ne",
   "And.casesOn"],
  "name": "ProperSpace.of_locallyCompactSpace",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E] [NormedSpace ğ•œ E]\n  [LocallyCompactSpace E], ProperSpace E",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "eq_true", "SetLike.coe_mem", "Subtype.val"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_6",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : â†¥p), (â†‘x âˆˆ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Membership.mem.out",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "ENNReal",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "HSMul.hSMul",
   "LE.le",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_4",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : ğ•œ) (x_1 : E),\n  (SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) (x â€¢ x_1) âˆˆ â‹¯.choose",
  "constCategory": "Theorem"},
 {"references": [],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_1",
  "constType": "âˆ€ {E : Type u_1} [NormedAddCommGroup E], Nonempty E",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Membership.mem.out",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "ENNReal",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LE.le",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_2",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  (SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) (x + x_1) âˆˆ â‹¯.choose",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_8",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "dist_zero_left",
   "IsUltrametricDist.dist_eq_max_of_dist_ne_dist",
   "congrArg",
   "dist_zero",
   "not_false_eq_true",
   "congrFun",
   "congr",
   "Dist.dist",
   "Eq.symm",
   "HSub.hSub",
   "Not",
   "Norm.norm",
   "Neg.neg",
   "sub_neg_eq_add",
   "dist_zero_right",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "eq_false",
   "id",
   "norm_neg",
   "Eq.mpr",
   "Ne",
   "dist_eq_norm_sub"],
  "name": "IsUltrametricDist.norm_add_eq_max_of_norm_ne_norm",
  "constType":
  "âˆ€ {S : Type u_1} [inst : SeminormedAddGroup S] [IsUltrametricDist S] {x y : S}, â€–xâ€– â‰  â€–yâ€– â†’ â€–x + yâ€– = max â€–xâ€– â€–yâ€–",
  "constCategory": "Theorem"},
 {"references": ["Subtype.range_coe"],
  "name": "Subtype.range_coe_subtype",
  "constType":
  "âˆ€ {Î± : Type u_1} {p : Î± â†’ Prop}, Set.range Subtype.val = {x | p x}",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_1",
  "constType":
  "âˆ€ {a0 a1 : â„¤} {t : List â„¤}, (Omega.LinearCombo.coordinate 1).eval (Omega.Coeffs.ofList (a0 :: a1 :: t)) = a1",
  "constCategory": "Theorem"},
 {"references": ["setOf"],
  "name": "Set.univ",
  "constType": "{Î± : Type u} â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["propext", "And.left"],
  "name": "and_self",
  "constType": "âˆ€ (p : Prop), (p âˆ§ p) = p",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "sup_le_sup_left"],
  "name": "max_le_max_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b : Î±} (c : Î±), a â‰¤ b â†’ max c a â‰¤ max c b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "propext"],
  "name": "Classical.not_not._simp_1",
  "constType": "âˆ€ {a : Prop}, (Â¬Â¬a) = a",
  "constCategory": "Theorem"},
 {"references": ["dist_nonneg", "Dist.dist", "LE.le", "eq_true", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_16",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±}, (0 â‰¤ dist x y) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_exists", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_9",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop}, (Â¬âˆƒ x, p x) = âˆ€ (x : Î±), Â¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddSubsemigroup.mem_mk", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
  "constType":
  "âˆ€ {M : Type u_1} [inst : Add M] {s : Set M} {x : M} (h_add : âˆ€ {a b : M}, a âˆˆ s â†’ b âˆˆ s â†’ a + b âˆˆ s),\n  (x âˆˆ { carrier := s, add_mem' := h_add }) = (x âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "inferInstance", "OfNat.ofNat"],
  "name": "Mathlib.Meta.NormNum.instAtLeastTwo",
  "constType": "âˆ€ (n : â„•), (n + 2).AtLeastTwo",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "LinearIsometry.isometry",
   "Eq.mp",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericalCompletion_minimal",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "LinearIsometryEquiv.symm",
   "RingHom.id",
   "Eq.symm",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Isometry.isometryEquivOnRange",
   "LinearIsometry.comp",
   "Exists.choose",
   "Function.Surjective",
   "Exists.casesOn",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "SphericallyCompleteSpace.IsImmediate",
   "LinearMap.range_comp_le_range",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective",
   "LE.le",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_unique'",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [inst_6 : IsUltrametricDist F] [SphericallyCompleteSpace F] {f : E â†’â‚—áµ¢[ğ•œ] F},\n  SphericallyCompleteSpace.IsImmediate f â†’ Nonempty (SphericallyCompleteSpace.SphericalCompletion ğ•œ E â‰ƒâ‚—áµ¢[ğ•œ] F)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "dist_comm",
   "Eq.mp",
   "Set",
   "le_trans",
   "NNReal",
   "Inter.inter",
   "Membership.mem",
   "NNReal.toReal",
   "Subtype.val",
   "OfNat.ofNat",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric._simp_1_1",
   "congrArg",
   "Exists.casesOn",
   "Metric.closedBall",
   "Max.max",
   "IsUltrametricDist.dist_triangle_max",
   "Iff.mpr",
   "LE.le",
   "Dist.dist",
   "id",
   "Eq.mpr",
   "sup_le_iff",
   "And.casesOn"],
  "name":
  "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] [hiud : IsUltrametricDist Î±] {z1 z2 : Î±} {r1 r2 : NNReal},\n  r1 â‰¤ r2 â†’\n    (Metric.closedBall z1 â†‘r1 âˆ© Metric.closedBall z2 â†‘r2).Nonempty â†’ Metric.closedBall z1 â†‘r1 âŠ† Metric.closedBall z2 â†‘r2",
  "constCategory": "Theorem"},
 {"references": ["DistribSMul.smul_add"],
  "name": "smul_add",
  "constType":
  "âˆ€ {M : Type u_1} {A : Type u_7} [inst : AddZeroClass A] [inst_1 : DistribSMul M A] (a : M) (bâ‚ bâ‚‚ : A),\n  a â€¢ (bâ‚ + bâ‚‚) = a â€¢ bâ‚ + a â€¢ bâ‚‚",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "Ne",
  "constType": "{Î± : Sort u} â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Order.Defs.LinearOrder.0.max_assoc._proof_1_1"],
  "name": "max_assoc",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] (a b c : Î±), max (max a b) c = max a (max b c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Injective",
  "constType": "{Î± : Sort u_1} â†’ {Î² : Sort u_2} â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_isNNRat.match_1_1",
   "mul_one",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] {a : Î±} {n : â„•},\n  Mathlib.Meta.NormNum.IsNat a n â†’ Mathlib.Meta.NormNum.IsNNRat a n 1",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "AddRightMono", "lt_add_of_nonneg_of_lt", "LE.le", "OfNat.ofNat"],
  "name": "Right.add_pos_of_nonneg_of_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : Preorder Î±] [AddRightMono Î±] {a b : Î±}, 0 â‰¤ a â†’ 0 < b â†’ 0 < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh.match_1",
   "NNReal.toReal",
   "Subtype.val",
   "DFunLike.coe",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_5",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_4",
   "HSub.hSub",
   "QuotientAddGroup.mk'",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_1",
   "Norm.norm",
   "Set",
   "NNReal",
   "Submodule.quotientRel",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_2",
   "Submodule.toAddSubgroup",
   "Nat.brecOn",
   "Exists.choose",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "StrictAnti",
   "Antitone",
   "Nat.below",
   "QuotientAddGroup.mk",
   "Quotient.out",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_3"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : SeminormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [IsUltrametricDist E] â†’\n            {F : Submodule ğ•œ E} â†’\n              â¦ƒc : â„• â†’ E â§¸ Fâ¦„ â†’\n                â¦ƒr : â„• â†’ NNRealâ¦„ â†’\n                  StrictAnti r â†’ (Antitone fun i â†¦ Metric.closedBall (c i) â†‘(r i)) â†’ (t : â„•) â†’ { x // â†‘x = c t }",
  "constCategory": "Definition"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Submodule.mem_mk",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_9",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : AddSubmonoid M} {x : M} (h : âˆ€ (c : R) {x : M}, x âˆˆ S.carrier â†’ c â€¢ x âˆˆ S.carrier),\n  (x âˆˆ { toAddSubmonoid := S, smul_mem' := h }) = (x âˆˆ S)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Int.ofNat_le", "Iff.mpr", "LE.le"],
  "name": "Lean.Omega.Int.ofNat_le_of_le",
  "constType": "âˆ€ {x y : â„•}, x â‰¤ y â†’ â†‘x â‰¤ â†‘y",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.Â«term_âŸ‚â‚˜_Â»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "AddLeftMono",
   "Nat.cast",
   "Eq.trans",
   "OfNat.ofNat",
   "congrArg",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LT.lt",
   "of_eq_true",
   "iff_self",
   "congr",
   "Nat.cast_zero",
   "Eq.symm",
   "lt_self_iff_false._simp_1",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0.Nat.cast_pos'._simp_1_1",
   "Eq.ndrec",
   "Nat.zero_lt_succ._simp_1",
   "Nat.casesAuxOn"],
  "name": "Nat.cast_pos'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] [NeZero 1]\n  {n : â„•}, 0 < â†‘n â†” 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.subtype._proof_2",
   "RingHom.id",
   "Membership.mem",
   "Subtype.val",
   "Submodule.subtype._proof_1"],
  "name": "Submodule.subtype",
  "constType":
  "{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Semiring R] â†’ [inst_1 : AddCommMonoid M] â†’ {module_M : _root_.Module R M} â†’ (p : Submodule R M) â†’ â†¥p â†’â‚—[R] M",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Prod.fst",
   "congrArg",
   "congr",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (n : â„¤) (e : M) {L l l' : Mathlib.Tactic.FieldSimp.NF M},\n  L.eval * l.eval = l'.eval â†’ ((n, e) ::áµ£ L).eval * l.eval = ((n, e) ::áµ£ l').eval",
  "constCategory": "Theorem"},
 {"references": ["Not", "False.elim", "eq_true"],
  "name": "not_false_eq_true",
  "constType": "(Â¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NNReal.coe_mk",
   "le_of_not_gt",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "norm_zero",
   "Exists.choose_spec",
   "Norm.norm",
   "NNReal",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_5",
   "Antitone",
   "SMulMemClass.smul_mem",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_2",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "Mathlib.Tactic.Ring.add_mul",
   "Set.mem_of_mem_of_subset",
   "Submodule.mem_span_singleton_self",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "Subtype.dist_eq",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "dist_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "sub_smul",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Ne",
   "norm_nonneg",
   "antitone_nat_of_succ_le",
   "dite",
   "neg_neg_of_pos",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "Submodule.span",
   "HDiv.hDiv",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_3",
   "Submodule.eq_zero_of_bot_submodule",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "Bot.bot",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "norm_pos_iff",
   "Iff.mpr",
   "div_nonneg",
   "HSMul.hSMul",
   "id",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_1",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "le_div_iffâ‚€",
   "Eq.mp",
   "NNReal.toReal",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "mul_le_of_le_divâ‚€",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "NNReal.zero_le_coe",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_4",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Set.Nonempty",
   "Submodule.span_zero_singleton",
   "Mathlib.Tactic.Ring.cast_pos",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "norm_smul",
   "LT.lt",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] [scsk : SphericallyCompleteSpace ğ•œ] {E : Type u_2}\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] (z : E), SphericallyCompleteSpace â†¥(ğ•œ âˆ™ z)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Set.Nonempty",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "Classical.not_forall._simp_1",
   "Set.iInter",
   "EmptyCollection.emptyCollection",
   "not_exists._simp_1",
   "congrArg",
   "Classical.not_not._simp_1",
   "iff_self",
   "of_eq_true",
   "_private.Mathlib.Data.Set.Lattice.0.Set.nonempty_iInter._simp_1_1",
   "forall_congr",
   "funext",
   "Ne",
   "_private.Mathlib.Data.Set.Lattice.0.Set.nonempty_iInter._simp_1_2"],
  "name": "Set.nonempty_iInter",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty â†” âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["neg_mem_iff", "Neg.neg", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_2",
  "constType":
  "âˆ€ {S : Type u_3} {G : Type u_4} [inst : InvolutiveNeg G] {x : SetLike S G} [NegMemClass S G] {H : S} {x_1 : G},\n  (-x_1 âˆˆ H) = (x_1 âˆˆ H)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Filter.map"],
  "name": "Filter.Tendsto",
  "constType":
  "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (Î± â†’ Î²) â†’ Filter Î± â†’ Filter Î² â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "MonadExcept.throw",
  "constType":
  "{Îµ : outParam (Type u)} â†’ {m : Type v â†’ Type w} â†’ [self : MonadExcept Îµ m] â†’ {Î± : Type v} â†’ Îµ â†’ m Î±",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "mul_add",
   "Eq.symm",
   "HMul.hMul",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.subst_add",
  "constType":
  "âˆ€ {M : Type u_1} [inst : Semiring M] {xâ‚ xâ‚‚ Xâ‚ Xâ‚‚ Y y a : M},\n  xâ‚ = a * Xâ‚ â†’ xâ‚‚ = a * Xâ‚‚ â†’ Xâ‚ + Xâ‚‚ = Y â†’ a * Y = y â†’ xâ‚ + xâ‚‚ = y",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "rfl",
   "LinearIsometry.toLinearMap",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) (M : Submodule ğ•œ Eâ‚€) (hc : f.range â‰¤ M) (x x_1 : â†¥f.range), âŸ¨â†‘(x + x_1), â‹¯âŸ© = âŸ¨â†‘(x + x_1), â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "binderNameHint",
  "constType": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {Î³ : Sort w} â†’ Î± â†’ Î² â†’ Î³ â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hDM",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F]\n  [inst_7 : SphericallyCompleteSpace F] {S : â†¥D â†’L[ğ•œ] F} {ğ’° : Set (E â†’L[ğ•œ] F)} {hğ’° : ğ’°.Nonempty} {Îµ : â†‘ğ’° â†’ â„}\n  (self : SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ),\n  D â‰¤ SphericallyCompleteSpace.PartialExtension.Mâœ self",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.mpr", "Membership.mem", "nonempty_subtype"],
  "name": "Set.Nonempty.to_subtype",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s.Nonempty â†’ Nonempty â†‘s",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Map.0.Submodule.eq_zero_of_bot_submodule.match_1_1",
   "Membership.mem",
   "Submodule.mem_bot",
   "Iff.mp",
   "Subtype.ext",
   "Bot.bot",
   "OfNat.ofNat"],
  "name": "Submodule.eq_zero_of_bot_submodule",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (b : â†¥âŠ¥),\n  b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["not_le_of_gt", "LT.lt", "le_of_lt", "le_trans", "LE.le", "lt_of_le_not_ge"],
  "name": "lt_of_le_of_lt",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b c : Î±}, a â‰¤ b â†’ b < c â†’ a < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And.right",
  "constType": "âˆ€ {a b : Prop}, a âˆ§ b â†’ b",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "RingHom.id",
   "LE.le",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Exists.choose",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.OrthProj",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [iud : IsUltrametricDist E] â†’\n          [inst_2 : NormedSpace ğ•œ E] â†’ (F : Submodule ğ•œ E) â†’ [SphericallyCompleteSpace â†¥F] â†’ E â†’L[ğ•œ] â†¥F",
  "constCategory": "Definition"},
 {"references": ["and_imp", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_7",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["iff_self",
   "_private.Init.PropLemmas.0.exists_and_right._simp_1_1",
   "Eq.trans",
   "of_eq_true",
   "exists_and_left._simp_1",
   "congr",
   "funext",
   "congrArg"],
  "name": "exists_and_right",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_3",
  "constType":
  "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆ€ (a : Î±), b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["add_lt_add_iff_left",
   "HAdd.hAdd",
   "LT.lt",
   "Iff.trans",
   "AddLeftReflectLT",
   "AddLeftStrictMono",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "lt_add_iff_pos_right",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : LT Î±] [AddLeftStrictMono Î±] [AddLeftReflectLT Î±] (a : Î±) {b : Î±},\n  a < a + b â†” 0 < b",
  "constCategory": "Theorem"},
 {"references": ["inv_nonneg", "Inv.inv", "LE.le", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_6",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a : Gâ‚€},\n  (0 â‰¤ aâ»Â¹) = (0 â‰¤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "ite", "ite_congr", "congrArg"],
  "name": "ite_cond_eq_false",
  "constType":
  "âˆ€ {Î± : Sort u} {c : Prop} {x : Decidable c} (a b : Î±), c = False â†’ (if c then a else b) = b",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "eq_true", "le_sup_left"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_10",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (a â‰¤ a âŠ” b) = True",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "SphericallyCompleteSpace.câ‚€._simp_4",
  "constType":
  "âˆ€ {b : Prop} (Î± : Sort u_1) [i : Nonempty Î±], (âˆ€ (a : Î±), b) = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["propext", "exists_eq_right"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_12",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Subtype.ext_iff", "Membership.mem", "OfNat.ofNat"],
  "name": "Submodule.mk_eq_zero",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x âˆˆ p), âŸ¨x, hâŸ© = 0 â†” x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "Nat.cast",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "HPow.hPow",
   "add_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "pow_one",
   "eq_self",
   "of_eq_true",
   "congr"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max",
   "Codisjoint",
   "Min.min",
   "codisjoint_iff",
   "Disjoint",
   "Iff.mpr",
   "Top.top",
   "disjoint_iff",
   "Bot.bot"],
  "name": "IsCompl.of_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, x âŠ“ y = âŠ¥ â†’ x âŠ” y = âŠ¤ â†’ IsCompl x y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasSubset.Subset",
  "constType": "{Î± : Type u} â†’ [self : HasSubset Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Iff.not_right", "Not", "not_finite_iff_infinite", "Iff.symm"],
  "name": "not_infinite_iff_finite",
  "constType": "âˆ€ {Î± : Sort u_1}, Â¬Infinite Î± â†” Finite Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_6",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "mul_assoc",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Prod.fst",
   "congrArg",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (n : â„¤) (e : M) {L l l' : Mathlib.Tactic.FieldSimp.NF M},\n  L.eval * l.eval = l'.eval â†’ L.eval * ((n, e) ::áµ£ l).eval = ((n, e) ::áµ£ l').eval",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp", "Set", "RingHom.id"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp.eq_1",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (Eâ‚€ : Type u_3) [inst_4 : NormedAddCommGroup Eâ‚€]\n  [inst_5 : NormedSpace ğ•œ Eâ‚€] [inst_6 : IsUltrametricDist Eâ‚€] [inst_7 : SphericallyCompleteSpace Eâ‚€] (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€),\n  SphericallyCompleteSpace.imm_ext_in_sph_comp E Eâ‚€ f =\n    {M |\n      âˆƒ (hc : f.range â‰¤ M),\n        SphericallyCompleteSpace.IsImmediate\n          { toFun := fun x â†¦ âŸ¨â†‘x, â‹¯âŸ©, map_add' := â‹¯, map_smul' := â‹¯, norm_map' := â‹¯ }}",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "Norm.norm",
   "Memâ„“p",
   "Iff.mpr",
   "Top.top",
   "memâ„“p_infty_iff",
   "Set.range",
   "BddAbove"],
  "name": "memâ„“p_infty",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {f : (i : Î±) â†’ E i},\n  BddAbove (Set.range fun i â†¦ â€–f iâ€–) â†’ Memâ„“p f âŠ¤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubmonoidClass.toAddMonoid._proof_1",
  "constType":
  "âˆ€ {M : Type u_2} [inst : AddMonoid M] {A : Type u_1} [inst_1 : SetLike A M] [AddSubmonoidClass A M], AddMemClass A M",
  "constCategory": "Theorem"},
 {"references": ["SMulZeroClass.smul_zero"],
  "name": "smul_zero",
  "constType":
  "âˆ€ {M : Type u_1} {A : Type u_7} [inst : Zero A] [inst_1 : SMulZeroClass M A] (a : M), a â€¢ 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_2",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.leftInverse_invFun",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_4",
   "Eq.substr",
   "LinearIsometry.ext",
   "SphericallyCompleteSpace.hahn_banach'",
   "Eq.trans",
   "Set.rangeFactorization_injective",
   "Eq.mp",
   "LinearMap.range",
   "Membership.mem",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_3",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_2",
   "Subtype.val",
   "DFunLike.coe",
   "Set.Elem",
   "Set.range",
   "ContinuousLinearMap.comp",
   "congrArg",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_3",
   "RingHom.id",
   "forall_congr",
   "Eq.ndrec",
   "forall_prop_domain_congr",
   "rfl",
   "LinearIsometry.toContinuousLinearMap",
   "ContinuousLinearMap.toLinearMap",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "LinearMap.mem_range_self",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_1",
   "LinearIsometry.comp",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_2",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate",
   "Exists.casesOn",
   "eq_self",
   "SphericallyCompleteSpace.IsImmediate",
   "of_eq_true",
   "LinearIsometry.toLinearMap",
   "Iff.mpr",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [inst_6 : IsUltrametricDist F] {H : Type u_4} [inst_7 : NormedAddCommGroup H]\n  [inst_8 : NormedSpace ğ•œ H] [IsUltrametricDist H] [SphericallyCompleteSpace H] (f : E â†’â‚—áµ¢[ğ•œ] F),\n  SphericallyCompleteSpace.IsImmediate f â†’ âˆ€ (g : E â†’â‚—áµ¢[ğ•œ] H), âˆƒ h, h.comp f = g",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.IsImmediate",
   "RingHom.id",
   "DFunLike.coe",
   "Function.Surjective"],
  "name": "SphericallyCompleteSpace.MaximallyComplete",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u) â†’ [inst_1 : NormedAddCommGroup E] â†’ [NormedSpace ğ•œ E] â†’ [IsUltrametricDist E] â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Metric.closedBall", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Metric.mem_closedBall",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, y âˆˆ Metric.closedBall x Îµ â†” dist y x â‰¤ Îµ",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT", "Unit"],
  "name": "Lean.PrettyPrinter.UnexpandM",
  "constType": "Type â†’ Type",
  "constCategory": "Definition"},
 {"references": ["sup_le_sup"],
  "name": "max_le_max",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b c d : Î±}, a â‰¤ c â†’ b â‰¤ d â†’ max a b â‰¤ max c d",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, (dist x y â‰¤ â†‘c) = (nndist x y â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_2",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_20",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_9",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±} {x : Î±}, (x âˆˆ Set.range f) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "IsChain",
   "Or.elim",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed._simp_1_4",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed.match_1_1",
   "Subtype.val",
   "refl",
   "exists_prop_congr",
   "congrArg",
   "Order.Preimage",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed._simp_1_3",
   "Iff.of_eq",
   "funext",
   "id",
   "by_cases",
   "Eq.mpr",
   "propext",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed._simp_1_5"],
  "name": "IsChain.directed",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} [Refl r] {f : Î² â†’ Î±} {c : Set Î²},\n  IsChain (f â»Â¹'o r) c â†’ Directed r fun x â†¦ f â†‘x",
  "constCategory": "Theorem"},
 {"references": ["sub_eq_zero", "HSub.hSub", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_7",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Prod.fst",
   "Submodule.add_mem_sup",
   "HAdd.hAdd",
   "Subtype.prop",
   "SMulMemClass.smul_mem",
   "id"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_6",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (m : ğ•œ) (a : â†¥(ğ•œ âˆ™ x) Ã— â†¥F), m â€¢ (â†‘a.1 + â†‘a.2) âˆˆ ğ•œ âˆ™ x + F",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.rfl", "BddAbove"],
  "name": "bddAbove_def",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, BddAbove s â†” âˆƒ x, âˆ€ y âˆˆ s, y â‰¤ x",
  "constCategory": "Theorem"},
 {"references": ["SetLike.coe", "Set", "Membership.mem", "Iff.rfl"],
  "name": "SetLike.mem_coe",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x âˆˆ â†‘p â†” x âˆˆ p",
  "constCategory": "Theorem"},
 {"references": ["exists_exists_eq_and", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_14",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b) = âˆƒ a, p (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["Set.sInter", "HasSubset.Subset", "Set", "setOf"],
  "name": "closure",
  "constType": "{X : Type u} â†’ [TopologicalSpace X] â†’ Set X â†’ Set X",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "of_eq_false",
   "Eq.trans",
   "of_eq_true",
   "Eq.mpr_not",
   "dite",
   "not_false",
   "dite_congr",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_cond_eq_false",
  "constType":
  "âˆ€ {Î± : Sort u} {c : Prop} {x : Decidable c} {t : c â†’ Î±} {e : Â¬c â†’ Î±} (h : c = False), dite c t e = e â‹¯",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "Metric.infEDist",
   "congrArg",
   "EDist.edist",
   "LE.le",
   "Dist.dist",
   "dist_edist",
   "ENNReal.toReal",
   "id",
   "Metric.infDist",
   "Eq.mpr",
   "Metric.infDist.eq_1",
   "Metric.infEDist_le_edist_of_mem",
   "ENNReal.toReal_mono",
   "edist_ne_top"],
  "name": "Metric.infDist_le_dist_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x y : Î±}, y âˆˆ s â†’ Metric.infDist x s â‰¤ dist x y",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_iff_continuousAt",
   "Iff.mpr",
   "Filter.EventuallyEq.continuousAt",
   "ContinuousAt",
   "Filter.Eventually.of_forall",
   "nhds"],
  "name": "continuous_of_const",
  "constType":
  "âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X â†’ Y},\n  (âˆ€ (x y : X), f x = f y) â†’ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "_private.Init.Prelude.0.of_decide_eq_true.match_1_1",
   "decide_eq_false",
   "Decidable.decide",
   "ne_true_of_eq_false"],
  "name": "of_decide_eq_true",
  "constType": "âˆ€ {p : Prop} [inst : Decidable p], decide p = true â†’ p",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "le_refl._simp_1",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "LT.lt", "lt_iff_not_ge", "LE.le", "Iff.symm"],
  "name": "not_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, Â¬a â‰¤ b â†” b < a",
  "constCategory": "Theorem"},
 {"references": ["PseudoMetricSpace.dist_self"],
  "name": "dist_self",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] (x : Î±), dist x x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "HasSSubset.SSubset",
   "HasSubset.Subset",
   "Set",
   "And.right",
   "Set.not_subset",
   "Membership.mem",
   "Iff.mp"],
  "name": "Set.exists_of_ssubset",
  "constType": "âˆ€ {Î± : Type u} {s t : Set Î±}, s âŠ‚ t â†’ âˆƒ x âˆˆ t, x âˆ‰ s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inv.inv",
  "constType": "{Î± : Type u} â†’ [self : Inv Î±] â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Norm.norm",
   "Set",
   "lowerBounds",
   "Membership.mem",
   "LE.le",
   "And.right",
   "HMul.hMul",
   "ContinuousLinearMap.isLeast_opNorm",
   "DFunLike.coe",
   "OfNat.ofNat",
   "setOf",
   "And.left"],
  "name": "ContinuousLinearMap.le_opNorm",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F)\n  (x : E), â€–f xâ€– â‰¤ â€–fâ€– * â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "mul_one",
   "Prod.snd",
   "add_neg_cancel",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_evalâ‚‚",
   "Prod.fst",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Mathlib.Tactic.FieldSimp.zpow'_zero_of_ne_zero",
   "of_eq_true",
   "id",
   "Ne",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (n : â„¤) {e : M},\n  e â‰  0 â†’\n    âˆ€ {L l l' : Mathlib.Tactic.FieldSimp.NF M},\n      L.eval * l.eval = l'.eval â†’ ((n, e) ::áµ£ L).eval * ((-n, e) ::áµ£ l).eval = l'.eval",
  "constCategory": "Theorem"},
 {"references": ["Subtype.prop", "Set", "Membership.mem"],
  "name": "Subtype.coe_prop",
  "constType": "âˆ€ {Î± : Type u_1} {S : Set Î±} (a : { a // a âˆˆ S }), â†‘a âˆˆ S",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "rfl"],
  "name": "Submodule.add_eq_sup",
  "constType":
  "âˆ€ {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p q : Submodule R M), p + q = p âŠ” q",
  "constCategory": "Theorem"},
 {"references": ["Array.mkArray1", "Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.node1",
  "constType": "SourceInfo â†’ SyntaxNodeKind â†’ Syntax â†’ Syntax",
  "constCategory": "Definition"},
 {"references":
  ["smul_zero",
   "Submodule.ext",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0.Submodule.span_zero_singleton._simp_1_1",
   "Submodule.mem_bot._simp_1",
   "Eq.trans",
   "Set",
   "Singleton.singleton",
   "exists_const._simp_1",
   "Membership.mem",
   "Submodule.span",
   "Bot.bot",
   "OfNat.ofNat",
   "congrArg",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0.Submodule.span_zero_singleton._simp_1_2",
   "iff_self",
   "of_eq_true",
   "congr",
   "funext",
   "HSMul.hSMul"],
  "name": "Submodule.span_zero_singleton",
  "constType":
  "âˆ€ (R : Type u_1) {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M], R âˆ™ 0 = âŠ¥",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_3",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.Â«term_âŸ‚[_]_Â»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{Î± : Sort u} â†’ {Î² : Sort v} â†’ {Î´ : Sort w} â†’ (Î² â†’ Î´) â†’ (Î± â†’ Î²) â†’ Î± â†’ Î´",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' â†’ b = b' â†’ a' + b' = c â†’ a + b = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT.lt",
  "constType": "{Î± : Type u} â†’ [self : LT Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.pi", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_pi",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} {s : Set Î¹} {t : (i : Î¹) â†’ Set (Î± i)} {f : (i : Î¹) â†’ Î± i},\n  f âˆˆ s.pi t â†” âˆ€ i âˆˆ s, f i âˆˆ t i",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "neg_add_rev",
   "Eq.ndrec",
   "add_comm",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "âˆ€ {R : Type u_2} [inst : CommRing R] {aâ‚ aâ‚‚ bâ‚ bâ‚‚ : R}, -aâ‚ = bâ‚ â†’ -aâ‚‚ = bâ‚‚ â†’ -(aâ‚ + aâ‚‚) = bâ‚ + bâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "âˆ€ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "PreLp",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.câ‚€"],
  "name": "SphericallyCompleteSpace.câ‚€.eq_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_2) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)],\n  SphericallyCompleteSpace.câ‚€ ğ•œ E =\n    { carrier := {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ}, add_mem' := â‹¯, zero_mem' := â‹¯, smul_mem' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "HSMul.hSMul",
   "id",
   "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_5",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (m : ğ•œ) (a : â†¥(ğ•œ âˆ™ x) Ã— â†¥F), m â€¢ â†‘a.1 + m â€¢ â†‘a.2 âˆˆ ğ•œ âˆ™ x âŠ” F",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hU",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F]\n  [inst_7 : SphericallyCompleteSpace F] {S : â†¥D â†’L[ğ•œ] F} {ğ’° : Set (E â†’L[ğ•œ] F)} {hğ’° : ğ’°.Nonempty} {Îµ : â†‘ğ’° â†’ â„}\n  (self : SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ) (U : â†‘ğ’°)\n  (x : â†¥(SphericallyCompleteSpace.PartialExtension.Mâœ self)),\n  â€–(SphericallyCompleteSpace.PartialExtension.Tâœ self) x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "norm_eq_zero",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "RingHom.id",
   "funext",
   "forall_congr",
   "Eq.symm",
   "Subtype.coe_eta",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "AddHom.toFun",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "Eq.ndrec",
   "forall_prop_domain_congr",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_4",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Norm.norm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.IsImmediate",
   "SetLike.coe",
   "Iff.of_eq",
   "LinearIsometry.toLinearMap",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_2",
   "setOf",
   "Eq.substr",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_3",
   "LinearMap.range",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_8",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_6",
   "DFunLike.coe",
   "Subspace",
   "congrArg",
   "LinearMap.range.congr_simp",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_7",
   "Metric.infDist",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "propext",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Set",
   "Metric.infDist_zero_of_mem",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_5",
   "AddHom.mk.congr_simp",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "exists_prop_congr",
   "HAdd.hAdd",
   "of_eq_true",
   "LE.le",
   "LinearMap.mk.congr_simp"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (Eâ‚€ : Type u_3) [inst_4 : NormedAddCommGroup Eâ‚€]\n  [inst_5 : NormedSpace ğ•œ Eâ‚€] [inst_6 : IsUltrametricDist Eâ‚€] [inst_7 : SphericallyCompleteSpace Eâ‚€] (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€),\n  (SphericallyCompleteSpace.imm_ext_in_sph_comp E Eâ‚€ f).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Membership.mem.out",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "ENNReal",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LE.le",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : E),\n  (SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) x âˆˆ â‹¯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mp",
   "id",
   "eq_true",
   "Classical.not_imp._simp_1",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg"],
  "name": "Lean.Grind.eq_true_of_imp_eq_false",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) = False â†’ a = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_3",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references":
  ["mul_comm", "Eq.symm", "id", "HMul.hMul", "mul_assoc", "Eq.mpr", "congrArg"],
  "name": "CancelDenoms.mul_subst",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : CommRing Î±] {n1 n2 k e1 e2 t1 t2 : Î±},\n  n1 * e1 = t1 â†’ n2 * e2 = t2 â†’ n1 * n2 = k â†’ k * (e1 * e2) = t1 * t2",
  "constCategory": "Theorem"},
 {"references": ["IsLinearMap.map_smul", "RingHom.id", "IsLinearMap.map_add"],
  "name": "IsLinearMap.mk'",
  "constType":
  "{R : Type u_1} â†’\n  {M : Type u_8} â†’\n    {Mâ‚‚ : Type u_10} â†’\n      [inst : Semiring R] â†’\n        [inst_1 : AddCommMonoid M] â†’\n          [inst_2 : AddCommMonoid Mâ‚‚] â†’\n            [inst_3 : _root_.Module R M] â†’ [inst_4 : _root_.Module R Mâ‚‚] â†’ (f : M â†’ Mâ‚‚) â†’ IsLinearMap R f â†’ M â†’â‚—[R] Mâ‚‚",
  "constCategory": "Definition"},
 {"references": ["RingHom.id", "continuous_id", "LinearMap.id"],
  "name": "ContinuousLinearMap.id",
  "constType":
  "(Râ‚ : Type u_1) â†’\n  [inst : Semiring Râ‚] â†’\n    (Mâ‚ : Type u_4) â†’\n      [inst_1 : TopologicalSpace Mâ‚] â†’ [inst_2 : AddCommMonoid Mâ‚] â†’ [inst_3 : _root_.Module Râ‚ Mâ‚] â†’ Mâ‚ â†’L[Râ‚] Mâ‚",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd", "Function.Injective.eq_iff", "add_left_injective"],
  "name": "add_left_inj",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [IsRightCancelAdd G] (a : G) {b c : G}, b + a = c + a â†” b = c",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton.singleton",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î² : Type v} â†’ [self : Singleton Î± Î²] â†’ Î± â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_14",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Encodable.encodek", "Denumerable.ofNat_of_decode", "Encodable.encode"],
  "name": "Denumerable.ofNat_encode",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Denumerable Î±] (a : Î±), Denumerable.ofNat Î± (Encodable.encode a) = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsBoundedLinearMap.toIsLinearMap",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Semiring ğ•œ] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : _root_.Module ğ•œ E] [inst_3 : SeminormedAddCommGroup F] [inst_4 : _root_.Module ğ•œ F] {f : E â†’ F},\n  IsBoundedLinearMap ğ•œ f â†’ IsLinearMap ğ•œ f",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "norm_sub_le_norm_sub_add_norm_sub",
   "Norm.norm",
   "Eq.mp",
   "congr",
   "LE.le",
   "HSub.hSub",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_le_norm_sub_add",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), â€–aâ€– â‰¤ â€–a - bâ€– + â€–bâ€–",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype.val",
  "constType": "{Î± : Sort u} â†’ {p : Î± â†’ Prop} â†’ Subtype p â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["sub_neg_of_lt", "LE.le"],
  "name": "Mathlib.Tactic.Linarith.sub_neg_of_lt",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Ring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] {a b : Î±}, a < b â†’ a - b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Logic.Denumerable.0.nonempty_denumerable_iff.match_1_1",
   "nonempty_denumerable",
   "inferInstance",
   "_private.Mathlib.Logic.Denumerable.0.nonempty_denumerable_iff.match_1_3"],
  "name": "nonempty_denumerable_iff",
  "constType":
  "âˆ€ {Î± : Type u_3}, Nonempty (Denumerable Î±) â†” Countable Î± âˆ§ Infinite Î±",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "ConditionallyCompleteLattice.le_csSup",
   "BddAbove"],
  "name": "le_csSup",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, BddAbove s â†’ a âˆˆ s â†’ a â‰¤ sSup s",
  "constCategory": "Theorem"},
 {"references": ["ciSup_le", "OrderDual", "LE.le"],
  "name": "le_ciInf",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : ConditionallyCompleteLattice Î±] [Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±},\n  (âˆ€ (x : Î¹), c â‰¤ f x) â†’ c â‰¤ iInf f",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "not_lt._simp_1",
   "dist_eq_norm",
   "Submodule.nonempty",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "sub_zero",
   "Metric.le_infDist",
   "Subspace",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "forall_congr",
   "Dist.dist",
   "HSub.hSub",
   "Eq.symm",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "SphericallyCompleteSpace.MOrth",
   "Not",
   "Mathlib.Tactic.Contrapose.contraposeâ‚ƒ",
   "binderNameHint",
   "Norm.norm",
   "Mathlib.Tactic.Contrapose.contraposeâ‚‚",
   "Set",
   "OfNat.ofNat",
   "LT.lt",
   "ZeroMemClass.zero_mem._simp_1",
   "SetLike.coe",
   "of_eq_true",
   "SetLike.mem_coe._simp_1",
   "Iff.mpr",
   "LE.le",
   "id",
   "Mathlib.Tactic.Push.not_and_eq",
   "Eq.mpr",
   "eq_of_le_of_ge"],
  "name": "SphericallyCompleteSpace.not_morth_iff_exists_dist_lt_norm",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ğ•œ E},\n  Â¬SphericallyCompleteSpace.MOrth ğ•œ x F â†” âˆƒ y âˆˆ F, dist x y < â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "one_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.one_mul",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] (a : R), Nat.rawCast 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_6",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "StrictAnti",
   "antitone_iff_forall_lt",
   "Antitone",
   "Iff.mpr",
   "LE.le",
   "LT.lt.le"],
  "name": "StrictAnti.antitone",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PartialOrder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²}, StrictAnti f â†’ Antitone f",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_4",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.sat'.eq_1",
   "Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs.combo",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
   "Lean.Omega.Constraint.combo",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Omega.Constraint.combo_sat",
   "Lean.Omega.IntList",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.combo_sat'",
  "constType":
  "âˆ€ (s t : Omega.Constraint) (a : â„¤) (x : Omega.Coeffs) (b : â„¤) (y v : Omega.Coeffs),\n  s.sat' x v = true â†’ t.sat' y v = true â†’ (Omega.Constraint.combo a s b t).sat' (Omega.Coeffs.combo a x b y) v = true",
  "constCategory": "Theorem"},
 {"references": ["id", "HMul.hMul", "Eq.mpr", "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
  "constType":
  "âˆ€ {M : Type u_1} [inst : Mul M] {a b c D e f : M}, a = b â†’ b = c â†’ c = D * e â†’ e = f â†’ a = D * f",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.mp",
   "forall_congr",
   "Membership.mem",
   "id",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.sorth_of_sorth._simp_1_2",
   "Eq.mpr",
   "SphericallyCompleteSpace.SOrth",
   "SphericallyCompleteSpace.Orth",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth",
   "SphericallyCompleteSpace.MOrth",
   "Subspace"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.sorth_of_sorth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F1 F2 : Subspace ğ•œ E},\n  SphericallyCompleteSpace.SOrth ğ•œ F1 F2 â†’ SphericallyCompleteSpace.SOrth ğ•œ F2 F1",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references": ["NeZero.ne", "OfNat.ofNat"],
  "name": "one_ne_zero",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : Zero Î±] [inst_1 : One Î±] [NeZero 1], 1 â‰  0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroClass.mul_zero",
  "constType": "âˆ€ {Mâ‚€ : Type u} [self : MulZeroClass Mâ‚€] (a : Mâ‚€), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod.snd",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ Î± Ã— Î² â†’ Î²",
  "constCategory": "Definition"},
 {"references":
  ["neg_add_cancel",
   "HAdd.hAdd",
   "Neg.neg",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "OfNat.ofNat",
   "congrArg"],
  "name": "add_neg_cancel",
  "constType": "âˆ€ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "AddLeftMono",
   "Nat.cast",
   "eq_true",
   "OfNat.ofNat",
   "Nat.cast_add_one_pos"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] [NeZero 1]\n  (n : â„•), (0 < â†‘n + 1) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsUltrametricDist.dist_triangle_max",
  "constType":
  "âˆ€ {X : Type u_2} {inst : Dist X} [self : IsUltrametricDist X] (x y z : X), dist x z â‰¤ max (dist x y) (dist y z)",
  "constCategory": "Theorem"},
 {"references": ["Max.max"],
  "name": "Nat.max",
  "constType": "â„• â†’ â„• â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["not_congr"],
  "name": "Iff.not",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ (Â¬a â†” Â¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "LE.le",
   "AddLeftReflectLE",
   "propext",
   "add_le_add_iff_left"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_9",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Add Î±] [inst_1 : LE Î±] [AddLeftMono Î±] [AddLeftReflectLE Î±] (a : Î±) {b c : Î±},\n  (a + b â‰¤ a + c) = (b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references": ["SMulWithZero.zero_smul"],
  "name": "zero_smul",
  "constType":
  "âˆ€ (Mâ‚€ : Type u_2) {A : Type u_7} [inst : Zero Mâ‚€] [inst_1 : Zero A] [inst_2 : SMulWithZero Mâ‚€ A] (m : A), 0 â€¢ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["norm_sub_rev",
   "Norm.norm",
   "Neg.neg",
   "Eq.mp",
   "zero_sub",
   "congr",
   "HSub.hSub",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_neg",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), â€–-aâ€– = â€–aâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "PreLp",
   "HasQuotient.Quotient",
   "lp",
   "RingHom.id",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.câ‚€"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension.eq_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E],\n  SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E =\n    { toFun := fun x â†¦ (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup) âŸ¨fun x_1 â†¦ x, â‹¯âŸ©,\n      map_add' := â‹¯, map_smul' := â‹¯, norm_map' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_3",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, (x â‰¥ y) = (y â‰¤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["isClosed_le",
   "Dist.dist",
   "id",
   "continuous_const",
   "continuous_id",
   "Continuous.dist"],
  "name": "Metric.isClosed_closedBall",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, IsClosed (Metric.closedBall x Îµ)",
  "constCategory": "Theorem"},
 {"references": ["le_top", "LE.le", "Top.top", "eq_true"],
  "name": "le_top._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderTop Î±] {a : Î±}, (a â‰¤ âŠ¤) = True",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_6",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "id",
   "neg_add_cancel_left",
   "Eq.mpr",
   "add_comm",
   "congrArg"],
  "name": "add_neg_cancel_comm",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddCommGroup G] (a b : G), a + b + -a = b",
  "constCategory": "Theorem"},
 {"references": ["trivial", "propext", "And.left"],
  "name": "and_true",
  "constType": "âˆ€ (p : Prop), (p âˆ§ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "Iff.rfl",
   "OfNat.ofNat"],
  "name": "AddSubmonoid.mem_mk",
  "constType":
  "âˆ€ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubsemigroup M} {x : M} (h_zero : 0 âˆˆ s.carrier),\n  x âˆˆ { toAddSubsemigroup := s, zero_mem' := h_zero } â†” x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax.isNodeOf", "Lean.nullKind"],
  "name": "Lean.Syntax.matchesNull",
  "constType": "Syntax â†’ â„• â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "LE.le", "Iff.rfl", "OfNat.ofNat"],
  "name": "Int.add_one_le_iff",
  "constType": "âˆ€ {a b : â„¤}, a + 1 â‰¤ b â†” a < b",
  "constCategory": "Theorem"},
 {"references": ["trivial"],
  "name": "Submodule.mem_top",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  x âˆˆ âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Dist.dist"],
  "name": "Subtype.dist_eq",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] {p : Î± â†’ Prop} (x y : Subtype p), dist x y = dist â†‘x â†‘y",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat_ne_zero", "eq_false", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_9",
  "constType":
  "âˆ€ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] (n : â„•) [inst_2 : n.AtLeastTwo], (OfNat.ofNat n = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "Submodule.span",
   "Submodule.span_induction",
   "Union.union",
   "congrArg",
   "Submodule.span_eq",
   "le_sup_right",
   "congr",
   "Eq.symm",
   "Eq.ndrec",
   "add_comm",
   "Set",
   "Submodule.smul_mem",
   "le_sup_left",
   "add_zero",
   "OfNat.ofNat",
   "Or.casesOn",
   "HAdd.hAdd",
   "Exists.casesOn",
   "eq_self",
   "ZeroMemClass.zero_mem._simp_1",
   "Max.max",
   "zero_add",
   "and_self",
   "SetLike.coe",
   "of_eq_true",
   "add_assoc",
   "HSMul.hSMul",
   "id",
   "smul_add",
   "Submodule.span_union",
   "AddMemClass.add_mem",
   "Eq.mpr",
   "And.casesOn"],
  "name": "Submodule.mem_sup",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M}\n  {p p' : Submodule R M}, x âˆˆ p âŠ” p' â†” âˆƒ y âˆˆ p, âˆƒ z âˆˆ p', y + z = x",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "iSup",
   "isLUB_ciSup",
   "upperBounds",
   "Set",
   "isLUB_le_iff",
   "Membership.mem",
   "LE.le",
   "Set.forall_mem_range",
   "Set.range",
   "BddAbove"],
  "name": "ciSup_le_iff",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : ConditionallyCompleteLattice Î±] [Nonempty Î¹] {f : Î¹ â†’ Î±} {a : Î±},\n  BddAbove (Set.range f) â†’ (iSup f â‰¤ a â†” âˆ€ (i : Î¹), f i â‰¤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max",
   "le_sup_right",
   "le_trans",
   "LE.le",
   "sup_le",
   "_private.Mathlib.Order.Lattice.0.sup_le_iff.match_1_1",
   "le_sup_left"],
  "name": "sup_le_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, a âŠ” b â‰¤ c â†” a â‰¤ c âˆ§ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["exists_eq", "eq_true"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_9",
  "constType": "âˆ€ {Î± : Sort u_1} {a' : Î±}, (âˆƒ a, a = a') = True",
  "constCategory": "Theorem"},
 {"references": ["le_of_not_ge", "Not", "LE.le", "lt_of_le_not_ge"],
  "name": "lt_of_not_ge",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, Â¬b â‰¤ a â†’ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "ENNReal", "PreLp", "Norm.norm", "lp", "Membership.mem", "Top.top"],
  "name": "lp.norm_eq_ciSup",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] (f : â†¥(lp E âŠ¤)), â€–fâ€– = â¨† i, â€–â†‘f iâ€–",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.Data.Prod.0.Prod.forall.match_1_1"],
  "name": "Prod.forall",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± Ã— Î² â†’ Prop}, (âˆ€ (x : Î± Ã— Î²), p x) â†” âˆ€ (a : Î±) (b : Î²), p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["AlgebraicClosure", "Padic", "Nat.Prime"],
  "name": "PadicAlgCl",
  "constType": "(p : â„•) â†’ [hp : Fact (Nat.Prime p)] â†’ Type",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.ext_iff",
   "Membership.mem",
   "Subtype.val",
   "Iff.symm",
   "OfNat.ofNat"],
  "name": "ZeroMemClass.coe_eq_zero",
  "constType":
  "âˆ€ {A : Type u_3} {Mâ‚ : Type u_4} [inst : SetLike A Mâ‚] [inst_1 : Zero Mâ‚] [hA : ZeroMemClass A Mâ‚] {S' : A} {x : â†¥S'},\n  â†‘x = 0 â†” x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_7",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_zero",
   "Eq.mp",
   "HSMul.hSMul",
   "Eq.symm",
   "HSub.hSub",
   "Ne",
   "sub_smul",
   "smul_eq_zero_iff_left",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "smul_left_injective",
  "constType":
  "âˆ€ (R : Type u_1) {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {m : M}\n  [IsDomain R] [Module.IsTorsionFree R M], m â‰  0 â†’ Function.Injective fun x â†¦ x â€¢ m",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "LT.lt.not_ge",
   "Set",
   "Membership.mem",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem"],
  "name": "Metric.notMem_of_dist_lt_infDist",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x y : Î±}, dist x y < Metric.infDist x s â†’ y âˆ‰ s",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references": ["NNReal", "OfNat.ofNat", "ENNReal.top_ne_coe"],
  "name": "ENNReal.top_ne_zero",
  "constType": "âŠ¤ â‰  0",
  "constCategory": "Theorem"},
 {"references": ["LinearMap.toAddHom", "AddHom.toFun", "Eq.ndrec"],
  "name": "ContinuousLinearMap.mk.congr_simp",
  "constType":
  "âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {Ïƒ : R â†’+* S} {M : Type u_3}\n  [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M] {Mâ‚‚ : Type u_4} [inst_4 : TopologicalSpace Mâ‚‚]\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : _root_.Module R M] [inst_7 : _root_.Module S Mâ‚‚]\n  (toLinearMap toLinearMap_1 : M â†’â‚›â‚—[Ïƒ] Mâ‚‚) (e_toLinearMap : toLinearMap = toLinearMap_1)\n  (cont : Continuous toLinearMap.toFun),\n  { toLinearMap := toLinearMap, cont := cont } = { toLinearMap := toLinearMap_1, cont := â‹¯ }",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_4",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.atTop",
   "Filter.tendsto_atTop_mono",
   "id",
   "Filter.tendsto_id",
   "StrictMono.id_le",
   "StrictMono"],
  "name": "StrictMono.tendsto_atTop",
  "constType":
  "âˆ€ {Ï† : â„• â†’ â„•}, StrictMono Ï† â†’ Filter.Tendsto Ï† Filter.atTop Filter.atTop",
  "constCategory": "Theorem"},
 {"references": ["Set", "Metric.infEDist", "ENNReal.toReal_nonneg"],
  "name": "Metric.infDist_nonneg",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, 0 â‰¤ Metric.infDist x s",
  "constCategory": "Theorem"},
 {"references": ["NNReal", "WithTop"],
  "name": "ENNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "_private.Mathlib.Topology.MetricSpace.HausdorffDistance.0.Metric.infDist_lt_iff._simp_1_1",
   "Set.Nonempty",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "Classical.not_forall._simp_1",
   "Metric.le_infDist",
   "congrArg",
   "LT.lt",
   "iff_self",
   "of_eq_true",
   "congr",
   "funext",
   "Dist.dist",
   "LE.le",
   "Metric.infDist",
   "Classical.not_imp._simp_1",
   "propext"],
  "name": "Metric.infDist_lt_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„},\n  s.Nonempty â†’ (Metric.infDist x s < r â†” âˆƒ y âˆˆ s, dist x y < r)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Inter.inter", "Membership.mem", "And.left"],
  "name": "Set.mem_of_mem_inter_left",
  "constType": "âˆ€ {Î± : Type u} {x : Î±} {a b : Set Î±}, x âˆˆ a âˆ© b â†’ x âˆˆ a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "OrderDual", "LE.le", "monotone_nat_of_le_succ", "OfNat.ofNat"],
  "name": "antitone_nat_of_succ_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Preorder Î±] {f : â„• â†’ Î±}, (âˆ€ (n : â„•), f (n + 1) â‰¤ f n) â†’ Antitone f",
  "constCategory": "Theorem"},
 {"references":
  ["OrderBot.bot_le", "Set", "lowerBounds", "Membership.mem", "Bot.bot"],
  "name": "OrderBot.bddBelow",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [OrderBot Î±] (s : Set Î±), BddBelow s",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball._proof_1",
   "GT.gt",
   "Subtype.val",
   "Set.Elem",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball",
   "funext",
   "Eq.symm",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_strictanti",
   "Eq.ndrec",
   "And.left",
   "Nat.casesAuxOn",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball_decreasing._simp_1_4",
   "Exists.choose_spec",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
   "NNReal",
   "Prod.snd",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
   "Unit",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "zero_add",
   "HasSubset.Subset",
   "NNDist.nndist",
   "id",
   "Eq.mpr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball.match_1",
   "Exists.choose.congr_simp",
   "Eq.mp",
   "NNReal.toReal",
   "Set.Countable",
   "Dense",
   "Prod.fst",
   "congrArg",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball._proof_3",
   "congr",
   "Dist.dist",
   "Denumerable.ofNat",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius.congr_simp",
   "Not",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "lt_add_one",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_sub_closedball_not_belong",
   "LE.le",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball.eq_def",
   "antitone_nat_of_succ_le",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "TopologicalSpace.SeparableSpace.exists_countable_dense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball_decreasing",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [hiud : IsUltrametricDist Î±]\n  [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] [nemp : Nonempty Î±] [hsep : TopologicalSpace.SeparableSpace Î±]\n  (hÎ±' : Denumerable â†‘â‹¯.choose),\n  Antitone fun n â†¦\n    Metric.closedBall (SphericallyCompleteSpace.funk_chain_of_ballâœ hÎ±' n).1\n      â†‘(SphericallyCompleteSpace.funk_chain_of_ballâœÂ¹ hÎ±' n).2",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMul.hMul",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HMul Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv.hDiv",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HDiv Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.câ‚€._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_2) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] (i : â„•), IsBoundedSMul ğ•œ (E i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Set.Finite", "Set.Elem", "propext", "Set.finite_coe_iff"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_13",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, Finite â†‘s = s.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.fromRef", "Bind.bind", "Lean.MonadRef.getRef", "Pure.pure"],
  "name": "Lean.MonadRef.mkInfoFromRefPos",
  "constType": "{m : Type â†’ Type} â†’ [Monad m] â†’ [MonadRef m] â†’ m SourceInfo",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_2",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LT Î±] {x y : Î±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": ["NegZeroClass.neg_zero"],
  "name": "neg_zero",
  "constType": "âˆ€ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references": ["zero_lt_one"],
  "name": "Mathlib.Tactic.Linarith.zero_lt_one",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsStrictOrderedRing Î±], 0 < 1",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma.add_comm"],
  "name": "add_comm",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "AddMonoidHom.mk'",
   "QuotientAddGroup.mk",
   "QuotientAddGroup.mk'._proof_1"],
  "name": "QuotientAddGroup.mk'",
  "constType":
  "{G : Type u_1} â†’ [inst : AddGroup G] â†’ (N : AddSubgroup G) â†’ [nN : N.Normal] â†’ G â†’+ G â§¸ N",
  "constCategory": "Definition"},
 {"references": ["LE.le", "bot_le", "eq_true", "Bot.bot"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_minimal._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderBot Î±] {a : Î±}, (âŠ¥ â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["nndist_eq_zero", "NNDist.nndist", "NNReal", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_21",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : MetricSpace Î³] {x y : Î³}, (nndist x y = 0) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "le_sup_iff", "LE.le", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_10",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b c : Î±}, (a â‰¤ max b c) = (a â‰¤ b âˆ¨ a â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "LinearMap.range",
   "Membership.mem",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "SphericallyCompleteSpace.IsImmediate",
   "LinearIsometry.toLinearMap",
   "RingHom.id",
   "LE.le",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "setOf"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u_2) â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [IsUltrametricDist E] â†’\n            (Eâ‚€ : Type u_3) â†’\n              [inst_4 : NormedAddCommGroup Eâ‚€] â†’\n                [inst_5 : NormedSpace ğ•œ Eâ‚€] â†’\n                  [IsUltrametricDist Eâ‚€] â†’ [SphericallyCompleteSpace Eâ‚€] â†’ (E â†’â‚—áµ¢[ğ•œ] Eâ‚€) â†’ Set (Submodule ğ•œ Eâ‚€)",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_9",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "PreLp",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.câ‚€"],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_3",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [IsUltrametricDist E],\n  IsUltrametricDist (â†¥(lp (fun x â†¦ E) âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E)",
  "constCategory": "Theorem"},
 {"references":
  ["Monotone.map_max",
   "LE.le",
   "monotone_mul_right_of_nonneg",
   "HMul.hMul",
   "OfNat.ofNat"],
  "name": "max_mul_of_nonneg",
  "constType":
  "âˆ€ {R : Type u} [inst : Semiring R] [inst_1 : LinearOrder R] {c : R} [MulPosMono R] (a b : R),\n  0 â‰¤ c â†’ max a b * c = max (a * c) (b * c)",
  "constCategory": "Theorem"},
 {"references": ["Submodule.neg_mem", "Submodule.toAddSubmonoid"],
  "name": "Submodule.toAddSubgroup",
  "constType":
  "{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Ring R] â†’ [inst_1 : AddCommGroup M] â†’ {module_M : _root_.Module R M} â†’ Submodule R M â†’ AddSubgroup M",
  "constCategory": "Definition"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "Maximal",
   "Set",
   "RingHom.id",
   "Membership.mem",
   "inferInstance",
   "Exists.choose"],
  "name": "SphericallyCompleteSpace.instIsUltrametricDistSphericalCompletion",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (Eâ‚€ : Type u_3) [inst_4 : NormedAddCommGroup Eâ‚€]\n  [inst_5 : NormedSpace ğ•œ Eâ‚€] [inst_6 : IsUltrametricDist Eâ‚€] [inst_7 : SphericallyCompleteSpace Eâ‚€] (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€),\n  IsUltrametricDist â†¥â‹¯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "mul_neg",
   "congr",
   "HSub.hSub",
   "left_distrib",
   "HMul.hMul",
   "congrArg"],
  "name": "CancelDenoms.sub_subst",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {n e1 e2 t1 t2 : Î±}, n * e1 = t1 â†’ n * e2 = t2 â†’ n * (e1 - e2) = t1 - t2",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.image",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Set Î± â†’ Set Î²",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "âˆ€ {a b : Prop}, (a â†’ b) â†’ Â¬b â†’ Â¬a",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Exists.choose",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "Maximal",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletion",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u) â†’ [inst_1 : NormedAddCommGroup E] â†’ [NormedSpace ğ•œ E] â†’ [IsUltrametricDist E] â†’ Type u",
  "constCategory": "Definition"},
 {"references": ["Set", "LE.le", "Membership.mem", "setOf"],
  "name": "upperBounds",
  "constType": "{Î± : Type u_1} â†’ [LE Î±] â†’ Set Î± â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["Subtype.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_12",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆƒ x, q x) = âˆƒ a, âˆƒ (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Not", "Nat.lt_or_ge", "LE.le", "Or.resolve_right", "GE.ge"],
  "name": "Nat.lt_of_not_le",
  "constType": "âˆ€ {a b : â„•}, Â¬a â‰¤ b â†’ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "inv_nonneg",
   "PosMulReflectLT.toPosMulStrictMono",
   "mul_nonneg",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "HDiv.hDiv",
   "Iff.mpr",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "div_nonneg",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a b : Gâ‚€},\n  0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 â‰¤ a / b",
  "constCategory": "Theorem"},
 {"references": ["Subtype.property", "Membership.mem"],
  "name": "SetLike.coe_mem",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : â†¥p), â†‘x âˆˆ p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.eq_false_of_imp_eq_false",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "NNReal.toReal",
   "eq_true",
   "DFunLike.coe",
   "Lean.Grind.of_forall_eq_false",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "Not",
   "Set.preimage",
   "Set",
   "NNReal",
   "Set.subset_def",
   "Exists.casesOn",
   "Metric.closedBall",
   "HasSubset.Subset",
   "of_eq_true",
   "Lean.Grind.iff_eq",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.eq_true_of_imp_eq_false",
   "Set.mem_preimage"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._proof_1_1",
  "constType":
  "âˆ€ {E : Type u_1} {F : Type u_2} [inst : PseudoMetricSpace E] [inst_1 : PseudoMetricSpace F] (f : E â‰ƒáµ¢ F) â¦ƒci : â„• â†’ Fâ¦„\n  â¦ƒri : â„• â†’ NNRealâ¦„ â¦ƒm n : â„•â¦„,\n  Metric.closedBall (ci n) â†‘(ri n) âŠ† Metric.closedBall (ci m) â†‘(ri m) â†’\n    â‡‘f â»Â¹' Metric.closedBall (ci n) â†‘(ri n) âŠ† â‡‘f â»Â¹' Metric.closedBall (ci m) â†‘(ri m)",
  "constCategory": "Theorem"},
 {"references": ["Codisjoint.eq_top", "IsCompl.codisjoint"],
  "name": "IsCompl.sup_eq_top",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : BoundedOrder Î±] {x y : Î±}, IsCompl x y â†’ x âŠ” y = âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.substr",
  "constType": "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {a b : Î±}, b = a â†’ p a â†’ p b",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "Eq.symm",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (dist y x â‰¤ Îµ) = (y âˆˆ Metric.closedBall x Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "HDiv.hDiv",
   "eq_self",
   "Inv.inv",
   "Eq.trans",
   "of_eq_true",
   "inv_one",
   "HMul.hMul",
   "mul_one",
   "OfNat.ofNat",
   "congrArg"],
  "name": "div_one",
  "constType": "âˆ€ {G : Type u_3} [inst : DivInvOneMonoid G] (a : G), a / 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Membership.mem",
   "Metric.infEDist",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "EDist.edist",
   "dist_edist",
   "funext",
   "Dist.dist",
   "ENNReal.toReal",
   "id",
   "Metric.infDist",
   "iInf",
   "Eq.mpr",
   "Metric.infDist.eq_1",
   "Metric.infEDist.eq_1",
   "iInf_subtype'",
   "edist_ne_top",
   "ENNReal.toReal_iInf"],
  "name": "Metric.infDist_eq_iInf",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, Metric.infDist x s = â¨… y, dist x â†‘y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "FiniteDimensional",
  "constType":
  "(K : Type u_1) â†’ (V : Type u_2) â†’ [inst : DivisionRing K] â†’ [inst_1 : AddCommGroup V] â†’ [_root_.Module K V] â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "mul_neg",
   "HMul.hMul",
   "HPow.hPow",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "âˆ€ {R : Type u_2} [inst : CommRing R] (aâ‚ : R) (aâ‚‚ : â„•) {aâ‚ƒ b : R}, -aâ‚ƒ = b â†’ -(aâ‚ ^ aâ‚‚ * aâ‚ƒ) = aâ‚ ^ aâ‚‚ * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Encodable.encode",
  "constType": "{Î± : Type u_1} â†’ [self : Encodable Î±] â†’ Î± â†’ â„•",
  "constCategory": "Definition"},
 {"references": ["rfl"],
  "name": "congrArg",
  "constType":
  "âˆ€ {Î± : Sort u} {Î² : Sort v} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), aâ‚ = aâ‚‚ â†’ f aâ‚ = f aâ‚‚",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "binderNameHint", "Mathlib.Tactic.Push.not_exists", "propext"],
  "name": "Mathlib.Tactic.Push.not_exists._simp_1",
  "constType":
  "âˆ€ {Î± : Sort u_1} (s : Î± â†’ Prop), (Â¬Exists s) = âˆ€ (x : Î±), binderNameHint x s Â¬s x",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Iff.rfl", "setOf"],
  "name": "Set.mem_setOf",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {p : Î± â†’ Prop}, a âˆˆ {x | p x} â†” p a",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_2",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Classical.propDecidable",
   "Iff.mp",
   "HMul.hMul",
   "GT.gt",
   "GE.ge",
   "Subtype.val",
   "HDiv.hDiv",
   "SphericallyCompleteSpace.câ‚€._simp_2",
   "not_false_eq_true",
   "forall_congr",
   "funext",
   "norm_zero",
   "le_mul_inv_iffâ‚€'",
   "Norm.norm",
   "SphericallyCompleteSpace.câ‚€._simp_3",
   "SphericallyCompleteSpace.câ‚€._simp_4",
   "Exists.casesOn",
   "norm_pos_iff",
   "SphericallyCompleteSpace.câ‚€._simp_6",
   "eq_false",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Top.top",
   "zero_smul",
   "Eq.mpr",
   "setOf",
   "lp",
   "Eq.mp",
   "congrArg",
   "congr",
   "Not",
   "PreLp",
   "Inv.inv",
   "SphericallyCompleteSpace.câ‚€._simp_5",
   "Set",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.câ‚€._simp_1",
   "LT.lt",
   "norm_smul",
   "ENNReal",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Ne",
   "dite"],
  "name": "SphericallyCompleteSpace.câ‚€._proof_4",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_1) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] (c : ğ•œ) {x : â†¥(lp E âŠ¤)},\n  x âˆˆ {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ} â†’ c â€¢ x âˆˆ {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ}",
  "constCategory": "Theorem"},
 {"references": ["Subtype.property"],
  "name": "Subtype.prop",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (x : Subtype p), p â†‘x",
  "constCategory": "Theorem"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring â„•",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Topology.MetricSpace.Defs.0.nndist_eq_zero._simp_1_1",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "NNDist.nndist",
   "NNReal",
   "NNReal.toReal",
   "OfNat.ofNat",
   "dist_eq_zero._simp_1",
   "congrArg"],
  "name": "nndist_eq_zero",
  "constType":
  "âˆ€ {Î³ : Type w} [inst : MetricSpace Î³] {x y : Î³}, nndist x y = 0 â†” x = y",
  "constCategory": "Theorem"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "HSMul.hSMul",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) (M : Submodule ğ•œ Eâ‚€), f.range â‰¤ M â†’ âˆ€ (x : ğ•œ) (x_1 : â†¥f.range), â†‘(x â€¢ x_1) âˆˆ M",
  "constCategory": "Theorem"},
 {"references":
  ["IsLinearMap.mk'",
   "Eq.trans",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Mathlib.Tactic.Contrapose.contraposeâ‚„",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "LinearMap.toAddHom",
   "HMul.hMul",
   "eq_true",
   "IsBoundedLinearMap.toIsLinearMap",
   "Submodule.span",
   "heq_of_eq",
   "Submodule.mem_sup_left",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
   "RingHom.id",
   "eq_of_heq",
   "Submodule.mem_span_singleton",
   "forall_congr",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "AddHom.toFun",
   "Eq.ndrec",
   "And.left",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Exists.choose_spec",
   "Norm.norm",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "And.right",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop",
   "add_zero",
   "IsBoundedLinearMap.toContinuousLinearMap._proof_1",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "map_add",
   "HSMul.hSMul",
   "id",
   "zero_smul",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_1",
   "Eq.mp",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_boundedlinear",
   "DFunLike.coe",
   "Submodule.zero_mem",
   "congrArg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_2",
   "Subtype.prop",
   "Submodule.mem_sup",
   "congr",
   "eq_and_eq_of_add_eq_add_of_not_mem_submodule_span_singleton",
   "IsLinearMap.map_add",
   "propext",
   "Not",
   "Set.Nonempty",
   "Set",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Submodule.add_eq_sup",
   "ContinuousLinearMap.mk.congr_simp",
   "Exists.choose",
   "AddHom.mk.congr_simp",
   "OfNat.ofNat",
   "IsBoundedLinearMap.toLinearMap",
   "HAdd.hAdd",
   "LT.lt",
   "Max.max",
   "and_self",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
   "IsLinearMap.map_smul",
   "of_eq_true",
   "LE.le",
   "LinearMap.mk.congr_simp",
   "smul_eq_zero_iff_left"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (D : Submodule ğ•œ E),\n  âˆ€ a âˆ‰ D,\n    âˆ€ (F : Type u_3) [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ğ•œ F]\n      [hsc : SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) (ğ’° : Set (E â†’L[ğ•œ] F)),\n      ğ’°.Nonempty â†’\n        âˆ€ (Îµ : â†‘ğ’° â†’ â„),\n          (âˆ€ (T : â†‘ğ’°), 0 < Îµ T) â†’\n            (âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V)) â†’\n              (âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–) â†’\n                âˆƒ T,\n                  (âˆ€ (x : â†¥D), T âŸ¨â†‘x, â‹¯âŸ© = S x) âˆ§\n                    âˆ€ (U : â†‘ğ’°) (x : E) (hx : x âˆˆ D + ğ•œ âˆ™ a), â€–T âŸ¨x, hxâŸ© - â†‘U xâ€– â‰¤ Îµ U * â€–xâ€–",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ProperSpace.isCompact_closedBall",
  "constType":
  "âˆ€ {Î± : Type u} {inst : PseudoMetricSpace Î±} [self : ProperSpace Î±] (x : Î±) (r : â„), IsCompact (Metric.closedBall x r)",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "âˆ€ {Î± : Sort u_2} {a b c : Î±}, a = c â†’ b = c â†’ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Set.not_nonempty_iff_eq_empty",
   "Set.Nonempty",
   "Set",
   "EmptyCollection.emptyCollection",
   "propext"],
  "name": "Set.not_nonempty_iff_eq_empty._simp_1",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, (Â¬s.Nonempty) = (s = âˆ…)",
  "constCategory": "Theorem"},
 {"references": ["not_le_of_gt"],
  "name": "LT.lt.not_ge",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, a < b â†’ Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "DFunLike.coe"],
  "name": "LinearMap.mem_range_self",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] (f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) (x : M), f x âˆˆ f.range",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "mul_pos_iff_of_pos_right",
   "Inv.inv",
   "Eq.trans",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "iff_self",
   "of_eq_true",
   "Iff.mpr",
   "PosMulReflectLT.toMulPosReflectLT",
   "inv_pos",
   "propext"],
  "name": "div_pos_iff_of_pos_right",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : Semifield Î±] [inst_1 : PartialOrder Î±] [PosMulReflectLT Î±] {a b : Î±} [IsStrictOrderedRing Î±],\n  0 < b â†’ (0 < a / b â†” 0 < a)",
  "constCategory": "Theorem"},
 {"references": ["HDiv.hDiv", "id", "Eq.mpr", "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.eq_div_of_subst",
  "constType":
  "âˆ€ {M : Type u_1} [inst : Div M] {l l_n l_d n d : M}, l = l_n / l_d â†’ l_n = n â†’ l_d = d â†’ l = n / d",
  "constCategory": "Theorem"},
 {"references":
  ["mul_div_left_comm",
   "HDiv.hDiv",
   "mul_comm",
   "Eq.symm",
   "id",
   "HMul.hMul",
   "mul_assoc",
   "Eq.mpr",
   "one_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "CancelDenoms.div_subst",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Field Î±] {n1 n2 k e1 e2 t1 : Î±}, n1 * e1 = t1 â†’ n2 / e2 = 1 â†’ n1 * n2 = k â†’ k * (e1 / e2) = t1",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_5",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (âˆƒ x, p x) â†’ Prop}, (âˆ€ (h : âˆƒ x, p x), q h) = âˆ€ (x : Î±) (h : p x), q â‹¯",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset", "Set", "Set.setOf_subset_setOf", "propext", "setOf"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} {p q : Î± â†’ Prop}, ({a | p a} âŠ† {a | q a}) = âˆ€ (a : Î±), p a â†’ q a",
  "constCategory": "Theorem"},
 {"references":
  ["IsLinearMap.mk'",
   "le_refl",
   "Norm.norm",
   "mul_le_mul_of_nonneg_left",
   "HMul.hMul",
   "LinearMap.comp",
   "IsBoundedLinearMap.toIsLinearMap",
   "mul_assoc",
   "_private.Mathlib.Analysis.Normed.Operator.BoundedLinearMaps.0.IsBoundedLinearMap.comp.match_1_1",
   "Function.comp",
   "DFunLike.coe",
   "OfNat.ofNat",
   "congrArg",
   "LinearMap.isLinear",
   "LT.lt",
   "le_of_lt",
   "RingHom.id",
   "LE.le",
   "le_imp_le_of_le_of_le",
   "Eq.mpr",
   "IsLinearMap.with_bound"],
  "name": "IsBoundedLinearMap.comp",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [inst : Semiring ğ•œ] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : _root_.Module ğ•œ E] [inst_3 : SeminormedAddCommGroup F] [inst_4 : _root_.Module ğ•œ F]\n  [inst_5 : SeminormedAddCommGroup G] [inst_6 : _root_.Module ğ•œ G] {f : E â†’ F} {g : F â†’ G},\n  IsBoundedLinearMap ğ•œ g â†’ IsBoundedLinearMap ğ•œ f â†’ IsBoundedLinearMap ğ•œ (g âˆ˜ f)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Set",
   "_private.Mathlib.Order.SetNotation.0.Set.mem_iUnion.match_1_1",
   "Membership.mem",
   "Eq.symm",
   "_private.Mathlib.Order.SetNotation.0.Set.mem_iUnion.match_1_3",
   "Set.iUnion",
   "Set.range"],
  "name": "Set.mem_iUnion",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, x âˆˆ â‹ƒ i, s i â†” âˆƒ i, x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Subtype.val",
   "Subspace"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_9",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (z : â†¥(ğ•œ âˆ™ x âŠ” F)), âˆƒ y âˆˆ ğ•œ âˆ™ x, âˆƒ z_1 âˆˆ F, y + z_1 = â†‘z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE.le",
  "constType": "{Î± : Type u} â†’ [self : LE Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["isometry_iff_dist_eq", "Dist.dist", "Iff.mp", "Isometry"],
  "name": "Isometry.dist_eq",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ âˆ€ (x y : Î±), dist (f x) (f y) = dist x y",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Memâ„“p",
   "zero_memâ„“p",
   "forall_congr",
   "funext",
   "Set.range_const",
   "PreLp",
   "Memâ„“p.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Memâ„“p.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "Iff.mpr",
   "LE.le",
   "id",
   "Top.top",
   "Eq.mpr",
   "memâ„“p_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_3",
  "constType":
  "âˆ€ (E : Type u_1) [inst : NormedAddCommGroup E] (x : E), (fun x_1 â†¦ x) âˆˆ lp (fun x â†¦ E) âŠ¤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Array.getD",
   "_private.Init.Prelude.0.Lean.Syntax.setKind.match_1"],
  "name": "Lean.Syntax.getArg",
  "constType": "Syntax â†’ â„• â†’ Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_5",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x âˆˆ p), (âŸ¨x, hâŸ© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "Set.mem_singleton_iff._simp_1",
  "constType": "âˆ€ {Î± : Type u} {a b : Î±}, (a âˆˆ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "Eq.trans",
   "zero_sub",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "RingHom.id",
   "Eq.symm",
   "HSub.hSub",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_4",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "LinearMap.ker",
   "Exists.choose_spec",
   "Norm.norm",
   "Neg.neg",
   "And.right",
   "Mathlib.Tactic.Abel.term_add_constg",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "zero_add",
   "sup_of_le_left",
   "SetLike.coe",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Int.negOfNat",
   "id",
   "norm_neg",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_3",
   "Eq.mpr",
   "SphericallyCompleteSpace.SOrth",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "one_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "dist_eq_norm",
   "IsUltrametricDist.norm_add_le_max",
   "Submodule.nonempty",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "le_trans",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_neg",
   "DFunLike.coe",
   "Subspace",
   "Metric.le_infDist",
   "map_sub",
   "congrArg",
   "dist_zero",
   "ZeroMemClass.zero_mem",
   "congr",
   "Dist.dist",
   "Metric.infDist",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_1",
   "Metric.infDist_le_dist_of_mem",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_2",
   "ContinuousLinearMap.toLinearMap",
   "dist_comm",
   "Set",
   "SphericallyCompleteSpace.sorth_symm",
   "zero_le_one",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Exists.choose",
   "Mathlib.Tactic.Abel.term_neg",
   "Submodule.mem_toAddSubgroup",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_iff",
   "eq_of_le_of_ge"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [inst_3 : SphericallyCompleteSpace â†¥F],\n  SphericallyCompleteSpace.SOrth ğ•œ F (SphericallyCompleteSpace.OrthComp ğ•œ F)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Eq.trans",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Metric.isBounded_closedBall",
   "Metric.diam",
   "eq_true",
   "HMul.hMul",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "Metric.diam_nonneg",
   "DenselyNormedField.lt_norm_lt",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Ring.sub_pf",
   "Norm.norm",
   "NNReal",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
   "Exists.casesOn",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast_zero",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "diam_le_radius_of_ultrametric",
   "Eq.mp",
   "NNReal.toReal",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_3",
   "Metric.dist_le_diam_of_mem",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "dist_self_add_left",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "dist_self",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "le_of_lt",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "eq_of_le_of_ge",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField",
  "constType":
  "âˆ€ (Î± : Type u_1) [dnf : DenselyNormedField Î±] [hiud : IsUltrametricDist Î±],\n  SphericallyCompleteSpace.IsSphericallyDense Î±",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name": "not_lt._simp_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, (Â¬a < b) = (b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Submodule.toAddSubmonoid",
  "constType":
  "{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : Semiring R] â†’ [inst_1 : AddCommMonoid M] â†’ [inst_2 : _root_.Module R M] â†’ Submodule R M â†’ AddSubmonoid M",
  "constCategory": "Definition"},
 {"references": ["trivial", "propext"],
  "name": "eq_true",
  "constType": "âˆ€ {p : Prop}, p â†’ p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "csInf_le_csInf",
   "HasSubset.Subset",
   "Set",
   "OrderBot.bddBelow"],
  "name": "csInf_le_csInf'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Î±] {s t : Set Î±}, t.Nonempty â†’ t âŠ† s â†’ sInf s â‰¤ sInf t",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "eq_true", "le_sup_left"],
  "name": "le_sup_left._simp_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (a â‰¤ a âŠ” b) = True",
  "constCategory": "Theorem"},
 {"references": ["Set", "Inter.inter", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_inter_iff",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), x âˆˆ a âˆ© b â†” x âˆˆ a âˆ§ x âˆˆ b",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop._simp_1_1",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "neg_zero",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "sub_zero",
  "constType":
  "âˆ€ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.nonempty_closedBall",
   "Metric.closedBall",
   "Set.Nonempty",
   "LE.le",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_8",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, (Metric.closedBall x Îµ).Nonempty = (0 â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±} {x : Î±}, (x âˆˆ Set.range f) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["Dist.dist", "LE.le", "NNReal", "NNReal.toReal", "Iff.rfl"],
  "name": "dist_le_coe",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {c : NNReal}, dist x y â‰¤ â†‘c â†” nndist x y â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "zero_add", "LE.le.trans_eq", "le_self_add", "OfNat.ofNat"],
  "name": "zero_le",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddZeroClass Î±] [inst_1 : LE Î±] [CanonicallyOrderedAdd Î±] (a : Î±), 0 â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Subtype.ext", "Subtype.val"],
  "name": "Subtype.coe_eta",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (a : { a // p a }) (h : p â†‘a), âŸ¨â†‘a, hâŸ© = a",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_4",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), (a â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty", "Set", "Iff.mpr", "Set.nonempty_coe_sort", "Set.Elem"],
  "name": "Set.Nonempty.coe_sort",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s.Nonempty â†’ Nonempty â†‘s",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "Norm.norm",
   "Dist.dist",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dist_zero_right",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_zero",
  "constType": "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E], â€–0â€– = 0",
  "constCategory": "Theorem"},
 {"references":
  ["true_or",
   "Eq.trans",
   "Norm.norm",
   "Eq.mp",
   "Neg.neg",
   "norm_eq_of_norm_sub_lt_left._simp_1_1",
   "eq_true",
   "congrArg",
   "sub_eq_add_neg",
   "LT.lt",
   "HAdd.hAdd",
   "Max.max",
   "of_eq_true",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "norm_neg",
   "Eq.mpr",
   "IsUltrametricDist.norm_eq_of_add_norm_lt_max"],
  "name": "norm_eq_of_norm_sub_lt_left",
  "constType":
  "âˆ€ {S : Type u_1} [inst : SeminormedAddGroup S] [IsUltrametricDist S] {x y : S}, â€–x - yâ€– < â€–xâ€– â†’ â€–xâ€– = â€–yâ€–",
  "constCategory": "Theorem"},
 {"references": ["Function.Injective.eq_iff", "Neg.neg", "neg_injective"],
  "name": "neg_inj",
  "constType":
  "âˆ€ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = -b â†” a = b",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "Neg.neg",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.zpow'_neg",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "mul_inv",
   "Prod.fst",
   "congrArg",
   "HDiv.hDiv",
   "congr",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div'",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (n : â„¤) (e : M) {t t_n t_d : Mathlib.Tactic.FieldSimp.NF M},\n  t.eval = t_n.eval / t_d.eval â†’ ((-n, e) ::áµ£ t).eval = t_n.eval / ((n, e) ::áµ£ t_d).eval",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Iff.mpr", "LE.le", "sup_eq_right"],
  "name": "sup_of_le_right",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a â‰¤ b â†’ a âŠ” b = b",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.toReal_smul",
   "Norm.norm",
   "Set",
   "infEDist_smulâ‚€",
   "NNReal",
   "NNReal.toReal",
   "Metric.infEDist",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "NNNorm.nnnorm",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "HSMul.hSMul",
   "id",
   "Set.smulSet",
   "ENNReal.toReal",
   "Metric.infDist",
   "Ne",
   "Eq.mpr"],
  "name": "infDist_smulâ‚€",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : NormedDivisionRing ğ•œ] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : _root_.Module ğ•œ E] [NormSMulClass ğ•œ E] {c : ğ•œ},\n  c â‰  0 â†’ âˆ€ (s : Set E) (x : E), Metric.infDist (c â€¢ x) (c â€¢ s) = â€–câ€– * Metric.infDist x s",
  "constCategory": "Theorem"},
 {"references":
  ["Inv.inv",
   "HMul.hMul",
   "Iff.rfl",
   "OfNat.ofNat",
   "le_mul_inv_iffâ‚€",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "mul_comm",
   "Eq.mpr",
   "PosMulReflectLT.toMulPosReflectLT",
   "propext"],
  "name": "le_mul_inv_iffâ‚€'",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : CommGroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a b c : Gâ‚€},\n  0 < c â†’ (a â‰¤ b * câ»Â¹ â†” c * a â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": ["Metric.closedBall", "NNReal", "NNReal.toReal", "Metric.diam"],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.mk._flat_ctor",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±],\n  (âˆ€ (c : Î±) (r : NNReal), Metric.diam (Metric.closedBall c â†‘r) = â†‘r) â†’ SphericallyCompleteSpace.IsSphericallyDense Î±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (Eâ‚€ : Type u_2) [inst_1 : NormedAddCommGroup Eâ‚€]\n  [inst_2 : NormedSpace ğ•œ Eâ‚€], IsScalarTower ğ•œ ğ•œ Eâ‚€",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id",
   "IsBoundedLinearMap.toContinuousLinearMap._proof_1",
   "IsBoundedLinearMap.toLinearMap"],
  "name": "IsBoundedLinearMap.toContinuousLinearMap",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    {F : Type u_3} â†’\n      [inst : Semiring ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup E] â†’\n          [inst_2 : _root_.Module ğ•œ E] â†’\n            [inst_3 : SeminormedAddCommGroup F] â†’\n              [inst_4 : _root_.Module ğ•œ F] â†’ (f : E â†’ F) â†’ IsBoundedLinearMap ğ•œ f â†’ E â†’L[ğ•œ] F",
  "constCategory": "Definition"},
 {"references":
  ["Classical.choose_spec", "Set.Nonempty", "Set", "Membership.mem"],
  "name": "Set.Nonempty.some_mem",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±} (h : s.Nonempty), h.some âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "_private.Mathlib.Data.Set.Disjoint.0.Set.disjoint_iff_forall_ne._proof_1_1"],
  "name": "Set.disjoint_iff_forall_ne",
  "constType":
  "âˆ€ {Î± : Type u} {s t : Set Î±}, Disjoint s t â†” âˆ€ â¦ƒa : Î±â¦„, a âˆˆ s â†’ âˆ€ â¦ƒb : Î±â¦„, b âˆˆ t â†’ a â‰  b",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "NNReal.toReal",
   "SphericallyCompleteSpace.câ‚€",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.exists_norm_sub_lt",
   "DFunLike.coe",
   "Subtype.val",
   "Subtype.prop",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
   "HSub.hSub",
   "QuotientAddGroup.mk'",
   "PreLp",
   "Exists.choose_spec",
   "Norm.norm",
   "Set",
   "And.right",
   "NNReal",
   "Submodule.toAddSubgroup",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "StrictAnti",
   "ENNReal",
   "Antitone",
   "Top.top",
   "id"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.mk_eq_and_norm_sub_lt",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_2) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] [inst_3 : âˆ€ (i : â„•), IsUltrametricDist (E i)]\n  {c : â„• â†’ â†¥(lp E âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ E} {r : â„• â†’ NNReal} (hsr : StrictAnti r)\n  (hanti : Antitone fun i â†¦ Metric.closedBall (c i) â†‘(r i)) (i : â„•),\n  (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ E).toAddSubgroup)\n        â†‘(SphericallyCompleteSpace.quotient_mk_sectionâœ E hsr hanti i) =\n      c i âˆ§\n    â€–â†‘(SphericallyCompleteSpace.quotient_mk_sectionâœÂ¹ E hsr hanti (i + 2)) -\n          â†‘(SphericallyCompleteSpace.quotient_mk_sectionâœÂ² E hsr hanti (i + 1))â€– <\n      â†‘(r i)",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Set.singleton_subset_iff",
   "propext"],
  "name": "Set.singleton_subset_iff._simp_1",
  "constType": "âˆ€ {Î± : Type u} {a : Î±} {s : Set Î±}, ({a} âŠ† s) = (a âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ], RingHomSurjective (RingHom.id ğ•œ)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Submodule.span_singleton_le_iff_mem._simp_1",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "le_iSup_iff",
   "Submodule.span_singleton_le_iff_mem",
   "Submodule.span",
   "congrArg",
   "iSup",
   "iff_self",
   "of_eq_true",
   "forall_congr",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "Submodule.mem_iSup",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {Î¹ : Sort u_9} (p : Î¹ â†’ Submodule R M) {m : M}, m âˆˆ â¨† i, p i â†” âˆ€ (N : Submodule R M), (âˆ€ (i : Î¹), p i â‰¤ N) â†’ m âˆˆ N",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} â†’ {B : outParam (Type u_2)} â†’ [self : SetLike A B] â†’ A â†’ Set B",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearIsometry.toLinearMap",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring Râ‚‚] â†’\n        {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n          {E : Type u_11} â†’\n            {Eâ‚‚ : Type u_12} â†’\n              [inst_2 : SeminormedAddCommGroup E] â†’\n                [inst_3 : SeminormedAddCommGroup Eâ‚‚] â†’\n                  [inst_4 : _root_.Module R E] â†’ [inst_5 : _root_.Module Râ‚‚ Eâ‚‚] â†’ (E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚",
  "constCategory": "Definition"},
 {"references": ["not_le_of_gt", "Not", "LT.lt", "LE.le", "lt_of_not_ge"],
  "name": "lt_iff_not_ge",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, a < b â†” Â¬b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_2",
   "Set.pi",
   "Membership.mem",
   "Iff.mp",
   "Classical.propDecidable",
   "NNReal.toReal",
   "Set.iInter",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_4",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Subtype.prop",
   "eq_of_heq",
   "Dist.dist",
   "forall_congr",
   "Eq.symm",
   "Set.mem_iInter",
   "closedBall_pi",
   "dite_cond_eq_false",
   "Eq.ndrec",
   "Not",
   "dist_self",
   "Exists.choose_spec",
   "Set",
   "NNReal",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_3",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_3",
   "Exists.choose",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_1",
   "Eq.casesOn",
   "OfNat.ofNat",
   "Set.univ",
   "Metric.closedBall",
   "eq_self",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_2",
   "HasSubset.Subset",
   "of_eq_true",
   "dite_cond_eq_true",
   "eq_false",
   "Antitone",
   "NNDist.nndist",
   "LE.le",
   "id",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_4",
   "Eq.mpr",
   "dite"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace",
  "constType":
  "âˆ€ {Î¹ : Type u_1} [inst : Fintype Î¹] {E : Î¹ â†’ Type u_2} [inst_1 : (i : Î¹) â†’ PseudoMetricSpace (E i)]\n  [hh : âˆ€ (i : Î¹), SphericallyCompleteSpace (E i)], SphericallyCompleteSpace ((i : Î¹) â†’ E i)",
  "constCategory": "Theorem"},
 {"references":
  ["IsOpen.isClosed_compl",
   "Disjoint.subset_compl_right",
   "Disjoint.mono_left",
   "IsOpen",
   "Set",
   "Compl.compl",
   "Disjoint",
   "disjoint_compl_left",
   "closure_minimal",
   "closure"],
  "name": "Disjoint.closure_left",
  "constType":
  "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, Disjoint s t â†’ IsOpen t â†’ Disjoint (closure s) t",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Nat.cast_lt",
   "Nat.cast",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "Iff.mpr",
   "_private.Mathlib.Tactic.NormNum.Ineq.0.Mathlib.Meta.NormNum.isNat_lt_true.match_1_1",
   "Iff.mp",
   "Nat.ble"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Semiring Î±] [inst_1 : PartialOrder Î±] [IsOrderedRing Î±] [CharZero Î±] {a b : Î±} {a' b' : â„•},\n  Mathlib.Meta.NormNum.IsNat a a' â†’ Mathlib.Meta.NormNum.IsNat b b' â†’ b'.ble a' = false â†’ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Lean.Omega.Int.add_le_zero_iff_le_neg'",
   "Eq.trans",
   "Eq.mp",
   "Lean.Omega.Coeffs",
   "Decidable.decide",
   "congrArg",
   "Int.eq_iff_le_and_ge",
   "Lean.Omega.Int.add_nonneg_iff_neg_le'",
   "Decidable.decide.congr_simp",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "propext",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "and_comm",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addEquality_sat",
  "constType":
  "âˆ€ {c : â„¤} {x y : Omega.Coeffs}, c + x.dot y = 0 â†’ { lowerBound := some (-c), upperBound := some (-c) }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["Monotone.map_max",
   "monotone_mul_left_of_nonneg",
   "LE.le",
   "HMul.hMul",
   "OfNat.ofNat"],
  "name": "mul_max_of_nonneg",
  "constType":
  "âˆ€ {R : Type u} [inst : Semiring R] [inst_1 : LinearOrder R] {a : R} [PosMulMono R] (b c : R),\n  0 â‰¤ a â†’ a * max b c = max (a * b) (a * c)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "ContinuousLinearMap.le_of_opNorm_le",
   "Subtype.val",
   "RingHom.id",
   "funext",
   "forall_congr",
   "eq_of_heq",
   "Eq.symm",
   "SphericallyCompleteSpace.hahn_banach._simp_1_3",
   "Eq.ndrec",
   "HEq.casesOn",
   "And.left",
   "Norm.norm",
   "outParam",
   "And.right",
   "SphericallyCompleteSpace.OrthProj",
   "ContinuousLinearMap.norm_def",
   "true_and",
   "SphericallyCompleteSpace.norm_OrthProj_le_one",
   "Iff.mpr",
   "SetLike.coe_eq_coe",
   "lowerBounds",
   "id",
   "Eq.mpr",
   "one_mul",
   "setOf",
   "Eq.mp",
   "le_trans",
   "SphericallyCompleteSpace.hahn_banach._simp_1_4",
   "DFunLike.coe",
   "ContinuousLinearMap.opNorm_nonneg",
   "ContinuousLinearMap.comp",
   "congrArg",
   "csInf_le_csInf",
   "Subtype.prop",
   "Subtype.property",
   "InfSet.sInf",
   "SphericallyCompleteSpace.OrthProj_id",
   "PosMulMono.mul_le_mul_of_nonneg_left",
   "ContinuousLinearMap.le_opNorm",
   "ContinuousLinearMap.comp_apply",
   "Set",
   "SphericallyCompleteSpace.hahn_banach._simp_1_2",
   "Eq.casesOn",
   "OfNat.ofNat",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_iff",
   "eq_of_le_of_ge"],
  "name": "SphericallyCompleteSpace.hahn_banach",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [IsUltrametricDist E] (D : Submodule ğ•œ E) {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [IsUltrametricDist F] [hd : SphericallyCompleteSpace â†¥D] (f : â†¥D â†’L[ğ•œ] F),\n  âˆƒ f', (âˆ€ (v : E) (hv : v âˆˆ D), f' v = f âŸ¨v, hvâŸ©) âˆ§ â€–f'â€– = â€–fâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Set.iInter",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "le_of_not_gt",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NNReal",
   "Filter.atTop",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "StrictMono",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "lt_of_not_ge",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_1",
   "Mathlib.Tactic.Ring.neg_zero",
   "dist_comm",
   "Set",
   "StrictMono.tendsto_atTop",
   "HPow.hPow",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "Nat.cast_add",
   "Metric.closedBall",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius",
   "antitone_nat_of_succ_le",
   "dite",
   "neg_neg_of_pos",
   "And.casesOn",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Int.rawCast",
   "HMul.hMul",
   "GE.ge",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Filter.Tendsto",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_4",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_5",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_2",
   "Iff.mpr",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Eq.mp",
   "Metric.mem_closedBall",
   "NNReal.toReal",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "eventually_stable_or_exists_strictanti_of_antitone",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Function.comp",
   "StrictMono.monotone",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "Or.casesOn",
   "StrictAnti",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "Filter.tendsto_atTop_atTop_iff_of_monotone",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_3"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [iud : IsUltrametricDist Î±],\n  SphericallyCompleteSpace Î± â†”\n    âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n      StrictAnti ri â†’\n        (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["exists_apply_eq_apply", "eq_true"],
  "name": "exists_apply_eq_apply._simp_1",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} (f : Î± â†’ Î²) (a' : Î±), (âˆƒ a, f a = f a') = True",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Exists.choose"],
  "name": "Exists.choose.congr_simp",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p p_1 : Î± â†’ Prop} (e_p : p = p_1) (P : âˆƒ a, p a), P.choose = â‹¯.choose",
  "constCategory": "Theorem"},
 {"references": ["norm_eq_zero", "Norm.norm", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_16",
  "constType":
  "âˆ€ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, (â€–aâ€– = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["dist_comm",
   "Eq.mp",
   "Set",
   "NNReal",
   "Membership.mem",
   "NNReal.toReal",
   "diam_le_radius_of_ultrametric._proof_1_1",
   "OfNat.ofNat",
   "congrArg",
   "Metric.closedBall",
   "Max.max",
   "Subtype.prop",
   "IsUltrametricDist.dist_triangle_max",
   "LE.le",
   "Dist.dist",
   "Metric.diam_le_of_forall_dist_le"],
  "name": "diam_le_radius_of_ultrametric",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±] [hiud : IsUltrametricDist Î±] (z : Î±) (r : NNReal),\n  Metric.diam (Metric.closedBall z â†‘r) â‰¤ â†‘r",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "Subtype.val",
   "Subspace",
   "congrArg",
   "Prod.fst",
   "Submodule.add_mem_sup",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Subtype.coe_eta",
   "Eq.ndrec",
   "And.left",
   "Exists.choose_spec",
   "Set",
   "Submodule.add_eq_sup",
   "And.right",
   "Prod.snd",
   "Exists.choose",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "id",
   "Eq.mpr"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_15",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (t : â†¥(ğ•œ âˆ™ x + F)),\n  âŸ¨â†‘(â‹¯.mpr (fun z â†¦ (âŸ¨â‹¯.choose, â‹¯âŸ©, âŸ¨â‹¯.choose, â‹¯âŸ©)) t).1 + â†‘(â‹¯.mpr (fun z â†¦ (âŸ¨â‹¯.choose, â‹¯âŸ©, âŸ¨â‹¯.choose, â‹¯âŸ©)) t).2, â‹¯âŸ© = t",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "bot_le", "eq_true", "Bot.bot"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LE Î±] [inst_1 : OrderBot Î±] {a : Î±}, (âŠ¥ â‰¤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_2",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort v} {x : Î±} {s : Î¹ â†’ Set Î±}, (x âˆˆ â‹‚ i, s i) = âˆ€ (i : Î¹), x âˆˆ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_2",
  "constType":
  "âˆ€ {a0 a1 a2 : â„¤} {t : List â„¤}, (Omega.LinearCombo.coordinate 2).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: t)) = a2",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le", "Nat.add_comm", "Nat.le_add_right"],
  "name": "Nat.le_add_left",
  "constType": "âˆ€ (n m : â„•), n â‰¤ m + n",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_8",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Syntax.getKind", "BEq.beq"],
  "name": "Lean.Syntax.isOfKind",
  "constType": "Syntax â†’ SyntaxNodeKind â†’ Bool",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval.match_1",
   "List.map",
   "Mathlib.Tactic.FieldSimp.NF",
   "List.prod",
   "Mathlib.Tactic.FieldSimp.zpow'"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval",
  "constType":
  "{M : Type u_1} â†’ [GroupWithZero M] â†’ Mathlib.Tactic.FieldSimp.NF M â†’ M",
  "constCategory": "Definition"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.hahn_banach._simp_1_4",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 â‰¤ â€–aâ€–) = True",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "PreLp",
   "Eq.trans",
   "Norm.norm",
   "HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "LinearIsometry.norm_map",
   "SphericallyCompleteSpace.câ‚€",
   "DFunLike.coe",
   "congrArg",
   "eq_self",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "of_eq_true",
   "RingHom.id",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_6",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E), â€–(SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) xâ€– = â€–xâ€–",
  "constCategory": "Theorem"},
 {"references": ["map_add"],
  "name": "ContinuousLinearMap.map_add",
  "constType":
  "âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4}\n  [inst_2 : TopologicalSpace Mâ‚] [inst_3 : AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [inst_4 : TopologicalSpace Mâ‚‚]\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : _root_.Module Râ‚ Mâ‚] [inst_7 : _root_.Module Râ‚‚ Mâ‚‚] (f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚)\n  (x y : Mâ‚), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "Membership.mem",
   "SphericallyCompleteSpace.Orth",
   "SphericallyCompleteSpace.MOrth",
   "Subspace",
   "SphericallyCompleteSpace.sorth_iff_forall_orth._simp_1_2",
   "congrArg"],
  "name": "SphericallyCompleteSpace.sorth_iff_forall_orth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (F1 F2 : Subspace ğ•œ E),\n  SphericallyCompleteSpace.SOrth ğ•œ F1 F2 â†” âˆ€ x âˆˆ F1, âˆ€ y âˆˆ F2, x âŸ‚[ğ•œ] y",
  "constCategory": "Theorem"},
 {"references": ["WithTop.untopD", "NNReal", "OfNat.ofNat"],
  "name": "ENNReal.toNNReal",
  "constType": "ENNReal â†’ NNReal",
  "constCategory": "Definition"},
 {"references": ["Metric.closedBall", "NNReal", "NNReal.toReal", "Metric.diam"],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.recOn",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    {motive : SphericallyCompleteSpace.IsSphericallyDense Î± â†’ Sort u} â†’\n      (t : SphericallyCompleteSpace.IsSphericallyDense Î±) â†’\n        ((spherically_dense : âˆ€ (c : Î±) (r : NNReal), Metric.diam (Metric.closedBall c â†‘r) = â†‘r) â†’ motive â‹¯) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "HMul.hMul",
   "Int.rawCast",
   "Int.cast",
   "OfNat.ofNat",
   "Int.cast_neg",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Int.cast_one",
   "neg_mul",
   "Int.negOfNat",
   "Eq.ndrec",
   "one_mul"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "âˆ€ {R : Type u_2} [inst : CommRing R] {a b : R}, (Int.negOfNat 1).rawCast * a = b â†’ -a = b",
  "constCategory": "Theorem"},
 {"references": ["Nat.lt_add_one"],
  "name": "Nat.lt_succ_self",
  "constType": "âˆ€ (n : â„•), n < n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "mul_inv_cancelâ‚€",
   "Inv.inv",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "inv_inv",
   "LT.lt.ne'",
   "not_false_eq_true",
   "of_eq_true",
   "eq_false",
   "congr",
   "id",
   "Eq.mpr",
   "LT.lt.le",
   "lt_of_mul_lt_mul_left"],
  "name": "inv_pos",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a : Gâ‚€}, 0 < aâ»Â¹ â†” 0 < a",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "HSMul.hSMul"],
  "name": "Mathlib.Tactic.Abel.termg",
  "constType": "{Î± : Type u_1} â†’ [AddCommGroup Î±] â†’ â„¤ â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Metric.exists_ball_subset_ball",
   "IsOpen",
   "HasSubset.Subset",
   "Set",
   "Iff.mpr",
   "Membership.mem",
   "Metric.ball",
   "GT.gt",
   "Metric.isOpen_iff",
   "OfNat.ofNat"],
  "name": "Metric.isOpen_ball",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, IsOpen (Metric.ball x Îµ)",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.SimpLemmas.0.and_imp.match_1_1"],
  "name": "and_imp",
  "constType": "âˆ€ {a b c : Prop}, a âˆ§ b â†’ c â†” a â†’ b â†’ c",
  "constCategory": "Theorem"},
 {"references":
  ["exists_bijective_subseq_of_finite_duplication._proof_1_7",
   "implies_congr",
   "_private.SphericalCompleteness.External.Sequence.0.ebsofd._proof_2",
   "GT.gt",
   "congrArg",
   "strictMono_nat_of_lt_succ",
   "funext",
   "forall_congr",
   "exists_bijective_subseq_of_finite_duplication._simp_1_4",
   "Eq.ndrec",
   "exists_bijective_subseq_of_finite_duplication._proof_1_6",
   "Not",
   "Exists.choose_spec",
   "Function.comp",
   "StrictMono.monotone",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Max.max",
   "Function.Injective.of_lt_imp_ne",
   "id",
   "Eq.mpr",
   "_private.SphericalCompleteness.External.Sequence.0.ebsofd",
   "Ne",
   "Exists.choose.congr_simp",
   "Function.Injective",
   "StrictMono"],
  "name": "exists_bijective_subseq_of_finite_duplication",
  "constType":
  "âˆ€ {Î± : Type u_1} (seq : â„• â†’ Î±),\n  (âˆ€ (n : â„•), âˆƒ N, âˆ€ i > N, seq n â‰  seq i) â†’ âˆƒ Ï†, StrictMono Ï† âˆ§ Function.Injective (seq âˆ˜ Ï†)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u â†’ Type u",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "zero_add",
   "zero_nsmul",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "succ_nsmul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "one_nsmul",
  "constType": "âˆ€ {M : Type u_2} [inst : AddMonoid M] (a : M), 1 â€¢ a = a",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Array.mkArray3"],
  "name": "Lean.Syntax.node3",
  "constType":
  "SourceInfo â†’ SyntaxNodeKind â†’ Syntax â†’ Syntax â†’ Syntax â†’ Syntax",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow.hPow",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HPow Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "_private.Mathlib.Logic.Basic.0.exists_exists_eq_and.match_1_1",
   "_private.Mathlib.Logic.Basic.0.exists_exists_eq_and.match_1_3",
   "Eq.symm"],
  "name": "exists_exists_eq_and",
  "constType":
  "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆƒ b, (âˆƒ a, f a = b) âˆ§ p b) â†” âˆƒ a, p (f a)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "le_trans", "LE.le", "le_sup_left"],
  "name": "le_sup_of_le_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, c â‰¤ a â†’ c â‰¤ a âŠ” b",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "HMul.hMul", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' â†’ b = b' â†’ a' * b' = c â†’ a * b = c",
  "constCategory": "Theorem"},
 {"references": ["IsLinearMap.mk'", "IsBoundedLinearMap.toIsLinearMap"],
  "name": "IsBoundedLinearMap.toLinearMap",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    {F : Type u_3} â†’\n      [inst : Semiring ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup E] â†’\n          [inst_2 : _root_.Module ğ•œ E] â†’\n            [inst_3 : SeminormedAddCommGroup F] â†’\n              [inst_4 : _root_.Module ğ•œ F] â†’ (f : E â†’ F) â†’ IsBoundedLinearMap ğ•œ f â†’ E â†’â‚—[ğ•œ] F",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Nat.recAux",
   "add_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "add_assoc",
   "Nat.cast_zero",
   "Nat.add_succ",
   "id",
   "Eq.mpr",
   "Nat.cast_succ"],
  "name": "Nat.cast_add",
  "constType":
  "âˆ€ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : â„•), â†‘(m + n) = â†‘m + â†‘n",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
   "not_lt._simp_1",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "Metric.diam",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "eq_true",
   "sub_zero",
   "UniformSpace.complete_of_cauchySeq_tendsto",
   "_private.SphericalCompleteness.External.Complete.0.dcidx",
   "le_of_not_gt",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_4",
   "Eq.symm",
   "mul_comm",
   "abs",
   "Nat.ble",
   "Nat.ofNat_pos._simp_1",
   "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
   "congr_arg",
   "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._proof_1_17",
   "ne_of_gt",
   "ENNReal.inv_zpow'",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_evalâ‚‚",
   "ENNReal.coe_eq_zero._simp_1",
   "Filter.atTop",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_15",
   "eq_false",
   "Antitone",
   "ENNReal.coe_ne_top",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Eq.mpr",
   "Mathlib.Tactic.Ring.add_mul",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_8",
   "Not.intro",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_evalâ‚ƒ",
   "Mathlib.Meta.NormNum.isNat_le_true",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_13",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "le_mul_inv_iffâ‚€",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Prod.fst",
   "inv_div",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Metric.tendsto_atTop'",
   "_private.SphericalCompleteness.External.Complete.0.dcidx_controlled_converge",
   "mul_one",
   "WithTop.coe_lt_coe",
   "HPow.hPow",
   "lt_of_lt_of_le",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "eq_self",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_3",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "Ne",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
   "Filter.Eventually",
   "false_and",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
   "Membership.mem",
   "Subtype.mk.congr_simp",
   "GT.gt",
   "GE.ge",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
   "Real.toNNReal_eq_zero._simp_1",
   "not_false_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_5",
   "forall_congr",
   "Mathlib.Tactic.Linarith.add_neg",
   "ENNReal.toReal",
   "Mathlib.Tactic.Ring.single_pow",
   "Filter.Tendsto",
   "Mathlib.Tactic.FieldSimp.subst_add",
   "Nat.mul",
   "Metric.diam_closedBall",
   "Mathlib.Meta.NormNum.isNat_eq_false",
   "lt_of_le_of_lt",
   "Mathlib.Tactic.Ring.mul_zero",
   "ENNReal.toReal_eq_toReal_iff'",
   "Mathlib.Tactic.FieldSimp.lt_eq_cancel_lt",
   "CauchySeq",
   "zpow_eq_pow",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "div_pos_iff_of_pos_left._simp_1",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
   "Mathlib.Tactic.Linarith.mul_nonpos",
   "zpow_natCast_sub_oneâ‚€",
   "not_false",
   "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
   "Mathlib.Tactic.Ring.mul_one",
   "Nat.cast",
   "Eq.mp",
   "ENNReal.ofNNReal",
   "Metric.mem_closedBall",
   "le_trans",
   "Or.resolve_right",
   "NNReal.toReal",
   "WithTop.some",
   "mul_div_assoc'",
   "LT.lt.ne_top",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "le_of_eq",
   "DivInvMonoid.zpow",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_9",
   "Mathlib.Meta.NormNum.isNNRat_inv_pos",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Inv.inv",
   "inv_pow",
   "ENNReal.toReal_inv",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
   "Mathlib.Tactic.Ring.cast_pos",
   "zero_lt_one",
   "add_sub_cancel_right",
   "Mathlib.Tactic.Ring.add_congr",
   "Metric.nonempty_iInter_of_nonempty_biInter",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "ENNReal.toReal_ofNat",
   "Eq.trans",
   "inv_pos_of_pos",
   "WithTop",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Meta.NormNum.isNNRat_div",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "sub_eq_zero_of_eq",
   "Mathlib.Tactic.Ring.one_mul",
   "Metric.diam_nonneg",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_2",
   "four_pos",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "nhds",
   "rfl",
   "Mathlib.Tactic.Ring.pow_prod_atom",
   "Exists.choose_spec",
   "Norm.norm",
   "abs_inv",
   "NNReal",
   "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
   "Prod.snd",
   "zpow_le_zpow_iff_rightâ‚€",
   "_private.SphericalCompleteness.External.Complete.0.dcidx_strict_mono",
   "NNDist.nndist",
   "Nat.rawCast",
   "Metric.isClosed_closedBall",
   "one_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Ne.symm",
   "add_lt_add_of_le_of_lt",
   "pow_pos",
   "one_div",
   "lt_div_iffâ‚€",
   "not_le._simp_1",
   "div_pos",
   "Int.add_one_le_iff",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "LT.lt.ne'",
   "mul_le_mul_of_nonneg_right",
   "add_le_add",
   "Mathlib.Tactic.Ring.pow_congr",
   "congr",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_10",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "lt_of_not_ge",
   "Mathlib.Tactic.Ring.pow_zero",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_evalâ‚ƒ",
   "pow_eq_zero_iff'._simp_1",
   "dist_comm",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_12",
   "dist_zero_right",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Max.max",
   "ENNReal",
   "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
   "congr_argâ‚‚",
   "inferInstance",
   "antitone_nat_of_succ_le",
   "neg_neg_of_pos",
   "Mathlib.Meta.NormNum.isNNRat_mul",
   "Real.toNNReal._proof_1",
   "lt_trans",
   "Mathlib.Tactic.Ring.zero_mul",
   "Nat.cast_one",
   "ENNReal.coe_inv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Linarith.lt_of_lt_of_eq",
   "Metric.isBounded_closedBall",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "Mathlib.Tactic.FieldSimp.NF.cons_pos",
   "one_lt_two",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_16",
   "HDiv.hDiv",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_7",
   "abs_eq_self",
   "Mathlib.Meta.NormNum.isNat_add",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.FieldSimp.NF.inv_eq_eval",
   "Real.toNNReal",
   "Neg.neg",
   "ENNReal.exists_inv_two_pow_lt",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_1",
   "CancelDenoms.sub_subst",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "div_one",
   "mul_div_cancel_rightâ‚€",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "NeZero.ne'",
   "congrArg",
   "sup_eq_left._simp_1",
   "Subtype.prop",
   "ENNReal.toReal_pow",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "dist_triangle",
   "Mathlib.Tactic.FieldSimp.NF.one_div_eq_eval",
   "zpow_pos",
   "pow_nonneg._simp_1",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_14",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "zpow_natCast",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_11",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "ENNReal.zpow_neg",
   "Mathlib.Tactic.Ring.pow_add",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "mul_div",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
   "CancelDenoms.div_subst",
   "Exists.choose",
   "NNReal.abs_eq",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "DivInvMonoid.zpow_succ'",
   "lt_mul_iff_one_lt_right'._simp_2",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name":
  "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±],\n  CompleteSpace Î± â†”\n    âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n      (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’\n        Filter.Tendsto ri Filter.atTop (nhds 0) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mpr_not",
   "dite",
   "dite_congr",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_cond_eq_true",
  "constType":
  "âˆ€ {Î± : Sort u} {c : Prop} {x : Decidable c} {t : c â†’ Î±} {e : Â¬c â†’ Î±} (h : c = True), dite c t e = t â‹¯",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "GT.gt",
   "Decidable.decide",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Nat.lt_of_not_le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._proof_10",
  "constType": "âˆ€ (n k : â„•), k + 1 â‰¥ n + 1 â†’ Â¬k = n â†’ Â¬k â‰¥ n + 1 â†’ False",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "add_assoc",
   "congr",
   "HSub.hSub",
   "neg_add_rev",
   "add_comm",
   "congrArg"],
  "name": "sub_sub",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SubtractionCommMonoid Î±] (a b c : Î±), a - b - c = a - (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["HSMul.hSMul", "Eq.symm", "HMul.hMul", "SemigroupAction.mul_smul"],
  "name": "smul_smul",
  "constType":
  "âˆ€ {M : Type u_1} {Î± : Type u_5} [inst : Monoid M] [inst_1 : MulAction M Î±] (aâ‚ aâ‚‚ : M) (b : Î±),\n  aâ‚ â€¢ aâ‚‚ â€¢ b = (aâ‚ * aâ‚‚) â€¢ b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat.cast",
   "Eq.mp",
   "Nat.ble_eq",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Iff.mpr",
   "Nat.cast_pos",
   "LE.le",
   "id",
   "Eq.mpr",
   "Nat.ble"],
  "name": "Mathlib.Meta.Positivity.pos_of_isNat",
  "constType":
  "âˆ€ {A : Type u_1} {e : A} {n : â„•} [inst : Semiring A] [inst_1 : PartialOrder A] [IsOrderedRing A] [Nontrivial A],\n  Mathlib.Meta.NormNum.IsNat e n â†’ Nat.ble 1 n = true â†’ 0 < e",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Iff.rfl", "Set.range"],
  "name": "Set.mem_range",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±} {x : Î±}, x âˆˆ Set.range f â†” âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_19",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, (Â¬a < b) = (b â‰¤ a)",
  "constCategory": "Theorem"},
 {"references": ["upperBounds", "Set", "Membership.mem", "Iff.rfl"],
  "name": "mem_upperBounds",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, a âˆˆ upperBounds s â†” âˆ€ x âˆˆ s, x â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "Mathlib.Meta.NormNum.isNNRat_div",
   "Mathlib.Tactic.Linarith.add_lt_of_le_of_neg",
   "Mathlib.Tactic.Ring.one_mul",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "rfl",
   "Norm.norm",
   "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
   "norm_add_le",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Top.top",
   "Eq.mpr",
   "Nat.rawCast",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "Mathlib.Tactic.Linarith.add_nonpos",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_add",
   "lt_of_not_ge",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "ENNReal",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "inferInstance",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
   "neg_neg_of_pos",
   "Mathlib.Meta.NormNum.isNNRat_mul",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Int.rawCast",
   "HMul.hMul",
   "GT.gt",
   "GE.ge",
   "HDiv.hDiv",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Nat.mul",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Linarith.natCast_nonneg",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Exists.casesOn",
   "CancelDenoms.sub_subst",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.mpr",
   "Nat.cast_zero",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "id",
   "Mathlib.Tactic.Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Ring.mul_one",
   "Nat.cast",
   "lp",
   "Eq.mp",
   "le_trans",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Meta.NormNum.isNNRat_inv_pos",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Mathlib.Tactic.Ring.of_eq",
   "PreLp",
   "Inv.inv",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "CancelDenoms.div_subst",
   "Mathlib.Tactic.Ring.add_congr",
   "SphericallyCompleteSpace.câ‚€._simp_1",
   "LT.lt",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.câ‚€._proof_2",
  "constType":
  "âˆ€ (E : â„• â†’ Type u_1) [inst : (i : â„•) â†’ NormedAddCommGroup (E i)] {a b : â†¥(lp E âŠ¤)},\n  a âˆˆ {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ} â†’\n    b âˆˆ {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ} â†’ a + b âˆˆ {f | âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, â€–â†‘f nâ€– â‰¤ Îµ}",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntax.raw",
  "constType": "{ks : SyntaxNodeKinds} â†’ TSyntax ks â†’ Syntax",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership.mem",
  "constType":
  "{Î± : outParam (Type u)} â†’ {Î³ : Type v} â†’ [self : Membership Î± Î³] â†’ Î³ â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "mul_pos_iff_of_pos_left",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "of_eq_true",
   "iff_self",
   "propext",
   "_private.Mathlib.Algebra.Order.Field.Basic.0.div_pos_iff_of_pos_left._simp_1_1"],
  "name": "div_pos_iff_of_pos_left",
  "constType":
  "âˆ€ {Î± : Type u_2} [inst : Semifield Î±] [inst_1 : PartialOrder Î±] [PosMulReflectLT Î±] {a b : Î±} [IsStrictOrderedRing Î±],\n  0 < a â†’ (0 < a / b â†” 0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "LE.le",
   "Membership.mem",
   "ConditionallyCompleteLattice.le_csInf"],
  "name": "le_csInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s : Set Î±} {a : Î±}, s.Nonempty â†’ (âˆ€ b âˆˆ s, a â‰¤ b) â†’ a â‰¤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "GE.ge",
  "constType": "{Î± : Type u} â†’ [LE Î±] â†’ Î± â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.Elem"],
  "name": "Set.toFinite",
  "constType": "âˆ€ {Î± : Type u} (s : Set Î±) [Finite â†‘s], s.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "LE.le",
   "Metric.ball",
   "Metric.ball_eq_empty",
   "EmptyCollection.emptyCollection",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_11",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, (Metric.ball x Îµ = âˆ…) = (Îµ â‰¤ 0)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "cast"],
  "name": "eq_of_heq",
  "constType": "âˆ€ {Î± : Sort u} {a a' : Î±}, a â‰ a' â†’ a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Inter.inter",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_1",
   "Classical.propDecidable",
   "Set.iInter",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_8",
   "Set.inter_eq_self_of_subset_right",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_6",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_9",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_5",
   "funext",
   "forall_congr",
   "Eq.symm",
   "Set.iInter_congr_Prop",
   "csInf_le",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
   "binderNameHint",
   "Set.Nonempty.to_subtype",
   "NNReal",
   "Set.iInter_coe_set",
   "Prod.snd",
   "BddBelow",
   "Exists.casesOn",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Iff.mpr",
   "Antitone",
   "id",
   "Mathlib.Tactic.Push.not_and_eq",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_3",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.antitone_of_countable_chain_of_ball",
   "Set.inter_eq_self_of_subset_left",
   "setOf",
   "Ne.symm",
   "Eq.mp",
   "NNReal.toReal",
   "lt_of_le_of_ne",
   "congrArg",
   "Prod.fst",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_4",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Subtype.prop",
   "congr",
   "InfSet.sInf",
   "Dist.dist",
   "Set.mem_iInter",
   "lt_of_not_ge",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Set",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.cofinal_of_countable_chain_of_ball",
   "OfNat.ofNat",
   "LT.lt",
   "Metric.closedBall",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric",
   "Ne",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_2",
   "dite",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [iud : IsUltrametricDist Î±],\n  SphericallyCompleteSpace Î± â†”\n    âˆ€ (S : Set (Î± Ã— NNReal)),\n      S.Nonempty â†’\n        (âˆ€ (w1 w2 : â†‘S), (Metric.closedBall (â†‘w1).1 â†‘(â†‘w1).2 âˆ© Metric.closedBall (â†‘w2).1 â†‘(â†‘w2).2).Nonempty) â†’\n          (â‹‚ w, Metric.closedBall (â†‘w).1 â†‘(â†‘w).2).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.MOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.MOrth.congr_simp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  x = x_1 â†’\n    âˆ€ (F F_1 : Subspace ğ•œ E), F = F_1 â†’ SphericallyCompleteSpace.MOrth ğ•œ x F = SphericallyCompleteSpace.MOrth ğ•œ x_1 F_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkStr4",
  "constType": "String â†’ String â†’ String â†’ String â†’ Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["Imp.swap", "Iff.mp"],
  "name": "Mathlib.Tactic.Contrapose.contraposeâ‚ƒ",
  "constType": "âˆ€ {p q : Prop}, (q â†’ Â¬p) â†’ p â†’ Â¬q",
  "constCategory": "Theorem"},
 {"references": ["Ne.isUnit", "IsUnit.div_self", "Ne", "OfNat.ofNat"],
  "name": "div_self",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] {a : Gâ‚€}, a â‰  0 â†’ a / a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Submodule.toAddSubmonoid",
   "Eq.trans",
   "NormedAddCommGroup.tendsto_atTop",
   "norm_le_norm_sub_add",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "Mathlib.Meta.NormNum.isNNRat_div",
   "SphericallyCompleteSpace.câ‚€._simp_2",
   "iSup",
   "Mathlib.Tactic.Ring.one_mul",
   "IsSeqClosed",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "nhds",
   "rfl",
   "Norm.norm",
   "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_4",
   "Filter.atTop",
   "SetLike.coe",
   "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€._simp_2",
   "Nat.max",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "Nat.rawCast",
   "add_halves",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "AddSubsemigroup.carrier",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "norm_sub_rev",
   "add_le_add",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "ciSup_le_iff",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "lt_of_not_ge",
   "lp.norm_eq_ciSup",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_8",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "ENNReal.top_ne_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "inferInstance",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
   "Mathlib.Meta.NormNum.isNNRat_mul",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
   "le_refl",
   "SphericallyCompleteSpace.câ‚€._proof_2",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.câ‚€._proof_3",
   "Int.rawCast",
   "HMul.hMul",
   "SphericallyCompleteSpace.câ‚€",
   "GT.gt",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_9",
   "GE.ge",
   "HDiv.hDiv",
   "SphericallyCompleteSpace.câ‚€._proof_1",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "AddSubmonoid.mk.congr_simp",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "add_comm",
   "Filter.Tendsto",
   "Submodule.mk.congr_simp",
   "Nat.mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Exists.casesOn",
   "CancelDenoms.sub_subst",
   "Mathlib.Tactic.Ring.atom_pf",
   "lp.norm_apply_le_norm",
   "upperBounds",
   "Nat.cast_zero",
   "HSMul.hSMul",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "id",
   "Mathlib.Tactic.Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_6",
   "Eq.mp",
   "lp",
   "le_trans",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "Set.range",
   "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€._simp_3",
   "congrArg",
   "SphericallyCompleteSpace.câ‚€._proof_4",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Meta.NormNum.isNNRat_inv_pos",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "PreLp",
   "Inv.inv",
   "Mathlib.Tactic.Ring.cast_pos",
   "CancelDenoms.div_subst",
   "Mathlib.Tactic.Ring.add_congr",
   "SphericallyCompleteSpace.câ‚€._simp_1",
   "LT.lt",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_7",
   "LE.le",
   "IsSeqClosed.isClosed",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "AddSubsemigroup.mk.congr_simp"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleCâ‚€._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E], IsClosed (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).carrier",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "HAdd.hAdd"],
  "name": "AddLeftStrictMono",
  "constType": "(M : Type u_1) â†’ [Add M] â†’ [LT M] â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Lean.Omega.Coeffs",
   "and_true",
   "Decidable.decide",
   "GE.ge",
   "congrArg",
   "Decidable.decide.congr_simp",
   "congr",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Int.zero_sub",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Int.sub_left_le_of_le_add",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addInequality_sat",
  "constType":
  "âˆ€ {c : â„¤} {x y : Omega.Coeffs}, c + x.dot y â‰¥ 0 â†’ { lowerBound := some (-c), upperBound := none }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace",
   "inferInstance"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceOfWeaklyLocallyCompactNormedField",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : NontriviallyNormedField Î±] [WeaklyLocallyCompactSpace Î±], SphericallyCompleteSpace Î±",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "smul_neg",
   "Neg.neg",
   "HSMul.hSMul",
   "id",
   "HSub.hSub",
   "smul_add",
   "Eq.mpr",
   "congrArg"],
  "name": "smul_sub",
  "constType":
  "âˆ€ {M : Type u_1} {A : Type u_7} [inst : AddGroup A] [inst_1 : DistribSMul M A] (r : M) (x y : A),\n  r â€¢ (x - y) = r â€¢ x - r â€¢ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bot.bot",
  "constType": "{Î± : Type u_1} â†’ [self : Bot Î±] â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Eq.symm",
   "Iff.eq",
   "mul_lt_mul_iff_of_pos_left",
   "HMul.hMul",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.lt_eq_cancel_lt",
  "constType":
  "âˆ€ {M : Type u_1} [inst : MonoidWithZero M] [inst_1 : PartialOrder M] [PosMulStrictMono M] [PosMulReflectLT M]\n  {eâ‚ eâ‚‚ fâ‚ fâ‚‚ L : M}, eâ‚ = L * fâ‚ â†’ eâ‚‚ = L * fâ‚‚ â†’ 0 < L â†’ (eâ‚ < eâ‚‚) = (fâ‚ < fâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "Eq.mp",
   "HMul.hMul",
   "GT.gt",
   "neg_of_neg_pos",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "Left.one_lt_inv_iff._simp_2",
   "neg_mul",
   "gt_iff_lt._simp_1",
   "LE.le",
   "id",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "neg_neg_of_pos"],
  "name": "Mathlib.Tactic.Linarith.mul_neg",
  "constType":
  "âˆ€ {Î± : Type u} [inst : Ring Î±] [inst_1 : PartialOrder Î±] [IsStrictOrderedRing Î±] {a b : Î±}, a < 0 â†’ 0 < b â†’ b * a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name": "Submodule.mk_eq_zero._simp_1",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x âˆˆ p), (âŸ¨x, hâŸ© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_14",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Set Î±) (y : Î²), (y âˆˆ f '' s) = âˆƒ x âˆˆ s, f x = y",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl"],
  "name": "Iff.of_eq",
  "constType": "âˆ€ {a b : Prop}, a = b â†’ (a â†” b)",
  "constCategory": "Theorem"},
 {"references":
  ["le_hasSum",
   "lp",
   "SummationFilter.unconditional",
   "Membership.mem",
   "ENNReal.toReal_pos",
   "lp.hasSum_norm",
   "eq_or_ne",
   "Subtype.val",
   "Set.range",
   "congrArg",
   "Eq.symm",
   "ENNReal.toReal",
   "Eq.ndrec",
   "lp.isLUB_norm",
   "propext",
   "And.left",
   "rfl",
   "PreLp",
   "lp.norm_nonneg'",
   "Norm.norm",
   "Set",
   "Real.rpow_nonneg",
   "HPow.hPow",
   "OfNat.ofNat",
   "Or.casesOn",
   "LT.lt",
   "ENNReal",
   "Real.rpow_le_rpow_iff",
   "upperBounds",
   "LE.le",
   "lowerBounds",
   "id",
   "Top.top",
   "Eq.mpr",
   "norm_nonneg",
   "Ne"],
  "name": "lp.norm_apply_le_norm",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)],\n  p â‰  0 â†’ âˆ€ (f : â†¥(lp E p)) (i : Î±), â€–â†‘f iâ€– â‰¤ â€–fâ€–",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Module.rank",
  "constType":
  "(R : Type u_1) â†’\n  (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommMonoid M] â†’ [_root_.Module R M] â†’ Cardinal.{u_2}",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Order.Defs.LinearOrder.0.max_self._proof_1_1"],
  "name": "max_self",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] (a : Î±), max a a = a",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_10",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_7",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LT Î±] {x y : Î±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.smul_orth_of_orth._simp_1_1",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x âˆˆ â†‘p) = (x âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_and_or", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_2",
  "constType": "âˆ€ {a b : Prop}, (Â¬(a âˆ§ b)) = (Â¬a âˆ¨ Â¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Module.finrank_eq_of_rank_eq",
   "Bot.bot",
   "OfNat.ofNat",
   "rank_bot"],
  "name": "finrank_bot",
  "constType":
  "âˆ€ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] [Nontrivial R],\n  Module.finrank R â†¥âŠ¥ = 0",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_4",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "mul_le_mul_iff_rightâ‚€",
   "LE.le",
   "Eq.symm",
   "Iff.eq",
   "HMul.hMul",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
  "constType":
  "âˆ€ {M : Type u_1} [inst : MonoidWithZero M] [inst_1 : PartialOrder M] [PosMulMono M] [PosMulReflectLE M]\n  {eâ‚ eâ‚‚ fâ‚ fâ‚‚ L : M}, eâ‚ = L * fâ‚ â†’ eâ‚‚ = L * fâ‚‚ â†’ 0 < L â†’ (eâ‚ â‰¤ eâ‚‚) = (fâ‚ â‰¤ fâ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_one",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] (a : R), a * Nat.rawCast 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Neg.neg",
   "Set",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Iff.rfl"],
  "name": "AddSubgroup.mem_mk",
  "constType":
  "âˆ€ {G : Type u_1} [inst : AddGroup G] {s : AddSubmonoid G} {x : G} (h_neg : âˆ€ {x : G}, x âˆˆ s.carrier â†’ -x âˆˆ s.carrier),\n  x âˆˆ { toAddSubmonoid := s, neg_mem' := h_neg } â†” x âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "ENNReal",
   "Memâ„“p.add",
   "Memâ„“p",
   "zero_memâ„“p",
   "Memâ„“p.neg",
   "setOf"],
  "name": "lp",
  "constType":
  "{Î± : Type u_3} â†’ (E : Î± â†’ Type u_5) â†’ [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] â†’ ENNReal â†’ AddSubgroup (PreLp E)",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.range._proof_1",
   "Submodule.copy",
   "Submodule.map",
   "Top.top",
   "DFunLike.coe",
   "Set.range"],
  "name": "LinearMap.range",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {M : Type u_5} â†’\n      {Mâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            [inst_2 : AddCommMonoid M] â†’\n              [inst_3 : AddCommMonoid Mâ‚‚] â†’\n                [inst_4 : _root_.Module R M] â†’\n                  [inst_5 : _root_.Module Râ‚‚ Mâ‚‚] â†’\n                    {Ï„â‚â‚‚ : R â†’+* Râ‚‚} â†’ [RingHomSurjective Ï„â‚â‚‚] â†’ (M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) â†’ Submodule Râ‚‚ Mâ‚‚",
  "constCategory": "Definition"},
 {"references": ["sup_le_iff"],
  "name": "max_le_iff",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b c : Î±}, max a b â‰¤ c â†” a â‰¤ c âˆ§ b â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "âˆ€ {a b : Prop}, a âˆ¨ b â†’ Â¬b â†’ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.combine",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "Eq.mpr",
   "Lean.Omega.Constraint.combine_sat",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.combine_sat'",
  "constType":
  "âˆ€ {s t : Omega.Constraint} {x y : Omega.Coeffs}, s.sat' x y = true â†’ t.sat' x y = true â†’ (s.combine t).sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Eq.trans",
   "Lean.Omega.Coeffs.ofList",
   "of_eq_true",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_0",
  "constType":
  "âˆ€ {a0 : â„¤} {t : List â„¤}, (Omega.LinearCombo.coordinate 0).eval (Omega.Coeffs.ofList (a0 :: t)) = a0",
  "constCategory": "Theorem"},
 {"references": ["mt", "LE.le", "Ne", "le_antisymm", "lt_of_le_not_ge"],
  "name": "lt_of_le_of_ne",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ a â‰  b â†’ a < b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} â†’ {Î± : outParam (Sort u_2)} â†’ {Î² : outParam (Î± â†’ Sort u_3)} â†’ [self : DFunLike F Î± Î²] â†’ F â†’ (a : Î±) â†’ Î² a",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Metric.infEDist_ne_top",
   "Eq.trans",
   "Membership.mem",
   "_private.Mathlib.Topology.MetricSpace.HausdorffDistance.0.Metric.le_infDist._simp_1_2",
   "Metric.infEDist",
   "_private.Mathlib.Topology.MetricSpace.HausdorffDistance.0.Metric.le_infDist._simp_1_3",
   "congrArg",
   "iff_self",
   "EDist.edist",
   "Dist.dist",
   "forall_congr",
   "ENNReal.toReal",
   "Eq.symm",
   "ENNReal.ofReal_le_iff_le_toReal",
   "Metric.infDist",
   "propext",
   "Set.Nonempty",
   "Set",
   "ENNReal.ofReal",
   "ENNReal",
   "of_eq_true",
   "LE.le",
   "id",
   "Eq.mpr",
   "edist_ne_top"],
  "name": "Metric.le_infDist",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±} {r : â„},\n  s.Nonempty â†’ (r â‰¤ Metric.infDist x s â†” âˆ€ â¦ƒy : Î±â¦„, y âˆˆ s â†’ r â‰¤ dist x y)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "sub_eq_zero_of_eq",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "rfl",
   "Norm.norm",
   "SphericallyCompleteSpace.Orth",
   "Mathlib.Tactic.Abel.term_add_constg",
   "SetLike.coe",
   "Int.negOfNat",
   "zero_smul",
   "norm_neg",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "norm_sub_rev",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "neg_sub",
   "dist_zero_right",
   "IsUltrametricDist.norm_add_eq_max_of_norm_ne_norm",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Max.max",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth._simp_1_1",
   "Metric.infDist_lt_iff",
   "Ne",
   "dite",
   "And.casesOn",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "Submodule.span",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "inv_smul_eq_iffâ‚€",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "Neg.neg",
   "lt_of_le_of_lt",
   "smul_sub",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth._simp_1_3",
   "Exists.casesOn",
   "zero_add",
   "Mathlib.Tactic.Ring.atom_pf",
   "norm_pos_iff",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_of_eq_of_lt",
   "congrArg",
   "neg_eq_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Metric.infDist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Metric.infDist_le_dist_of_mem",
   "Mathlib.Meta.NormNum.isInt_mul",
   "LT.lt.le",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Inv.inv",
   "eq_of_le_of_not_lt",
   "Mathlib.Tactic.Abel.term_neg",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "norm_smul",
   "ZeroMemClass.zero_mem._simp_1",
   "of_eq_true",
   "SetLike.mem_coe._simp_1",
   "ne_of_lt",
   "mul_lt_mul_iff_rightâ‚€",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.neg_congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth._simp_1_2",
   "LE.le",
   "max_eq_right"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [iud : IsUltrametricDist E] {x y : E}, (x âŸ‚[ğ•œ] y) â†’ y âŸ‚[ğ•œ] x",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "add_assoc",
   "congr",
   "HSub.hSub",
   "congrArg"],
  "name": "add_sub",
  "constType":
  "âˆ€ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + (b - c) = a + b - c",
  "constCategory": "Theorem"},
 {"references": ["LinearMap.range"],
  "name": "LinearMap.range.congr_simp",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] (f f_1 : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚), f = f_1 â†’ f.range = f_1.range",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Subtype.property", "NNReal", "OfNat.ofNat"],
  "name": "NNReal.zero_le_coe",
  "constType": "âˆ€ {q : NNReal}, 0 â‰¤ â†‘q",
  "constCategory": "Theorem"},
 {"references": ["Set", "Metric.infEDist", "ENNReal.toReal"],
  "name": "Metric.infDist",
  "constType": "{Î± : Type u} â†’ [PseudoMetricSpace Î±] â†’ Î± â†’ Set Î± â†’ â„",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView.imported",
   "Lean.MacroScopesView.review",
   "Lean.MacroScopesView.ctx",
   "cond.match_1",
   "Lean.MacroScope",
   "Lean.Name.mkStr",
   "Unit",
   "Lean.MacroScopesView.name",
   "Lean.Name.hasMacroScopes",
   "Lean.extractMacroScopes",
   "Lean.Name.appendCore",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.scopes",
   "List.foldl",
   "BEq.beq"],
  "name": "Lean.addMacroScope",
  "constType": "Name â†’ Name â†’ MacroScope â†’ Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PosMulMono.mul_le_mul_of_nonneg_left",
  "constType":
  "âˆ€ {Î± : Type u_1} {inst : Mul Î±} {inst_1 : Zero Î±} {inst_2 : Preorder Î±} [self : PosMulMono Î±] â¦ƒa : Î±â¦„,\n  0 â‰¤ a â†’ âˆ€ â¦ƒb c : Î±â¦„, b â‰¤ c â†’ a * b â‰¤ a * c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "RingHom.id",
   "LinearMap.range",
   "Membership.mem"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (Eâ‚€ : Type u_1) [inst_3 : NormedAddCommGroup Eâ‚€] [inst_4 : NormedSpace ğ•œ Eâ‚€]\n  [IsUltrametricDist Eâ‚€] (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€), IsUltrametricDist â†¥f.range",
  "constCategory": "Theorem"},
 {"references": ["Iff.trans", "exists_eq_left", "exists_congr", "And.comm"],
  "name": "exists_eq_right",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {a' : Î±}, (âˆƒ a, p a âˆ§ a = a') â†” p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range_nonempty",
   "Set",
   "csSup_le",
   "Membership.mem",
   "LE.le",
   "Set.forall_mem_range",
   "id",
   "Eq.mpr",
   "propext",
   "Set.range",
   "congrArg"],
  "name": "ciSup_le",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_4} [inst : ConditionallyCompleteLattice Î±] [Nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±},\n  (âˆ€ (x : Î¹), f x â‰¤ c) â†’ iSup f â‰¤ c",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.IsImmediate", "RingHom.id"],
  "name": "SphericallyCompleteSpace.IsImmediate.congr_simp",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : SeminormedAddCommGroup F]\n  [inst_5 : NormedSpace ğ•œ F] [inst_6 : IsUltrametricDist F] (f f_1 : E â†’â‚—áµ¢[ğ•œ] F),\n  f = f_1 â†’ SphericallyCompleteSpace.IsImmediate f = SphericallyCompleteSpace.IsImmediate f_1",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_18",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_imp", "propext"],
  "name": "Classical.not_imp._simp_2",
  "constType": "âˆ€ {a b : Prop}, (Â¬(a â†’ b)) = (a âˆ§ Â¬b)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Nonempty",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.preimage",
  "constType": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Set Î² â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "norm_pos_iff", "Norm.norm", "Ne", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.câ‚€._simp_5",
  "constType":
  "âˆ€ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, (0 < â€–aâ€–) = (a â‰  0)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "And.right",
   "Membership.mem",
   "Submodule.add_eq_sup",
   "Iff.mp",
   "Submodule.span",
   "Prod.snd",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst",
   "congrArg",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "id",
   "Eq.mpr",
   "And.left"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_14",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (t : â†¥(ğ•œ âˆ™ x + F)),\n  â†‘(â‹¯.mpr (fun z â†¦ (âŸ¨â‹¯.choose, â‹¯âŸ©, âŸ¨â‹¯.choose, â‹¯âŸ©)) t).1 + â†‘(â‹¯.mpr (fun z â†¦ (âŸ¨â‹¯.choose, â‹¯âŸ©, âŸ¨â‹¯.choose, â‹¯âŸ©)) t).2 âˆˆ\n    ğ•œ âˆ™ x + F",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Set.mem_range_self", "Set.range"],
  "name": "Set.rangeFactorization",
  "constType":
  "{Î± : Type u} â†’ {Î¹ : Sort u_1} â†’ (f : Î¹ â†’ Î±) â†’ Î¹ â†’ â†‘(Set.range f)",
  "constCategory": "Definition"},
 {"references": ["LE.le.lt_of_ne", "zero_le_one", "NeZero.ne'", "OfNat.ofNat"],
  "name": "zero_lt_one",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : PartialOrder Î±] [ZeroLEOneClass Î±] [NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_3",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references": ["Set.mem_pi", "Set", "Set.pi", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_1",
  "constType":
  "âˆ€ {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} {s : Set Î¹} {t : (i : Î¹) â†’ Set (Î± i)} {f : (i : Î¹) â†’ Î± i},\n  (f âˆˆ s.pi t) = âˆ€ i âˆˆ s, f i âˆˆ t i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "SphericallyCompleteSpace.Â«_aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___macroRules_SphericallyCompleteSpace_term_âŸ‚[_]__1Â»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "neg_zsmul",
   "Neg.neg",
   "neg_add_rev",
   "congrArg",
   "HAdd.hAdd",
   "congr",
   "HSMul.hSMul",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Mathlib.Tactic.Abel.termg",
   "add_comm"],
  "name": "Mathlib.Tactic.Abel.term_neg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (n : â„¤) (x a : Î±) (n' : â„¤) (a' : Î±),\n  -n = n' â†’ -a = a' â†’ -Mathlib.Tactic.Abel.termg n x a = Mathlib.Tactic.Abel.termg n' x a'",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Submodule.toAddSubgroup", "Iff.rfl"],
  "name": "Submodule.mem_toAddSubgroup",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x : M}, x âˆˆ p.toAddSubgroup â†” x âˆˆ p",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice"],
  "name": "Nonempty.some",
  "constType": "{Î± : Sort u_3} â†’ Nonempty Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Singleton.singleton",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "le_of_eq_of_le",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "SphericallyCompleteSpace.câ‚€._simp_2",
   "iSup",
   "Mathlib.Tactic.Linarith.add_lt_of_le_of_neg",
   "RingHom.id",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_6",
   "le_of_not_gt",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Set.range_const",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "mem_lowerBounds",
   "rfl",
   "Norm.norm",
   "Exists.choose_spec",
   "sub_neg_eq_add",
   "Set.mem_image",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_4",
   "SetLike.coe",
   "lowerBounds",
   "Int.negOfNat",
   "Top.top",
   "norm_neg",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "setOf",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_5",
   "le_of_forall_pos_sub_le",
   "HasQuotient.Quotient",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "AddSubgroup.toAddCommGroup._proof_1",
   "AddSubsemigroup.carrier",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "ZeroMemClass.zero_mem",
   "norm_sub_norm_le",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "InfSet.sInf",
   "propext",
   "lp.norm_eq_ciSup",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "ENNReal.top_ne_zero",
   "Memâ„“p.neg",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "eq_of_le_of_ge",
   "norm_nonneg",
   "And.casesOn",
   "le_refl",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "SphericallyCompleteSpace.câ‚€._proof_2",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€._proof_3",
   "Int.rawCast",
   "HMul.hMul",
   "Subtype.mk.congr_simp",
   "SphericallyCompleteSpace.câ‚€",
   "le_csInf",
   "GT.gt",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_9",
   "GE.ge",
   "quotient_norm_mk_eq",
   "zero_memâ„“p",
   "SphericallyCompleteSpace.câ‚€._proof_1",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddSubmonoid.mk.congr_simp",
   "QuotientAddGroup.mk'",
   "Submodule.mk.congr_simp",
   "csInf_le",
   "Memâ„“p.add",
   "Neg.neg",
   "And.right",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "AddSubgroupClass.toAddGroup._proof_1",
   "Submodule.toAddSubgroup",
   "add_zero",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_7",
   "Exists.casesOn",
   "Set.image",
   "Mathlib.Tactic.Ring.atom_pf",
   "lp.norm_apply_le_norm",
   "Iff.of_eq",
   "upperBounds",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "AddMemClass.add_mem",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "memâ„“p_infty",
   "AddSubmonoidClass.toAddMonoid._proof_1",
   "lp",
   "Eq.mp",
   "le_trans",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "SphericallyCompleteSpace.câ‚€._proof_4",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Memâ„“p",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "PreLp",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "exists_prop_congr",
   "SphericallyCompleteSpace.câ‚€._simp_1",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "AddSubsemigroup.mk.congr_simp",
   "ciSup_const"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_8",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E),\n  â€–{ toFun := fun x â†¦ (QuotientAddGroup.mk' (SphericallyCompleteSpace.câ‚€ ğ•œ fun x â†¦ E).toAddSubgroup) âŸ¨fun x_1 â†¦ x, â‹¯âŸ©,\n          map_add' := â‹¯, map_smul' := â‹¯ }\n        xâ€– =\n    â€–xâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "Lean.Syntax.node1",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "SphericallyCompleteSpace.Â«_aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___macroRules_SphericallyCompleteSpace_term_âŸ‚â‚˜__1Â»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "ZeroMemClass.zero_mem._simp_1",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "le_refl",
   "Filter.atTop",
   "Monotone",
   "le_trans",
   "LE.le",
   "Filter.tendsto_atTop_atTop",
   "IsDirectedOrder",
   "exists_congr",
   "forall_congr'",
   "Filter.Tendsto"],
  "name": "Filter.tendsto_atTop_atTop_iff_of_monotone",
  "constType":
  "âˆ€ {Î± : Type u_3} {Î² : Type u_4} [Nonempty Î±] [inst : Preorder Î±] [IsDirectedOrder Î±] {f : Î± â†’ Î²} [inst_2 : Preorder Î²],\n  Monotone f â†’ (Filter.Tendsto f Filter.atTop Filter.atTop â†” âˆ€ (b : Î²), âˆƒ a, b â‰¤ f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set.singleton_nonempty",
   "Set",
   "Singleton.singleton",
   "eq_true"],
  "name": "Set.singleton_nonempty._simp_1",
  "constType": "âˆ€ {Î± : Type u} (a : Î±), {a}.Nonempty = True",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_preimage",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {s : Set Î²} {a : Î±}, a âˆˆ f â»Â¹' s â†” f a âˆˆ s",
  "constCategory": "Theorem"},
 {"references":
  ["not_le",
   "Iff.trans",
   "LT.lt",
   "Not",
   "AddLeftMono",
   "Nat.cast_le_one",
   "Nat.cast",
   "Iff.not",
   "Iff.mpr",
   "LE.le",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.one_lt"],
  "name": "Nat.not_ofNat_le_one",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] [CharZero Î±]\n  {n : â„•} [inst_5 : n.AtLeastTwo], Â¬OfNat.ofNat n â‰¤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "sub_add_eq_sub_sub_swap",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "add_sub_cancel_right",
   "congrArg"],
  "name": "add_sub_add_right_eq_sub",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddGroup G] (a b c : G), a + c - (b + c) = a - b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.mk",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±],\n  (âˆ€ (c : Î±) (r : NNReal), Metric.diam (Metric.closedBall c â†‘r) = â†‘r) â†’ SphericallyCompleteSpace.IsSphericallyDense Î±",
  "constCategory": "Other"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Maximal",
   "Set",
   "RingHom.id",
   "Membership.mem",
   "inferInstance",
   "Exists.choose"],
  "name": "SphericallyCompleteSpace.instNormedSpaceSphericalCompletion",
  "constType":
  "{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u_2) â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [inst_3 : IsUltrametricDist E] â†’\n            (Eâ‚€ : Type u_3) â†’\n              [inst_4 : NormedAddCommGroup Eâ‚€] â†’\n                [inst_5 : NormedSpace ğ•œ Eâ‚€] â†’\n                  [inst_6 : IsUltrametricDist Eâ‚€] â†’\n                    [inst_7 : SphericallyCompleteSpace Eâ‚€] â†’ (f : E â†’â‚—áµ¢[ğ•œ] Eâ‚€) â†’ NormedSpace ğ•œ â†¥â‹¯.choose",
  "constCategory": "Definition"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_4",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLeftMono",
  "constType": "(M : Type u_1) â†’ [Add M] â†’ [LE M] â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Metric.ediam",
   "eq_self",
   "ENNReal",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "ENNReal.toReal",
   "Metric.ediam_subsingleton",
   "Set.Subsingleton",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Metric.diam_subsingleton",
  "constType":
  "âˆ€ {Î± : Type u} {s : Set Î±} [inst : PseudoMetricSpace Î±], s.Subsingleton â†’ Metric.diam s = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Subtype.mk.noConfusion",
   "Eq.casesOn"],
  "name": "Subtype.mk.injEq",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} (val : Î±) (property : p val) (val_1 : Î±) (property_1 : p val_1),\n  (âŸ¨val, propertyâŸ© = âŸ¨val_1, property_1âŸ©) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "LinearMap.ker",
   "Norm.norm",
   "RingHom.id",
   "LE.le",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Exists.choose",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.OrthComp",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [iud : IsUltrametricDist E] â†’\n          [inst_2 : NormedSpace ğ•œ E] â†’ (F : Submodule ğ•œ E) â†’ [SphericallyCompleteSpace â†¥F] â†’ Submodule ğ•œ E",
  "constCategory": "Definition"},
 {"references": ["Neg.neg", "Membership.mem", "neg_neg", "NegMemClass.neg_mem"],
  "name": "neg_mem_iff",
  "constType":
  "âˆ€ {S : Type u_3} {G : Type u_4} [inst : InvolutiveNeg G] {x : SetLike S G} [NegMemClass S G] {H : S} {x_1 : G},\n  -x_1 âˆˆ H â†” x_1 âˆˆ H",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.ge_iff_eq'",
   "Iff.trans",
   "norm_le_zero_iff",
   "Norm.norm",
   "LE.le",
   "norm_nonneg",
   "Iff.symm",
   "OfNat.ofNat"],
  "name": "norm_eq_zero",
  "constType":
  "âˆ€ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, â€–aâ€– = 0 â†” a = 0",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± Ã— Î² â†’ Prop}, (âˆƒ x, p x) = âˆƒ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MonadQuotation.getCurrMacroScope",
  "constType": "{m : Type â†’ Type} â†’ [self : MonadQuotation m] â†’ m MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Set.Ioc",
   "Set",
   "Set.mem_Ioc",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b x : Î±}, (x âˆˆ Set.Ioc a b) = (a < x âˆ§ x â‰¤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MacroScope",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Max.max",
   "Set",
   "Singleton.singleton",
   "Submodule.add_eq_sup",
   "Membership.mem",
   "id",
   "Submodule.span",
   "Subspace",
   "congrArg"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_8",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E), (â†¥(ğ•œ âˆ™ x + F) â†’ â†¥(ğ•œ âˆ™ x) Ã— â†¥F) = (â†¥(ğ•œ âˆ™ x âŠ” F) â†’ â†¥(ğ•œ âˆ™ x) Ã— â†¥F)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval.match_1",
   "Eq.trans",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "List.map",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "List.prod",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "congrArg",
   "Prod.fst",
   "eq_self",
   "of_eq_true",
   "mul_comm",
   "id",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons",
  "constType":
  "âˆ€ {M : Type u_1} [inst : CommGroupWithZero M] (p : â„¤ Ã— M) (l : Mathlib.Tactic.FieldSimp.NF M),\n  (p ::áµ£ l).eval = l.eval * Mathlib.Tactic.FieldSimp.zpow' p.2 p.1",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.Orth",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth"],
  "name": "SphericallyCompleteSpace.orth_symm",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [iud : IsUltrametricDist E] {x y : E}, (x âŸ‚[ğ•œ] y) â†” y âŸ‚[ğ•œ] x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "NNReal.toReal",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball._proof_1",
   "GT.gt",
   "Subtype.val",
   "Set.Countable",
   "Set.Elem",
   "Prod.fst",
   "Dense",
   "Denumerable.ofNat",
   "Not",
   "Set",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
   "NNReal",
   "Nat.brecOn",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "Metric.closedBall",
   "HasSubset.Subset",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball._proof_2",
   "Nat.below",
   "NNDist.nndist",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball.match_1",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_chain_of_ball",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    [hiud : IsUltrametricDist Î±] â†’\n      [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] â†’\n        [nemp : Nonempty Î±] â†’ [hsep : TopologicalSpace.SeparableSpace Î±] â†’ Denumerable â†‘â‹¯.choose â†’ â„• â†’ Î± Ã— NNReal",
  "constCategory": "Definition"},
 {"references":
  ["div_eq_mul_inv",
   "HDiv.hDiv",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNNRat_div.match_1_1",
   "Inv.inv",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "congrArg"],
  "name": "Mathlib.Meta.NormNum.isNNRat_div",
  "constType":
  "âˆ€ {Î± : Type u} [inst : DivisionSemiring Î±] {a b : Î±} {cn cd : â„•},\n  Mathlib.Meta.NormNum.IsNNRat (a * bâ»Â¹) cn cd â†’ Mathlib.Meta.NormNum.IsNNRat (a / b) cn cd",
  "constCategory": "Theorem"},
 {"references": ["SupSet.sSup", "Set.range"],
  "name": "iSup",
  "constType": "{Î± : Type u} â†’ {Î¹ : Sort v} â†’ [SupSet Î±] â†’ (Î¹ â†’ Î±) â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "StrictAnti", "StrictMono"],
  "name": "StrictAnti.comp_strictMono",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {Î³ : Type w} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : Preorder Î³] {g : Î² â†’ Î³}\n  {f : Î± â†’ Î²}, StrictAnti g â†’ StrictMono f â†’ StrictAnti (g âˆ˜ f)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense",
  "constType": "(Î± : Type u_1) â†’ [PseudoMetricSpace Î±] â†’ Prop",
  "constCategory": "Other"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "And.right",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "And.left"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_12",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (x : E) (F : Subspace ğ•œ E) (z : â†¥(ğ•œ âˆ™ x âŠ” F)), â‹¯.choose âˆˆ F",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach._simp_1_3",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "âˆ€ {R : Type u_2} [inst : CommRing R] {a b c d : R}, -b = c â†’ a + c = d â†’ a - b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.ndrec",
  "constType":
  "{Î± : Sort u2} â†’ {a : Î±} â†’ {motive : Î± â†’ Sort u1} â†’ motive a â†’ {b : Î±} â†’ a = b â†’ motive b",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Set.Nonempty",
   "Set",
   "Metric.nonempty_ball",
   "Metric.ball",
   "Iff.rfl",
   "EmptyCollection.emptyCollection",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "not_lt",
   "Set.not_nonempty_iff_eq_empty",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "Metric.ball_eq_empty",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {Îµ : â„}, Metric.ball x Îµ = âˆ… â†” Îµ â‰¤ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "nhds",
  "constType": "{X : Type u_3} â†’ [TopologicalSpace X] â†’ X â†’ Filter X",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "Membership.mem", "Iff.rfl"],
  "name": "mem_lowerBounds",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±} {a : Î±}, a âˆˆ lowerBounds s â†” âˆ€ x âˆˆ s, a â‰¤ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.rec",
  "constType":
  "{Î± : Type u_1} â†’\n  [inst : PseudoMetricSpace Î±] â†’\n    {motive : SphericallyCompleteSpace Î± â†’ Sort u} â†’\n      ((isSphericallyComplete :\n            âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n              (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty) â†’\n          motive â‹¯) â†’\n        (t : SphericallyCompleteSpace Î±) â†’ motive t",
  "constCategory": "Other"},
 {"references":
  ["Set.Nonempty",
   "Subtype.prop",
   "Set",
   "RingHom.id",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
   "LE.le",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} (F : Type u_3)\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ğ•œ F]\n  [inst_7 : SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) (ğ’° : Set (E â†’L[ğ•œ] F)) (hğ’° : ğ’°.Nonempty) (Îµ : â†‘ğ’° â†’ â„)\n  (a b : SphericallyCompleteSpace.PartialExtensionâœ ğ•œ E F S ğ’° hğ’° Îµ),\n  SphericallyCompleteSpace.PartialExtension.Mâœ a â‰¤ SphericallyCompleteSpace.PartialExtension.MâœÂ¹ b â†’\n    âˆ€ (x : â†¥(SphericallyCompleteSpace.PartialExtension.MâœÂ² a)), â†‘x âˆˆ SphericallyCompleteSpace.PartialExtension.MâœÂ³ b",
  "constCategory": "Theorem"},
 {"references": ["Classical.choose_spec"],
  "name": "Exists.choose_spec",
  "constType": "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} (P : âˆƒ a, p a), p P.choose",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "neg_neg",
   "congrArg"],
  "name": "sub_neg_eq_add",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : SubtractionMonoid Î±] (a b : Î±), a - -b = a + b",
  "constCategory": "Theorem"},
 {"references": ["Submodule.smul_mem'", "Membership.mem"],
  "name": "Submodule.smul_mem",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (r : R), x âˆˆ p â†’ r â€¢ x âˆˆ p",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "lt_self_iff_false", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_4",
  "constType": "âˆ€ {Î± : Type u_2} [inst : Preorder Î±] (x : Î±), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Set.Nonempty", "Set", "lowerBounds"],
  "name": "BddBelow",
  "constType": "{Î± : Type u_1} â†’ [LE Î±] â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["rfl", "Norm.norm"],
  "name": "ContinuousLinearMap.norm_def",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ğ•œ] [inst_3 : NontriviallyNormedField ğ•œâ‚‚]\n  [inst_4 : NormedSpace ğ•œ E] [inst_5 : NormedSpace ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F),\n  â€–fâ€– = sInf {c | 0 â‰¤ c âˆ§ âˆ€ (x : E), â€–f xâ€– â‰¤ c * â€–xâ€–}",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe",
   "Norm.norm",
   "Set",
   "Singleton.singleton",
   "Metric.infDist",
   "Submodule.span"],
  "name": "SphericallyCompleteSpace.Orth",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’ [inst_1 : SeminormedAddCommGroup E] â†’ [NormedSpace ğ•œ E] â†’ [IsUltrametricDist E] â†’ E â†’ E â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_15",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.not_right",
   "Set.not_nonempty_iff_eq_empty",
   "Set.Nonempty",
   "Set",
   "EmptyCollection.emptyCollection"],
  "name": "Set.nonempty_iff_ne_empty",
  "constType": "âˆ€ {Î± : Type u} {s : Set Î±}, s.Nonempty â†” s â‰  âˆ…",
  "constCategory": "Theorem"},
 {"references":
  ["Or.casesOn",
   "LT.lt",
   "Max.max",
   "Eq.trans",
   "of_eq_true",
   "LE.le",
   "eq_true",
   "le_total",
   "max_eq_left",
   "max_eq_right",
   "congrArg"],
  "name": "max_lt",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b c : Î±}, b < a â†’ c < a â†’ max b c < a",
  "constCategory": "Theorem"},
 {"references": ["not_le", "LT.lt", "Not", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, (Â¬a â‰¤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Max.max", "LT.lt.trans_le", "le_max_left"],
  "name": "lt_max_of_lt_left",
  "constType":
  "âˆ€ {Î± : Type u} [inst : LinearOrder Î±] {a b c : Î±}, a < b â†’ a < max b c",
  "constCategory": "Theorem"},
 {"references":
  ["negSucc_zsmul",
   "HAdd.hAdd",
   "Eq.trans",
   "one_nsmul",
   "Neg.neg",
   "congr_arg",
   "HSMul.hSMul",
   "OfNat.ofNat"],
  "name": "neg_one_zsmul",
  "constType": "âˆ€ {G : Type u_1} [inst : SubNegMonoid G] (x : G), -1 â€¢ x = -x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "SphericallyCompleteSpace._aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___unexpand_SphericallyCompleteSpace_SOrth_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Set", "eq_true", "OrderBot.bddBelow", "BddBelow"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_3",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [OrderBot Î±] (s : Set Î±), BddBelow s = True",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass.one_mul"],
  "name": "one_mul",
  "constType": "âˆ€ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "Int.cast_natCast",
   "Int.cast",
   "congrArg",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_isInt.match_1_1"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {a : Î±} {n : â„•},\n  Mathlib.Meta.NormNum.IsNat a n â†’ Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth",
   "Inv.inv",
   "Eq.mp",
   "inv_smul_smulâ‚€",
   "HSMul.hSMul",
   "Ne",
   "SphericallyCompleteSpace.Orth",
   "OfNat.ofNat",
   "congrArg"],
  "name": "SphericallyCompleteSpace.smul_orth_iff_orth_of_nonzero",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x y : E} {a : ğ•œ}, a â‰  0 â†’ ((x âŸ‚[ğ•œ] y) â†” a â€¢ x âŸ‚[ğ•œ] y)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.orth_symm",
   "sub_eq_add_neg",
   "mul_le_mul_iff_rightâ‚€",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "norm_zero",
   "sup_of_le_right",
   "infDist_smulâ‚€",
   "Norm.norm",
   "sub_neg_eq_add",
   "le_ciInf_set_iff",
   "SphericallyCompleteSpace.Orth",
   "Mathlib.Tactic.Abel.term_add_constg",
   "smul_submodule_eq_self",
   "SetLike.coe",
   "lowerBounds",
   "one_smul",
   "Int.negOfNat",
   "neg_one_zsmul",
   "zero_smul",
   "norm_neg",
   "Eq.mpr",
   "SphericallyCompleteSpace.orth_iff._simp_1_6",
   "one_mul",
   "setOf",
   "max_le",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "SphericallyCompleteSpace.orth_iff._simp_1_9",
   "dist_eq_norm",
   "Mathlib.Meta.NormNum.isInt_neg",
   "dist_zero",
   "congr",
   "neg_mul",
   "iInf",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "neg_smul",
   "Set",
   "one_nsmul",
   "dist_comm",
   "SphericallyCompleteSpace.orth_iff._simp_1_3",
   "not_or._simp_2",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "Ne",
   "eq_of_le_of_ge",
   "dite",
   "le_refl",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Submodule.span",
   "GE.ge",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.orth_iff._simp_1_2",
   "And.left",
   "SphericallyCompleteSpace.orth_iff._simp_1_5",
   "Neg.neg",
   "SphericallyCompleteSpace.orth_iff._simp_1_8",
   "SphericallyCompleteSpace.orth_iff._simp_1_7",
   "And.right",
   "add_zero",
   "SphericallyCompleteSpace.orth_iff._simp_1_10",
   "Exists.casesOn",
   "Set.image",
   "zero_add",
   "SphericallyCompleteSpace.orth_iff._simp_1_1",
   "sup_of_le_left",
   "norm_pos_iff",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "HSMul.hSMul",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Metric.infDist_eq_iInf",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "le_trans",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "congrArg",
   "Dist.dist",
   "le_of_eq",
   "Set.smulSet",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "Not",
   "Mathlib.Tactic.Abel.term_neg",
   "norm_smul",
   "Or.casesOn",
   "LT.lt",
   "of_eq_true",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "SphericallyCompleteSpace.orth_iff._simp_1_4"],
  "name": "SphericallyCompleteSpace.orth_iff",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [iud : IsUltrametricDist E] {x y : E},\n  (x âŸ‚[ğ•œ] y) â†” âˆ€ (Î± Î² : ğ•œ), â€–Î± â€¢ x + Î² â€¢ yâ€– = max â€–Î± â€¢ xâ€– â€–Î² â€¢ yâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.ext'_iff",
   "Set",
   "LinearMap.range",
   "Iff.rfl",
   "Function.Surjective",
   "DFunLike.coe",
   "Set.range",
   "LinearMap.coe_range",
   "congrArg",
   "Set.univ",
   "SetLike.coe",
   "Submodule.top_coe",
   "Top.top",
   "id",
   "Eq.mpr",
   "Set.range_eq_univ",
   "propext"],
  "name": "LinearMap.range_eq_top",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚}, f.range = âŠ¤ â†” Function.Surjective â‡‘f",
  "constCategory": "Theorem"},
 {"references": ["dist_eq_norm_sub"],
  "name": "dist_eq_norm",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), dist a b = â€–a - bâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "Left.neg_pos_iff",
   "neg_neg",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "le_of_forall_neg_add_le",
   "Iff.mpr",
   "LE.le",
   "HSub.hSub"],
  "name": "le_of_forall_pos_sub_le",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] [inst_1 : LinearOrder Î±] [AddLeftMono Î±] [DenselyOrdered Î±] {a b : Î±},\n  (âˆ€ (Îµ : Î±), 0 < Îµ â†’ a - Îµ â‰¤ b) â†’ a â‰¤ b",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_9",
  "constType": "âˆ€ {Î± : Type u_1} [inst : LE Î±] {x y : Î±}, (x â‰¥ y) = (y â‰¤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "one_div",
   "HMul.hMul",
   "or_true",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range._simp_1_1",
   "GT.gt",
   "Prod.fst",
   "congrArg",
   "HDiv.hDiv",
   "not_false_eq_true",
   "congr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range._simp_1_2",
   "Not",
   "Inv.inv",
   "div_self",
   "Exists.choose_spec",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius",
   "NNReal",
   "Prod.snd",
   "Exists.choose",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range._simp_1_4",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "zero_add",
   "mul_lt_mul_iff_rightâ‚€",
   "of_eq_true",
   "CharP.cast_eq_zero",
   "Iff.mpr",
   "NNDist.nndist",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range._simp_1_6",
   "id",
   "add_self_div_two",
   "Eq.mpr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range._simp_1_3",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range._simp_1_5",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "mul_div_assoc"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.funk_radius_range",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [hÎ± : SphericallyCompleteSpace.IsSphericallyDense Î±] [nemp : Nonempty Î±]\n  (n : â„•), SphericallyCompleteSpace.funk_radiusâœ Î± n > SphericallyCompleteSpace.funk_radiusâœÂ¹ Î± 0 / 2",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_2",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EStateM",
  "constType": "Type u â†’ Type u â†’ Type u â†’ Type u",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Dist.dist", "setOf"],
  "name": "Metric.ball",
  "constType": "{Î± : Type u} â†’ [PseudoMetricSpace Î±] â†’ Î± â†’ â„ â†’ Set Î±",
  "constCategory": "Definition"},
 {"references": ["String.toRawSubstring"],
  "name": "String.toRawSubstring'",
  "constType": "String â†’ Substring.Raw",
  "constCategory": "Definition"},
 {"references": ["HasSubset.Subset", "Set", "Membership.mem"],
  "name": "Set.mem_of_mem_of_subset",
  "constType": "âˆ€ {Î± : Type u} {x : Î±} {s t : Set Î±}, x âˆˆ s â†’ s âŠ† t â†’ x âˆˆ t",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "False.elim",
   "_private.Init.Data.Nat.Basic.0.Nat.lt_or_gt_of_ne.match_1_1",
   "Nat.lt_trichotomy",
   "Ne",
   "GT.gt"],
  "name": "Nat.lt_or_gt_of_ne",
  "constType": "âˆ€ {a b : â„•}, a â‰  b â†’ a < b âˆ¨ a > b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddLeftMono", "rel_iff_cov", "LE.le", "AddLeftReflectLE"],
  "name": "add_le_add_iff_left",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Add Î±] [inst_1 : LE Î±] [AddLeftMono Î±] [AddLeftReflectLE Î±] (a : Î±) {b c : Î±},\n  a + b â‰¤ a + c â†” b â‰¤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set.Nonempty",
   "Set",
   "Antitone",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter"],
  "name": "SphericallyCompleteSpace.mk._flat_ctor",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : PseudoMetricSpace Î±],\n  (âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n      (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty) â†’\n    SphericallyCompleteSpace Î±",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "id",
   "Classical.not_forall._simp_1",
   "eq_iff_iff._simp_1",
   "iff_false"],
  "name": "Lean.Grind.of_forall_eq_false",
  "constType":
  "âˆ€ (Î± : Sort u) (p : Î± â†’ Prop), (âˆ€ (x : Î±), p x) = False â†’ âˆƒ x, Â¬p x",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Inv.inv", "inv_pos", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_4",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a : Gâ‚€},\n  (0 < aâ»Â¹) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Eq.trans",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "Submodule.span",
   "sub_zero",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "sub_eq_add_neg",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Ring.sub_pf",
   "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth._simp_1_3",
   "Norm.norm",
   "Neg.neg",
   "sub_neg_eq_add",
   "SphericallyCompleteSpace.Orth",
   "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth._simp_1_1",
   "Exists.casesOn",
   "Mathlib.Tactic.Ring.atom_pf",
   "SetLike.coe",
   "Nat.cast_zero",
   "Iff.mpr",
   "HSMul.hSMul",
   "Classical.byContradiction",
   "Int.negOfNat",
   "id",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth._simp_1_2",
   "dist_eq_norm",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "lt_of_le_of_ne",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Dist.dist",
   "Metric.infDist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Metric.infDist_le_dist_of_mem",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "neg_smul",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Metric.infDist_lt_iff",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.orth_iff_birkhoff_james_orth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [iud : IsUltrametricDist E] (x y : E), (x âŸ‚[ğ•œ] y) â†” âˆ€ (c : ğ•œ), â€–xâ€– â‰¤ â€–x + c â€¢ yâ€–",
  "constCategory": "Theorem"},
 {"references":
  ["csInf_le",
   "Set.Nonempty",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "InfSet.sInf",
   "le_csInf",
   "BddBelow"],
  "name": "csInf_le_csInf",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLattice Î±] {s t : Set Î±},\n  BddBelow t â†’ s.Nonempty â†’ s âŠ† t â†’ sInf t â‰¤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_4",
  "constType": "âˆ€ {q : NNReal}, (0 â‰¤ â†‘q) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PadicAlgCl", "UniformSpace.Completion", "NNReal", "Nat.Prime"],
  "name": "PadicComplex",
  "constType": "(p : â„•) â†’ [hp : Fact (Nat.Prime p)] â†’ Type",
  "constCategory": "Definition"},
 {"references": ["InfSet.sInf", "Set.range"],
  "name": "iInf",
  "constType": "{Î± : Type u} â†’ {Î¹ : Sort v} â†’ [InfSet Î±] â†’ (Î¹ â†’ Î±) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.ker",
   "Membership.mem",
   "DFunLike.coe",
   "OfNat.ofNat",
   "propext",
   "LinearMap.mem_ker"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_1",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_7} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {y : M}, (y âˆˆ f.ker) = (f y = 0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MonadQuotation.getContext",
  "constType": "{m : Type â†’ Type} â†’ [self : MonadQuotation m] â†’ m Name",
  "constCategory": "Definition"},
 {"references": ["not_le", "LT.lt", "Not", "LE.le", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_9",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, (Â¬a â‰¤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "propext",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ a = b",
  "constCategory": "Axiom"},
 {"references": ["LT.lt", "eq_true", "zero_lt_one", "OfNat.ofNat"],
  "name": "zero_lt_one._simp_1",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : One Î±] [inst_2 : PartialOrder Î±] [ZeroLEOneClass Î±] [NeZero 1],\n  (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Submodule.mem_bot", "Bot.bot", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_2",
  "constType":
  "âˆ€ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x âˆˆ âŠ¥) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "AddLeftMono",
   "Nat.cast",
   "Eq.trans",
   "LT.lt.trans_le",
   "zero_lt_one",
   "Nat.mono_cast",
   "Eq.casesOn",
   "OfNat.ofNat",
   "congrArg",
   "Nat.cast_add",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Monotone.imp",
   "LE.le",
   "eq_of_heq",
   "Eq.symm",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.le_add_left._simp_1"],
  "name": "Nat.cast_add_one_pos",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddMonoidWithOne Î±] [inst_1 : PartialOrder Î±] [AddLeftMono Î±] [ZeroLEOneClass Î±] [NeZero 1]\n  (n : â„•), 0 < â†‘n + 1",
  "constCategory": "Theorem"},
 {"references": ["Array.mkArray2", "Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.node2",
  "constType": "SourceInfo â†’ SyntaxNodeKind â†’ Syntax â†’ Syntax â†’ Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "LE.le",
   "Submodule.span_singleton_le_iff_mem",
   "Submodule.span",
   "propext"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_3",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (m : M)\n  (p : Submodule R M), (R âˆ™ m â‰¤ p) = (m âˆˆ p)",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_8",
  "constType":
  "âˆ€ {Î± : Sort u_2} {Î² : Sort u_1} {f : Î± â†’ Î²} {p : Î² â†’ Prop}, (âˆ€ (b : Î²) (a : Î±), f a = b â†’ p b) = âˆ€ (a : Î±), p (f a)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Set", "Membership.mem", "Iff.rfl"],
  "name": "AddSubsemigroup.mem_mk",
  "constType":
  "âˆ€ {M : Type u_1} [inst : Add M] {s : Set M} {x : M} (h_add : âˆ€ {a b : M}, a âˆˆ s â†’ b âˆˆ s â†’ a + b âˆˆ s),\n  x âˆˆ { carrier := s, add_mem' := h_add } â†” x âˆˆ s",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "ite",
  "constType": "{Î± : Sort u} â†’ (c : Prop) â†’ [h : Decidable c] â†’ Î± â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "ENNReal",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "Membership.mem",
   "Metric.infEDist",
   "ENNReal.toReal",
   "Metric.infEDist_zero_of_mem",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Metric.infDist_zero_of_mem",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s : Set Î±} {x : Î±}, x âˆˆ s â†’ Metric.infDist x s = 0",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.trichotomy",
   "Eq.trans",
   "SummationFilter.unconditional",
   "Memâ„“p.summable",
   "eq_true",
   "memâ„“p_zero",
   "Set.range",
   "congrArg",
   "Memâ„“p.bddAbove",
   "Memâ„“p",
   "funext",
   "memâ„“p_gen",
   "ENNReal.toReal",
   "inv_eq_one._simp_2",
   "Eq.symm",
   "Eq.ndrec",
   "Not",
   "Norm.norm",
   "Neg.neg",
   "HPow.hPow",
   "BddAbove",
   "OfNat.ofNat",
   "Summable",
   "LT.lt",
   "Or.casesOn",
   "ENNReal",
   "of_eq_true",
   "id",
   "Top.top",
   "norm_neg",
   "Ne",
   "Eq.mpr",
   "Set.Finite",
   "memâ„“p_infty",
   "Memâ„“p.finite_dsupport",
   "setOf"],
  "name": "Memâ„“p.neg",
  "constType":
  "âˆ€ {Î± : Type u_3} {E : Î± â†’ Type u_4} {p : ENNReal} [inst : (i : Î±) â†’ NormedAddCommGroup (E i)] {f : (i : Î±) â†’ E i},\n  Memâ„“p f p â†’ Memâ„“p (-f) p",
  "constCategory": "Theorem"},
 {"references":
  ["dist_eq_norm", "Norm.norm", "Dist.dist", "HSub.hSub", "Eq.symm"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_22",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), â€–a - bâ€– = dist a b",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Subsingleton",
  "constType": "{Î± : Type u} â†’ Set Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Nat.cast", "Mathlib.Tactic.Zify.natCast_lt", "propext"],
  "name": "Mathlib.Tactic.Zify.natCast_lt._simp_1",
  "constType": "âˆ€ (a b : â„•), (a < b) = (â†‘a < â†‘b)",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Dist.dist",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "sub_zero",
   "dist_eq_norm_sub",
   "OfNat.ofNat",
   "congrArg"],
  "name": "dist_zero_right",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), dist a 0 = â€–aâ€–",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OfNat.ofNat",
  "constType": "{Î± : Type u} â†’ (x : â„•) â†’ [self : OfNat Î± x] â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAdd.hAdd",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ {Î³ : outParam (Type w)} â†’ [self : HAdd Î± Î² Î³] â†’ Î± â†’ Î² â†’ Î³",
  "constCategory": "Definition"},
 {"references": ["Dist.dist", "LE.le", "setOf"],
  "name": "Metric.closedBall",
  "constType": "{Î± : Type u} â†’ [PseudoMetricSpace Î±] â†’ Î± â†’ â„ â†’ Set Î±",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.coe_mono",
   "LinearMap.range",
   "LinearMap.comp",
   "DFunLike.coe",
   "Set.range_comp_subset_range"],
  "name": "LinearMap.range_comp_le_range",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {Râ‚ƒ : Type u_3} {M : Type u_5} {Mâ‚‚ : Type u_6} {Mâ‚ƒ : Type u_7} [inst : Semiring R]\n  [inst_1 : Semiring Râ‚‚] [inst_2 : Semiring Râ‚ƒ] [inst_3 : AddCommMonoid M] [inst_4 : AddCommMonoid Mâ‚‚]\n  [inst_5 : AddCommMonoid Mâ‚ƒ] [inst_6 : _root_.Module R M] [inst_7 : _root_.Module Râ‚‚ Mâ‚‚] [inst_8 : _root_.Module Râ‚ƒ Mâ‚ƒ]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {Ï„â‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ï„â‚â‚ƒ : R â†’+* Râ‚ƒ} [inst_9 : RingHomCompTriple Ï„â‚â‚‚ Ï„â‚‚â‚ƒ Ï„â‚â‚ƒ]\n  [inst_10 : RingHomSurjective Ï„â‚‚â‚ƒ] [inst_11 : RingHomSurjective Ï„â‚â‚ƒ] (f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) (g : Mâ‚‚ â†’â‚›â‚—[Ï„â‚‚â‚ƒ] Mâ‚ƒ),\n  (g âˆ˜â‚›â‚— f).range â‰¤ g.range",
  "constCategory": "Theorem"},
 {"references": ["Nat.le_trans", "Nat.le_succ", "LE.le"],
  "name": "Nat.le_of_succ_le",
  "constType": "âˆ€ {n m : â„•}, n.succ â‰¤ m â†’ n â‰¤ m",
  "constCategory": "Theorem"},
 {"references": ["Iff.trans", "Max.max", "sup_eq_left", "eq_comm", "LE.le"],
  "name": "left_eq_sup",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, a = a âŠ” b â†” b â‰¤ a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "IsChain",
   "Subtype.ext_iff",
   "Set",
   "Membership.mem",
   "zorn_le",
   "Iff.mp",
   "_private.Mathlib.Order.Zorn.0.zorn_leâ‚€.match_1_7",
   "Subtype.val",
   "BddAbove",
   "Set.Elem",
   "Exists.casesOn",
   "_private.Mathlib.Order.Zorn.0.zorn_leâ‚€.match_1_5",
   "_private.Mathlib.Order.Zorn.0.zorn_leâ‚€.match_1_3",
   "_private.Mathlib.Order.Zorn.0.zorn_leâ‚€.match_1_1",
   "Set.image",
   "Maximal",
   "HasSubset.Subset",
   "upperBounds",
   "LE.le",
   "IsMax",
   "Ne",
   "Eq.ndrec",
   "And.casesOn"],
  "name": "zorn_leâ‚€",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (s : Set Î±),\n  (âˆ€ c âŠ† s, IsChain (fun x1 x2 â†¦ x1 â‰¤ x2) c â†’ âˆƒ ub âˆˆ s, âˆ€ z âˆˆ c, z â‰¤ ub) â†’ âˆƒ m, Maximal (fun x â†¦ x âˆˆ s) m",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.Â«term_âŸ‚â‚›_Â»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Neg.neg", "Iff.mpr", "OfNat.ofNat", "neg_neg_iff_pos"],
  "name": "neg_neg_of_pos",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddCommGroup Î±] [inst_1 : PartialOrder Î±] [IsOrderedAddMonoid Î±] {a : Î±}, 0 < a â†’ -a < 0",
  "constCategory": "Theorem"},
 {"references": ["Set", "isClosed_closure", "closure", "IsClosed.closure_eq"],
  "name": "closure_eq_iff_isClosed",
  "constType":
  "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, closure s = s â†” IsClosed s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} â†’ {motive : a âˆ§ b â†’ Sort u} â†’ (t : a âˆ§ b) â†’ ((left : a) â†’ (right : b) â†’ motive â‹¯) â†’ motive t",
  "constCategory": "Definition"},
 {"references":
  ["NNReal.coe_le_coe", "LE.le", "NNReal", "NNReal.toReal", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_10",
  "constType": "âˆ€ {râ‚ râ‚‚ : NNReal}, (â†‘râ‚ â‰¤ â†‘râ‚‚) = (râ‚ â‰¤ râ‚‚)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Inter.inter", "Membership.mem", "Set.mem_inter_iff", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} (x : Î±) (a b : Set Î±), (x âˆˆ a âˆ© b) = (x âˆˆ a âˆ§ x âˆˆ b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "zero_add",
   "Nat.cast",
   "Nat.cast_zero",
   "id",
   "Eq.mpr",
   "Nat.cast_succ",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.cast_one",
  "constType": "âˆ€ {R : Type u_1} [inst : AddMonoidWithOne R], â†‘1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.câ‚€",
   "Membership.mem.out",
   "Subtype.val",
   "DFunLike.coe",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "SphericallyCompleteSpace.IsImmediate",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "HSMul.hSMul",
   "LE.le",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_5",
  "constType":
  "âˆ€ (ğ•œ : Type u_2) [inst : NontriviallyNormedField ğ•œ] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] (x : ğ•œ) (x_1 : E),\n  âŸ¨(SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) (x â€¢ x_1), â‹¯âŸ© =\n    âŸ¨(SphericallyCompleteSpace.sphericallyCompleteExtension ğ•œ E) (x â€¢ x_1), â‹¯âŸ©",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_refl"],
  "name": "le_refl",
  "constType": "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] (a : Î±), a â‰¤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_1",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] (i : â„•), IsBoundedSMul ğ•œ E",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "NegMemClass.neg_mem"],
  "name": "Submodule.neg_mem",
  "constType":
  "âˆ€ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x : M}, x âˆˆ p â†’ -x âˆˆ p",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "And.left"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (M : â†¥(D + ğ•œ âˆ™ a)) (this : âˆƒ y âˆˆ D, âˆƒ z âˆˆ ğ•œ âˆ™ a, y + z = â†‘M),\n  this.choose âˆˆ D",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Subtype.mk.injEq",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "forall_congr",
   "Membership.mem",
   "Set.mem_range_self",
   "Set.range",
   "congrArg"],
  "name": "Set.rangeFactorization_injective",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±}, Function.Injective (Set.rangeFactorization f) â†” Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "le_refl",
   "sub_add_cancel",
   "Eq.trans",
   "Membership.mem",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._proof_1_4",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._simp_1_3",
   "SphericallyCompleteSpace.câ‚€",
   "le_max_of_le_right",
   "sub_add_sub_cancel",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "not_false_eq_true",
   "False.elim",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "StrictAnti.antitone",
   "HSub.hSub",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._proof_1_5",
   "norm_zero",
   "add_comm",
   "QuotientAddGroup.mk'",
   "sub_self",
   "Norm.norm",
   "Neg.neg",
   "And.right",
   "NNReal",
   "Nat.recAux",
   "Submodule.toAddSubgroup",
   "Mathlib.Tactic.Abel.term_add_constg",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.mk_eq_and_norm_sub_lt",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._simp_1_1",
   "SphericallyCompleteSpace.câ‚€._simp_4",
   "Decidable.byContradiction",
   "zero_add",
   "lp.norm_apply_le_norm",
   "eq_false",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Antitone",
   "Int.negOfNat",
   "Top.top",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "max_le",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "IsUltrametricDist.norm_add_le_max",
   "HasQuotient.Quotient",
   "Eq.mp",
   "lp",
   "max_le_max",
   "Mathlib.Tactic.Abel.unfold_sub",
   "le_trans",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_neg",
   "DFunLike.coe",
   "congrArg",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
   "not_true_eq_false",
   "Mathlib.Tactic.Abel.termg",
   "Not",
   "PreLp",
   "Set",
   "ENNReal.top_ne_zero",
   "Nat.zero_le",
   "Mathlib.Tactic.Abel.term_neg",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "StrictAnti",
   "Metric.closedBall",
   "Max.max",
   "ENNReal",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "QuotientAddGroup.mk",
   "inferInstance",
   "dite"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] (E : â„• â†’ Type u_2) [inst_1 : (i : â„•) â†’ NormedAddCommGroup (E i)]\n  [inst_2 : (i : â„•) â†’ NormedSpace ğ•œ (E i)] [iiud : âˆ€ (i : â„•), IsUltrametricDist (E i)]\n  â¦ƒc : â„• â†’ â†¥(lp E âŠ¤) â§¸ SphericallyCompleteSpace.câ‚€ ğ•œ Eâ¦„ â¦ƒr : â„• â†’ NNRealâ¦„ (hsr : StrictAnti r)\n  (hanti : Antitone fun i â†¦ Metric.closedBall (c i) â†‘(r i)) (n : â„•),\n  â€–â†‘â†‘(SphericallyCompleteSpace.quotient_mk_sectionâœ E hsr hanti n) nâ€– â‰¤\n    max â€–â†‘(SphericallyCompleteSpace.quotient_mk_sectionâœÂ¹ E hsr hanti 0)â€–\n      (max â€–â†‘(SphericallyCompleteSpace.quotient_mk_sectionâœÂ² E hsr hanti 1)â€– â†‘(r 0))",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Iff.mp",
  "constType": "âˆ€ {a b : Prop}, (a â†” b) â†’ a â†’ b",
  "constCategory": "Theorem"},
 {"references": ["Int.cast"],
  "name": "Int.rawCast",
  "constType": "{Î± : Type u} â†’ [Ring Î±] â†’ â„¤ â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "add_sub_assoc",
   "sub_add_cancel",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "congrArg"],
  "name": "sub_add_sub_cancel",
  "constType":
  "âˆ€ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - b + (b - c) = a - c",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat.cast",
   "Unit",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_eq.match_1_1"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "âˆ€ {Î± : Type u} [inst : AddMonoidWithOne Î±] {n : â„•} {a a' : Î±}, Mathlib.Meta.NormNum.IsNat a n â†’ â†‘n = a' â†’ a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "AddSubmonoid.mem_mk",
   "propext",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_4",
  "constType":
  "âˆ€ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubsemigroup M} {x : M} (h_zero : 0 âˆˆ s.carrier),\n  (x âˆˆ { toAddSubsemigroup := s, zero_mem' := h_zero }) = (x âˆˆ s)",
  "constCategory": "Theorem"},
 {"references": ["eq_self", "Eq.trans", "of_eq_true", "Neg.neg", "congrArg"],
  "name": "Mathlib.Tactic.Abel.subst_into_negg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (a ta t : Î±), a = ta â†’ -ta = t â†’ -a = t",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x y : Î±} {Îµ : â„}, (y âˆˆ Metric.closedBall x Îµ) = (dist y x â‰¤ Îµ)",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "Module.Basis.linearIndependent",
   "Eq.trans",
   "disjoint_bot_right._simp_1",
   "Submodule.map",
   "Membership.mem",
   "Submodule.span",
   "Module.Basis.ofVectorSpace",
   "LinearIndependent.linearIndepOn_id",
   "Subtype.val",
   "Set.Elem",
   "Submodule.subtype",
   "Module.finrank",
   "RingHom.id",
   "Disjoint",
   "Set.subset_univ",
   "Eq.symm",
   "LinearIndepOn",
   "rfl",
   "LinearMap.ker",
   "Set.card_image_of_injective",
   "Submodule.coe_subtype",
   "LinearIndepOn.subset_extend",
   "Bot.bot",
   "Submodule.range_subtype",
   "Set.image",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "Set.Finite.fintype",
   "Submodule.ker_subtype",
   "FiniteDimensional",
   "Eq.mp",
   "LinearMap.range",
   "Submodule.map_top",
   "Module.Basis.coe_extend",
   "LinearIndepOn.image",
   "Module.Basis.extend",
   "Set.image_congr",
   "DFunLike.coe",
   "Set.range",
   "LinearIndependent.set_finite_of_isNoetherian",
   "congrArg",
   "LinearIndepOn.extend",
   "Fintype.card",
   "congr",
   "Module.finrank_eq_card_basis",
   "Submodule.span_image",
   "Module.Basis.coe_ofVectorSpace",
   "Module.Basis.span_eq",
   "Set",
   "Subtype.range_coe_subtype",
   "Set.univ",
   "Subtype.range_coe",
   "Subtype.coe_injective",
   "of_eq_true",
   "Module.Basis.ofVectorSpaceIndex",
   "Set.eq_of_subset_of_card_le",
   "LE.le"],
  "name": "Submodule.eq_top_of_finrank_eq",
  "constType":
  "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]\n  [FiniteDimensional K V] {S : Submodule K V}, Module.finrank K â†¥S = Module.finrank K V â†’ S = âŠ¤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DenselyNormedField.lt_norm_lt",
  "constType":
  "âˆ€ {Î± : Type u_5} [self : DenselyNormedField Î±] (x y : â„), 0 â‰¤ x â†’ x < y â†’ âˆƒ a, x < â€–aâ€– âˆ§ â€–aâ€– < y",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_4",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "AddSubmonoid.mk.congr_simp",
  "constType":
  "âˆ€ {M : Type u_3} [inst : AddZeroClass M] (toAddSubsemigroup toAddSubsemigroup_1 : AddSubsemigroup M)\n  (e_toAddSubsemigroup : toAddSubsemigroup = toAddSubsemigroup_1) (zero_mem' : 0 âˆˆ toAddSubsemigroup.carrier),\n  { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' } =\n    { toAddSubsemigroup := toAddSubsemigroup_1, zero_mem' := â‹¯ }",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_8",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 â‰¤ â€–aâ€–) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.substr",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "Eq.symm",
   "congrArg"],
  "name": "forall_prop_domain_congr",
  "constType":
  "âˆ€ {pâ‚ pâ‚‚ : Prop} {qâ‚ : pâ‚ â†’ Prop} {qâ‚‚ : pâ‚‚ â†’ Prop} (hâ‚ : pâ‚ = pâ‚‚),\n  (âˆ€ (a : pâ‚‚), qâ‚ â‹¯ = qâ‚‚ a) â†’ (âˆ€ (a : pâ‚), qâ‚ a) = âˆ€ (a : pâ‚‚), qâ‚‚ a",
  "constCategory": "Theorem"},
 {"references": ["csInf_le", "Set", "Membership.mem", "OrderBot.bddBelow"],
  "name": "csInf_le'",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Î±] {s : Set Î±} {a : Î±}, a âˆˆ s â†’ sInf s â‰¤ a",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_3",
  "constType": "âˆ€ {a b c : Prop}, (a âˆ§ b â†’ c) = (a â†’ b â†’ c)",
  "constCategory": "Theorem"},
 {"references": ["LinearIsometry.toLinearMap", "LinearIsometry.continuous"],
  "name": "LinearIsometry.toContinuousLinearMap",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              [inst_2 : SeminormedAddCommGroup E] â†’\n                [inst_3 : SeminormedAddCommGroup Eâ‚‚] â†’\n                  [inst_4 : _root_.Module R E] â†’ [inst_5 : _root_.Module Râ‚‚ Eâ‚‚] â†’ (E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â†’SL[Ïƒâ‚â‚‚] Eâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_3",
   "Subtype.val",
   "Set.Elem",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_7",
   "HDiv.hDiv",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_6",
   "InfSet.sInf",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_4",
   "Set",
   "NNReal",
   "Nat.brecOn",
   "Prod.snd",
   "Exists.choose",
   "HPow.hPow",
   "OfNat.ofNat",
   "Nonempty.some",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_2",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.match_1",
   "Min.min",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_1",
   "Nat.below",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_5",
   "setOf"],
  "name":
  "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
  "constType":
  "{Î± : Type u_1} â†’\n  [PseudoMetricSpace Î±] â†’\n    {S : Set (Î± Ã— NNReal)} â†’ [hS : Nonempty â†‘S] â†’ (âˆ€ w âˆˆ S, sInf {x | âˆƒ w âˆˆ S, w.2 = x} < w.2) â†’ â„• â†’ â†‘S",
  "constCategory": "Definition"},
 {"references":
  ["IsChain",
   "Set.Nonempty",
   "Set",
   "le_trans",
   "LE.le",
   "exists_maximal_of_nonempty_chains_bounded",
   "BddAbove"],
  "name": "zorn_le_nonempty",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [Nonempty Î±],\n  (âˆ€ (c : Set Î±), IsChain (fun x1 x2 â†¦ x1 â‰¤ x2) c â†’ c.Nonempty â†’ BddAbove c) â†’ âˆƒ m, IsMax m",
  "constCategory": "Theorem"},
 {"references":
  ["le_max_right", "Max.max", "eq_max", "LE.le", "le_max_left", "max_le"],
  "name": "max_comm",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] (a b : Î±), max a b = max b a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Neg.neg",
  "constType": "{Î± : Type u} â†’ [self : Neg Î±] â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Set.iInter",
   "Membership.mem.out",
   "sub_zero",
   "Left.mul_nonneg",
   "Subtype.val",
   "Set.Elem",
   "sub_eq_add_neg",
   "RingHom.id",
   "Eq.symm",
   "Eq.ndrec",
   "Set.iInter_congr_Prop",
   "rfl",
   "Exists.choose_spec",
   "Norm.norm",
   "NNReal",
   "Set.Nonempty.some_mem",
   "Set.iInter_coe_set",
   "Prod.snd",
   "Mathlib.Tactic.Abel.term_add_constg",
   "Classical.em",
   "map_add",
   "Int.negOfNat",
   "mul_max_of_nonneg",
   "norm_neg",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "max_le",
   "sup_le_sup_right",
   "dist_eq_norm",
   "le_sup_iff",
   "Mathlib.Meta.NormNum.isInt_neg",
   "map_sub",
   "Prod.fst",
   "mul_le_mul_of_nonneg_right",
   "congr",
   "Subtype.property",
   "map_zero",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "lt_of_not_ge",
   "dist_comm",
   "Set",
   "mul_nonneg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Metric.closedBall",
   "eq_self",
   "Max.max",
   "max_le_max_left",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_3",
   "norm_nonneg",
   "max_assoc",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_1",
   "le_refl",
   "Inter.inter",
   "Membership.mem",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "max_eq_left",
   "max_comm",
   "Neg.neg",
   "mul_le_mul_of_nonneg_left",
   "Set.inter_comm",
   "Set.Nonempty.some",
   "add_zero",
   "Exists.casesOn",
   "zero_add",
   "Iff.of_eq",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Metric.mem_closedBall",
   "Mathlib.Tactic.Abel.unfold_sub",
   "max_le_max",
   "le_trans",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_2",
   "NNReal.toReal",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_add",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_5",
   "Subtype.prop",
   "Dist.dist",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_4",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "ContinuousLinearMap.le_opNorm",
   "Exists.choose",
   "Mathlib.Tactic.Abel.term_neg",
   "Submodule.sub_mem_iff_left",
   "exists_prop_congr",
   "Or.casesOn",
   "LT.lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "add_sub_add_right_eq_sub"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E},\n  a âˆ‰ D â†’\n    âˆ€ {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ğ•œ F]\n      [hsc : SphericallyCompleteSpace F] (S : â†¥D â†’L[ğ•œ] F) {ğ’° : Set (E â†’L[ğ•œ] F)},\n      ğ’°.Nonempty â†’\n        âˆ€ {Îµ : â†‘ğ’° â†’ â„},\n          (âˆ€ (T : â†‘ğ’°), 0 < Îµ T) â†’\n            (âˆ€ (U V : â†‘ğ’°), â€–â†‘U - â†‘Vâ€– â‰¤ max (Îµ U) (Îµ V)) â†’\n              (âˆ€ (U : â†‘ğ’°) (x : â†¥D), â€–S x - â†‘U â†‘xâ€– â‰¤ Îµ U * â€–xâ€–) â†’\n                âˆƒ z0, âˆ€ (x : â†¥D) (U : â†‘ğ’°), â€–S x + z0 - â†‘U (â†‘x + a)â€– â‰¤ Îµ U * â€–â†‘x + aâ€–",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_1",
  "constType":
  "âˆ€ {Î± : Sort u} {p : Î± â†’ Prop} {q : { a // p a } â†’ Prop}, (âˆ€ (x : { a // p a }), q x) = âˆ€ (a : Î±) (b : p a), q âŸ¨a, bâŸ©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "ContinuousLinearMap.id",
   "forall_eq._simp_1",
   "Eq.trans",
   "Eq.mp",
   "Singleton.singleton",
   "Membership.mem",
   "HMul.hMul",
   "sub_zero",
   "Subtype.val",
   "DFunLike.coe",
   "Set.Elem",
   "congrArg",
   "SphericallyCompleteSpace.exists_extension_opNorm_le",
   "RingHom.id",
   "congr",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_1",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_2",
   "norm_zero",
   "forall_prop_domain_congr",
   "zero_lt_one._simp_1",
   "le_refl._simp_1",
   "Set.Nonempty",
   "Norm.norm",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_3",
   "Set",
   "zero_le_one._simp_1",
   "OfNat.ofNat",
   "Exists.casesOn",
   "LT.lt",
   "eq_self",
   "implies_true",
   "Max.max",
   "of_eq_true",
   "max_self",
   "LE.le",
   "Subtype.forall._simp_1",
   "Set.singleton_nonempty._simp_1",
   "Set.mem_singleton_iff._simp_1",
   "one_mul",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [SphericallyCompleteSpace â†¥F],\n  âˆƒ T, (âˆ€ a âˆˆ F, â†‘(T a) = a) âˆ§ â€–Tâ€– â‰¤ 1",
  "constCategory": "Theorem"},
 {"references": ["Not", "False.elim", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "âˆ€ {p : Prop} [dec : Decidable p], (Â¬p â†’ False) â†’ p",
  "constCategory": "Theorem"},
 {"references":
  ["Inv.inv",
   "inv_mul_le_iffâ‚€",
   "HMul.hMul",
   "mul_one",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "inv_le_iff_one_le_mulâ‚€'",
  "constType":
  "âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] [inst_1 : PartialOrder Gâ‚€] [PosMulReflectLT Gâ‚€] {a b : Gâ‚€},\n  0 < a â†’ (aâ»Â¹ â‰¤ b â†” 1 â‰¤ a * b)",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "Maximal",
  "constType": "{Î± : Type u_1} â†’ [LE Î±] â†’ (Î± â†’ Prop) â†’ Î± â†’ Prop",
  "constCategory": "Definition"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{Î± : Type u} â†’ [Ring Î±] â†’ AddMonoidWithOne Î±",
  "constCategory": "Definition"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective._proof_2",
   "DFunLike.coe",
   "Function.Surjective",
   "LinearIsometryEquiv.ofSurjective._proof_1",
   "LinearEquiv.ofBijective"],
  "name": "LinearIsometryEquiv.ofSurjective",
  "constType":
  "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {Eâ‚‚ : Type u_6} â†’\n      {F : Type u_9} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n                [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n                  [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                    [inst_4 : SeminormedAddCommGroup Eâ‚‚] â†’\n                      [inst_5 : _root_.Module Râ‚‚ Eâ‚‚] â†’\n                        [inst_6 : NormedAddCommGroup F] â†’\n                          [inst_7 : _root_.Module R F] â†’ (f : F â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ Function.Surjective â‡‘f â†’ F â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "NNReal",
   "Inter.inter",
   "Iff.mp",
   "NNReal.toReal",
   "List.tfae_of_cycle",
   "Prod.snd",
   "Set.iInter",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Metric.closedBall",
   "StrictAnti",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius",
   "Iff.mpr",
   "Antitone",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteSpace_equiv",
  "constType":
  "âˆ€ (Î± : Type u_1) [inst : PseudoMetricSpace Î±] [iud : IsUltrametricDist Î±],\n  [SphericallyCompleteSpace Î±,\n      âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n        Antitone ri â†’\n          (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty,\n      âˆ€ â¦ƒci : â„• â†’ Î±â¦„ â¦ƒri : â„• â†’ NNRealâ¦„,\n        StrictAnti ri â†’\n          (Antitone fun i â†¦ Metric.closedBall (ci i) â†‘(ri i)) â†’ (â‹‚ i, Metric.closedBall (ci i) â†‘(ri i)).Nonempty,\n      âˆ€ (S : Set (Î± Ã— NNReal)),\n        S.Nonempty â†’\n          (âˆ€ (w1 w2 : â†‘S), (Metric.closedBall (â†‘w1).1 â†‘(â†‘w1).2 âˆ© Metric.closedBall (â†‘w2).1 â†‘(â†‘w2).2).Nonempty) â†’\n            (â‹‚ w, Metric.closedBall (â†‘w).1 â†‘(â†‘w).2).Nonempty].TFAE",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{Î± : Sort u} â†’ Î± â†’ Î±",
  "constCategory": "Definition"},
 {"references": ["Max.max", "LE.le", "sup_le_iff", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_5",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b c : Î±}, (a âŠ” b â‰¤ c) = (a â‰¤ c âˆ§ b â‰¤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth",
   "Eq.mp",
   "Membership.mem",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.Orth",
   "propext",
   "SphericallyCompleteSpace.MOrth",
   "Subspace",
   "SphericallyCompleteSpace.morth_iff_forall_orth",
   "congrArg"],
  "name": "SphericallyCompleteSpace.smul_morth_of_morth",
  "constType":
  "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ğ•œ E} (a : ğ•œ),\n  SphericallyCompleteSpace.MOrth ğ•œ x F â†’ SphericallyCompleteSpace.MOrth ğ•œ (a â€¢ x) F",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Eq.trans",
   "add_add_add_comm",
   "congr",
   "HSMul.hSMul",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.Abel.termg",
   "add_zsmul",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.term_add_termg",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] (nâ‚ : â„¤) (x aâ‚ : Î±) (nâ‚‚ : â„¤) (aâ‚‚ : Î±) (n' : â„¤) (a' : Î±),\n  nâ‚ + nâ‚‚ = n' â†’\n    aâ‚ + aâ‚‚ = a' â†’\n      Mathlib.Tactic.Abel.termg nâ‚ x aâ‚ + Mathlib.Tactic.Abel.termg nâ‚‚ x aâ‚‚ = Mathlib.Tactic.Abel.termg n' x a'",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.ext",
   "Eq.symm",
   "Prod.snd",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn",
   "Prod.fst"],
  "name": "Prod.ext_iff",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} {x y : Î± Ã— Î²}, x = y â†” x.1 = y.1 âˆ§ x.2 = y.2",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_6",
  "constType":
  "âˆ€ {Î± : Type u} {Î¹ : Sort u_1} {f : Î¹ â†’ Î±} {x : Î±}, (x âˆˆ Set.range f) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.smul_orth_of_orth._simp_1_2",
  "constType":
  "âˆ€ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 âˆˆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "sub_neg_eq_add",
   "le_max_iff",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "zero_add",
   "Max.max",
   "IsUltrametricDist.dist_triangle_max",
   "congr",
   "LE.le",
   "Dist.dist",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "dist_eq_norm_sub",
   "propext"],
  "name": "IsUltrametricDist.norm_add_le_max",
  "constType":
  "âˆ€ {S : Type u_1} [inst : SeminormedAddGroup S] [IsUltrametricDist S] (x y : S), â€–x + yâ€– â‰¤ max â€–xâ€– â€–yâ€–",
  "constCategory": "Theorem"},
 {"references": ["Classical.propDecidable", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "âˆ€ {a : Prop}, Â¬Â¬a â†” a",
  "constCategory": "Theorem"},
 {"references": ["Set.Nonempty", "Set", "le_csInf_iff", "OrderBot.bddBelow"],
  "name": "le_csInf_iff''",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Î±] {s : Set Î±} {a : Î±},\n  s.Nonempty â†’ (a â‰¤ sInf s â†” âˆ€ b âˆˆ s, a â‰¤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_add",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isInt_add.match_1_1",
   "Int.add",
   "HAdd.hAdd",
   "Eq.symm",
   "Int.cast"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : Ring Î±] {f : Î± â†’ Î± â†’ Î±} {a b : Î±} {a' b' c : â„¤},\n  f = HAdd.hAdd â†’\n    Mathlib.Meta.NormNum.IsInt a a' â†’\n      Mathlib.Meta.NormNum.IsInt b b' â†’ a'.add b' = c â†’ Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_11",
  "constType":
  "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_5} {Mâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Râ‚‚ Mâ‚‚]\n  {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} {x : Mâ‚‚}, (x âˆˆ f.range) = âˆƒ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe_eq_coe", "Membership.mem", "Subtype.val", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_12",
  "constType":
  "âˆ€ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : â†¥p}, (â†‘x = â†‘y) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["exists_and_right", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_16",
  "constType":
  "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {b : Prop}, (âˆƒ x, p x âˆ§ b) = ((âˆƒ x, p x) âˆ§ b)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "eq_true", "le_sup_left"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_1",
  "constType":
  "âˆ€ {Î± : Type u} [inst : SemilatticeSup Î±] {a b : Î±}, (a â‰¤ a âŠ” b) = True",
  "constCategory": "Theorem"},
 {"references": ["inv_smul_smul", "Units.mk0", "Ne", "OfNat.ofNat"],
  "name": "inv_smul_smulâ‚€",
  "constType":
  "âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : GroupWithZero Î±] [inst_1 : MulAction Î± Î²] {a : Î±},\n  a â‰  0 â†’ âˆ€ (x : Î²), aâ»Â¹ â€¢ a â€¢ x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_4",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î¹ : Sort u_5} {f : Î¹ â†’ Set Î±}, (â‹‚ i, f i).Nonempty = âˆƒ x, âˆ€ (i : Î¹), x âˆˆ f i",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_5",
  "constType":
  "âˆ€ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 â‰¤ â€–aâ€–) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "Nat.cast_zero",
   "OfNat.ofNat",
   "congrArg",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.cast_zero.match_1_1"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 â†’ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.ext",
   "Submodule.toAddSubmonoid",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "Subtype.val",
   "Submodule.add_mem_sup",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "RingHom.id",
   "Subtype.coe_eta",
   "Eq.symm",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_5",
   "And.left",
   "LinearMap.ker",
   "Neg.neg",
   "And.right",
   "iff_true",
   "Mathlib.Tactic.Abel.term_add_constg",
   "LinearMap.sub_mem_ker_iff",
   "Bot.bot",
   "zero_add",
   "IsCompl.of_eq",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Int.negOfNat",
   "id",
   "Top.top",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "AddSubmonoid.mk_eq_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_3",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_neg",
   "DFunLike.coe",
   "congrArg",
   "Subtype.prop",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_2",
   "congr",
   "map_zero",
   "Mathlib.Tactic.Abel.termg",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_1",
   "ContinuousLinearMap.toLinearMap",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_6",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_4",
   "Mathlib.Tactic.Abel.term_neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "and_self",
   "Max.max",
   "of_eq_true",
   "Min.min",
   "Mathlib.Tactic.Abel.const_add_termg"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp",
  "constType":
  "âˆ€ (ğ•œ : Type u_1) [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [IsUltrametricDist E]\n  [inst_3 : NormedSpace ğ•œ E] (F : Submodule ğ•œ E) [SphericallyCompleteSpace â†¥F] (T : E â†’L[ğ•œ] â†¥F),\n  (âˆ€ (a : E) (b : a âˆˆ F), T a = âŸ¨a, bâŸ©) â†’ IsCompl F (â†‘T).ker",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "mul_add",
   "HMul.hMul",
   "HPow.hPow",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf",
  "constType":
  "âˆ€ {R : Type u_1} [inst : CommSemiring R] {a b c : R} (x : R) (e : â„•), a + b = c â†’ x ^ e * a + x ^ e * b = x ^ e * c",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Membership.mem", "Submodule.mem_inf", "propext"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_1",
  "constType":
  "âˆ€ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M} {x : M}, (x âˆˆ p âŠ“ q) = (x âˆˆ p âˆ§ x âˆˆ q)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_3",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Memâ„“p",
   "zero_memâ„“p",
   "forall_congr",
   "funext",
   "Set.range_const",
   "PreLp",
   "Memâ„“p.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Memâ„“p.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_2",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "HAdd.hAdd",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_câ‚€._simp_4",
   "Iff.mpr",
   "LE.le",
   "id",
   "Top.top",
   "Eq.mpr",
   "memâ„“p_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_4",
  "constType":
  "âˆ€ (E : Type u_1) [inst : NormedAddCommGroup E] (x y : E), (fun x_1 â†¦ x + y) âˆˆ lp (fun x â†¦ E) âŠ¤",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "neg_inj", "propext"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_2",
  "constType":
  "âˆ€ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = -b) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "add_left_inj", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_15",
  "constType":
  "âˆ€ {G : Type u_1} [inst : Add G] [IsRightCancelAdd G] (a : G) {b c : G}, (b + a = c + a) = (b = c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "And.right",
   "Membership.mem",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
  "constType":
  "âˆ€ {ğ•œ : Type u_2} [inst : NontriviallyNormedField ğ•œ] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {D : Submodule ğ•œ E} {a : E} (M : â†¥(D + ğ•œ âˆ™ a)) (this : âˆƒ y âˆˆ D, âˆƒ z âˆˆ ğ•œ âˆ™ a, y + z = â†‘M),\n  âˆƒ z âˆˆ ğ•œ âˆ™ a, this.choose + z = â†‘M",
  "constCategory": "Theorem"},
 {"references":
  ["Isometry.injective",
   "Set",
   "Membership.mem",
   "Equiv.ofInjective",
   "Set.range",
   "Set.Elem",
   "Isometry"],
  "name": "Isometry.isometryEquivOnRange",
  "constType":
  "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    [inst : EMetricSpace Î±] â†’ [inst_1 : PseudoEMetricSpace Î²] â†’ {f : Î± â†’ Î²} â†’ Isometry f â†’ Î± â‰ƒáµ¢ â†‘(Set.range f)",
  "constCategory": "Definition"},
 {"references":
  ["HDiv.hDiv",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
  "constType":
  "âˆ€ {M : Type u_1} [inst : GroupWithZero M] {lâ‚ lâ‚‚ l : Mathlib.Tactic.FieldSimp.NF M} {xâ‚ xâ‚‚ : M},\n  xâ‚ = lâ‚.eval â†’ xâ‚‚ = lâ‚‚.eval â†’ lâ‚.eval / lâ‚‚.eval = l.eval â†’ xâ‚ / xâ‚‚ = l.eval",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Lean.Omega.Constraint.isImpossible.match_1", "Decidable.decide"],
  "name": "Lean.Omega.Constraint.isImpossible",
  "constType": "Omega.Constraint â†’ Bool",
  "constCategory": "Definition"},
 {"references": ["Classical.choose"],
  "name": "Exists.choose",
  "constType": "{Î± : Sort u_1} â†’ {p : Î± â†’ Prop} â†’ (âˆƒ a, p a) â†’ Î±",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Monotone",
   "Iff.mpr",
   "LE.le",
   "monotone_iff_forall_lt",
   "LT.lt.le",
   "StrictMono"],
  "name": "StrictMono.monotone",
  "constType":
  "âˆ€ {Î± : Type u} {Î² : Type v} [inst : PartialOrder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²}, StrictMono f â†’ Monotone f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Or.casesOn",
  "constType":
  "âˆ€ {a b : Prop} {motive : a âˆ¨ b â†’ Prop} (t : a âˆ¨ b), (âˆ€ (h : a), motive â‹¯) â†’ (âˆ€ (h : b), motive â‹¯) â†’ motive t",
  "constCategory": "Definition"},
 {"references": ["LT.lt"],
  "name": "StrictAnti",
  "constType":
  "{Î± : Type u} â†’ {Î² : Type v} â†’ [Preorder Î±] â†’ [Preorder Î²] â†’ (Î± â†’ Î²) â†’ Prop",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "AddLeftReflectLT",
   "AddLeftStrictMono",
   "lt_add_iff_pos_right",
   "OfNat.ofNat",
   "propext"],
  "name": "lt_mul_iff_one_lt_right'._simp_2",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : AddZeroClass Î±] [inst_1 : LT Î±] [AddLeftStrictMono Î±] [AddLeftReflectLT Î±] (a : Î±) {b : Î±},\n  (a < a + b) = (0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.Prod.0.Prod.exists.match_1_3",
   "_private.Init.Data.Prod.0.Prod.exists.match_1_1"],
  "name": "Prod.exists",
  "constType":
  "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {p : Î± Ã— Î² â†’ Prop}, (âˆƒ x, p x) â†” âˆƒ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["max_comm", "Max.max", "LE.le", "max_eq_left"],
  "name": "max_eq_right",
  "constType":
  "âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {a b : Î±}, a â‰¤ b â†’ max a b = b",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_5",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "PreLp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "Set",
   "lp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_3",
   "SphericallyCompleteSpace.câ‚€",
   "Exists.choose",
   "DFunLike.coe",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_6",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.SphericalCompletion",
   "ENNReal",
   "Maximal",
   "RingHom.id",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding",
  "constType":
  "(ğ•œ : Type u_1) â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    (E : Type u) â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          [inst_3 : IsUltrametricDist E] â†’ E â†’â‚—áµ¢[ğ•œ] SphericallyCompleteSpace.SphericalCompletion ğ•œ E",
  "constCategory": "Definition"}]