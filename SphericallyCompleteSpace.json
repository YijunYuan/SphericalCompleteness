[{"references": ["Classical.propDecidable._proof_1", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) ‚Üí Decidable a",
  "constCategory": "Definition"},
 {"references": ["Eq.subst"],
  "name": "heq_of_eq",
  "constType": "‚àÄ {Œ± : Sort u} {a a' : Œ±}, a = a' ‚Üí a ‚âç a'",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max", "Eq.mp", "LE.le", "LE.le.eq_1", "le_sup_left", "congrArg"],
  "name": "Submodule.mem_sup_left",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S T : Submodule R M} {x : M}, x ‚àà S ‚Üí x ‚àà S ‚äî T",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_23",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "Exists.choose_spec",
   "Norm.norm",
   "Membership.mem",
   "Iff.mp",
   "Exists.choose",
   "SphericallyCompleteSpace.OrthComp._proof_2",
   "Subtype.val",
   "DFunLike.coe",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "RingHom.id",
   "SetLike.coe_eq_coe",
   "LE.le",
   "id",
   "SphericallyCompleteSpace.orth_of_orthcomp",
   "And.left"],
  "name": "SphericallyCompleteSpace.isCompl_orthcomp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  IsCompl F (SphericallyCompleteSpace.OrthComp ùïú F)",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_6",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_6",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± √ó Œ≤ ‚Üí Prop}, (‚àÉ x, p x) = ‚àÉ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff‚ÇÇ", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  (‚àÄ (b : Œ≤) (a : Œ±), p a ‚Üí f a = b ‚Üí q b) = ‚àÄ (a : Œ±), p a ‚Üí q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv",
   "HAdd.hAdd",
   "Nat.cast",
   "NNDist.nndist",
   "NNReal",
   "HMul.hMul",
   "Prod.snd",
   "GT.gt",
   "Exists.choose",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "OfNat.ofNat",
   "Prod.fst"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
  "constType":
  "(Œ± : Type u_1) ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] ‚Üí [nemp : Nonempty Œ±] ‚Üí ‚Ñï ‚Üí NNReal",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.mk.injEq",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_1",
   "Eq.trans",
   "add_add_add_comm",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Prod.fst",
   "Submodule.add_mem_sup",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_2",
   "Max.max",
   "Subtype.prop",
   "forall_congr",
   "id",
   "AddMemClass.add_mem",
   "Eq.mpr",
   "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_4",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (x_1 y : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F),\n  ‚ü®‚Üë(x_1 + y).1 + ‚Üë(x_1 + y).2, ‚ãØ‚ü© = ‚ü®‚Üëx_1.1 + ‚Üëx_1.2, ‚ãØ‚ü© + ‚ü®‚Üëy.1 + ‚Üëy.2, ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references": ["exists_prop_of_true"],
  "name": "exists_true_left",
  "constType": "‚àÄ {p : True ‚Üí Prop}, Exists p ‚Üî p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "rel_iff_cov", "LE.le", "HMul.hMul", "Subtype.val", "OfNat.ofNat"],
  "name": "mul_le_mul_iff_right‚ÇÄ",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] {a b c : Œ±} [PosMulMono Œ±] [PosMulReflectLE Œ±],\n  0 < a ‚Üí (a * b ‚â§ a * c ‚Üî b ‚â§ c)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congrFun",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, f = g ‚Üí ‚àÄ (a : Œ±), f a = g a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "LE.le", "NNReal.toReal", "OfNat.ofNat"],
  "name": "NNReal.coe_mk",
  "constType": "‚àÄ (a : ‚Ñù) (ha : 0 ‚â§ a), ‚Üë‚ü®a, ha‚ü© = a",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "LT.lt",
   "Not",
   "le_refl",
   "le_of_lt",
   "LE.le",
   "_private.Mathlib.Order.Defs.LinearOrder.0.le_of_not_gt.match_1_1",
   "lt_trichotomy"],
  "name": "le_of_not_gt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, ¬¨b < a ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.atTop", "Set", "Membership.mem", "nhds", "Filter.Tendsto"],
  "name": "IsSeqClosed",
  "constType": "{X : Type u_1} ‚Üí [TopologicalSpace X] ‚Üí Set X ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Submodule.Quotient.mk",
   "Eq.trans",
   "HasQuotient.Quotient",
   "Eq.mp",
   "Membership.mem",
   "_private.Mathlib.LinearAlgebra.Dimension.RankNullity.0.Submodule.exists_smul_notMem_of_rank_lt._simp_1_2",
   "DFunLike.coe",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "_private.Mathlib.LinearAlgebra.Dimension.RankNullity.0.Submodule.exists_smul_notMem_of_rank_lt._simp_1_1",
   "ne_eq",
   "RingHom.id",
   "LT.lt.ne",
   "funext",
   "forall_congr",
   "Eq.symm",
   "rank_eq_zero_iff",
   "propext",
   "rfl",
   "Not",
   "Submodule.mkQ",
   "binderNameHint",
   "Submodule.rank_quotient_add_rank",
   "Cardinal",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "zero_add",
   "Function.Surjective.forall",
   "Module.rank",
   "HSMul.hSMul",
   "Submodule.Quotient.mk_surjective",
   "Mathlib.Tactic.Push.not_and_eq",
   "Ne",
   "Mathlib.Tactic.Push.not_forall_eq"],
  "name": "Submodule.exists_smul_notMem_of_rank_lt",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  [HasRankNullity.{u, u_1} R] {N : Submodule R M},\n  Module.rank R ‚Ü•N < Module.rank R M ‚Üí ‚àÉ m, ‚àÄ (r : R), r ‚â† 0 ‚Üí r ‚Ä¢ m ‚àâ N",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "FiniteDimensional",
   "_private.SphericalCompleteness.NormedVectorSpace.Basic.0.SphericallyCompleteSpace.induction_sphericallyCompleteSpace_of_finiteDimensional",
   "Membership.mem",
   "NNReal.toReal",
   "Set.iInter",
   "Subtype.val",
   "Subspace",
   "congrArg",
   "le_rfl",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Module.finrank",
   "Dist.dist",
   "forall_congr",
   "Submodule.eq_top_of_finrank_eq",
   "Set.Nonempty",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_finiteDimensional._simp_1_1",
   "NNReal",
   "Nat.recAux",
   "Bot.bot",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Exists.casesOn",
   "Metric.closedBall",
   "Antitone",
   "NNDist.nndist",
   "LE.le",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_2",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_1",
   "id",
   "Nat.le_of_succ_le",
   "Top.top",
   "inferInstance",
   "Eq.mpr",
   "finrank_bot",
   "trivial",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_finiteDimensional",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] [SphericallyCompleteSpace ùïú] (E : Type u_2)\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] [IsUltrametricDist E] [FiniteDimensional ùïú E],\n  SphericallyCompleteSpace E",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "Int.add_one_le_of_lt",
  "constType": "‚àÄ {a b : ‚Ñ§}, a < b ‚Üí a + 1 ‚â§ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Metric.mem_ball",
   "Set",
   "Dist.dist",
   "Membership.mem",
   "Metric.ball",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.ball x Œµ) = (dist y x < Œµ)",
  "constCategory": "Theorem"},
 {"references": ["eq_false", "one_ne_zero", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Zero Œ±] [inst_1 : One Œ±] [NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_2",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "NNReal.toReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_3",
   "IsometryEquiv.isometry",
   "Set.iInter",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "forall_congr",
   "IsometryEquiv.preimage_closedBall",
   "Dist.dist",
   "funext",
   "IsometryEquiv.apply_symm_apply",
   "Eq.symm",
   "Set.preimage",
   "Set.Nonempty",
   "Set",
   "NNReal",
   "Exists.casesOn",
   "Metric.closedBall",
   "HasSubset.Subset",
   "IsometryEquiv.symm",
   "Antitone",
   "Isometry.dist_eq",
   "LE.le",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._proof_1_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_4"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
  "constType":
  "‚àÄ {E : Type u_1} {F : Type u_2} [inst : PseudoMetricSpace E] [inst_1 : PseudoMetricSpace F]\n  [he : SphericallyCompleteSpace E] (f : E ‚âÉ·µ¢ F), SphericallyCompleteSpace F",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, (x ‚â• y) = (y ‚â§ x)",
  "constCategory": "Theorem"},
 {"references": ["Nat.below", "Nat.brecOn", "Nat.ble.match_1"],
  "name": "Nat.ble",
  "constType": "‚Ñï ‚Üí ‚Ñï ‚Üí Bool",
  "constCategory": "Definition"},
 {"references": ["Set", "Iff.mpr", "iInf_congr_Prop"],
  "name": "Set.iInter_congr_Prop",
  "constType":
  "‚àÄ {Œ± : Type u_1} {p q : Prop} {f‚ÇÅ : p ‚Üí Set Œ±} {f‚ÇÇ : q ‚Üí Set Œ±} (pq : p ‚Üî q),\n  (‚àÄ (x : q), f‚ÇÅ ‚ãØ = f‚ÇÇ x) ‚Üí Set.iInter f‚ÇÅ = Set.iInter f‚ÇÇ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "FunLike",
  "constType":
  "Sort u_1 ‚Üí Sort u_2 ‚Üí Sort u_3 ‚Üí Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Inv.inv", "inv_pos", "OfNat.ofNat", "propext"],
  "name": "inv_pos._simp_1",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a : G‚ÇÄ},\n  (0 < a‚Åª¬π) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
   "Metric.diam_subsingleton",
   "Dense.closure_eq",
   "Eq.trans",
   "Singleton.singleton",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "Metric.diam",
   "Classical.propDecidable",
   "Denumerable.ofNat_encode",
   "Membership.mem.out",
   "Set.iInter",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_23",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range",
   "Subtype.val",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Set.Elem",
   "nonempty_denumerable_iff",
   "False.elim",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_17",
   "Eq.symm",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_15",
   "Eq.ndrec",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_3",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_8",
   "Nat.ble",
   "rfl",
   "Exists.choose_spec",
   "NNReal",
   "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_1",
   "MulZeroClass.mul_zero",
   "Prod.snd",
   "Set.disjoint_iff_forall_ne",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_12",
   "IsUltrametricDist.dist_triangle_max",
   "Antitone",
   "Disjoint.closure_left",
   "Classical.byContradiction",
   "NNDist.nndist",
   "Set.ext",
   "Eq.mpr",
   "Set.Finite",
   "one_mul",
   "Exists.choose.congr_simp",
   "setOf",
   "Std.lt_of_lt_of_le",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_20",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_25",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_eval‚ÇÉ",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_radius_eq",
   "Metric.ball",
   "and_true",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "EmptyCollection.emptyCollection",
   "Prod.fst",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_9",
   "LT.lt.ne'",
   "congr",
   "InfSet.sInf",
   "Denumerable.ofNat",
   "propext",
   "Metric.isOpen_ball",
   "Set",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_18",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_24",
   "Set.Subsingleton",
   "OfNat.ofNat",
   "Set.Finite.isClosed",
   "HAdd.hAdd",
   "Set.univ",
   "eq_self",
   "Metric.closedBall",
   "Max.max",
   "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_22",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "congr_arg‚ÇÇ",
   "inferInstance",
   "nndist_self",
   "Ne",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "dite",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_19",
   "closure_eq_iff_isClosed",
   "And.casesOn",
   "TopologicalSpace.SeparableSpace.exists_countable_dense",
   "lt_trans",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
   "Membership.mem",
   "HMul.hMul",
   "Mathlib.Tactic.FieldSimp.NF.cons_pos",
   "GT.gt",
   "Set.toFinite",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
   "HDiv.hDiv",
   "not_false_eq_true",
   "mul_le_iff_le_one_right",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_11",
   "Disjoint",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_13",
   "forall_congr",
   "funext",
   "csInf_le'",
   "And.left",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_21",
   "div_self",
   "Neg.neg",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
   "And.right",
   "Mathlib.Tactic.FieldSimp.lt_eq_cancel_lt",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_14",
   "Exists.casesOn",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.not_in_fuck_chain_of_ball",
   "zero_add",
   "Set.image",
   "HasSubset.Subset",
   "Iff.mpr",
   "SphericallyCompleteSpace.IsSphericallyDense.spherically_dense",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_7",
   "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
   "id",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_5",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
   "div_one",
   "Nat.cast",
   "Eq.mp",
   "mul_div_cancel_right‚ÇÄ",
   "Metric.mem_closedBall",
   "le_trans",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_3",
   "NNReal.toReal",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_10",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_16",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball_decreasing",
   "Encodable.encode",
   "Set.Countable",
   "Dense",
   "congrArg",
   "Dist.dist",
   "closure",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
   "zero_lt_one",
   "Set.Nonempty.csInf_mem",
   "Set.subsingleton_iff_singleton",
   "Exists.choose",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Nonempty.some",
   "LT.lt",
   "not_lt",
   "of_eq_true",
   "le_of_lt",
   "CharP.cast_eq_zero",
   "LE.le",
   "one_add_one_eq_two",
   "Set.finite_univ_iff",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : MetricSpace Œ±] [hiud : IsUltrametricDist Œ±]\n  [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] [nemp : Nonempty Œ±] [hsep : TopologicalSpace.SeparableSpace Œ±],\n  ¬¨SphericallyCompleteSpace Œ±",
  "constCategory": "Theorem"},
 {"references": ["Set.iInter_subtype", "Set", "Membership.mem", "Set.Elem"],
  "name": "Set.iInter_coe_set",
  "constType":
  "‚àÄ {Œ± : Type u_12} {Œ≤ : Type u_13} (s : Set Œ±) (f : ‚Üës ‚Üí Set Œ≤), ‚ãÇ i, f i = ‚ãÇ i, ‚ãÇ (h : i ‚àà s), f ‚ü®i, h‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "HasQuotient.Quotient",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Mem‚Ñìp",
   "zero_mem‚Ñìp",
   "forall_congr",
   "funext",
   "Set.range_const",
   "QuotientAddGroup.mk'",
   "rfl",
   "PreLp",
   "Mem‚Ñìp.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Mem‚Ñìp.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "Iff.mpr",
   "LE.le",
   "HSMul.hSMul",
   "Top.top",
   "id",
   "Eq.mpr",
   "mem‚Ñìp_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_7",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (c : ùïú) (x : E),\n  (have this := ‚ãØ;\n    (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup) ‚ü®fun x_1 ‚Ü¶ c ‚Ä¢ x, this‚ü©) =\n    have this := ‚ãØ;\n    (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup) ‚ü®fun x_1 ‚Ü¶ c ‚Ä¢ x, this‚ü©",
  "constCategory": "Theorem"},
 {"references": ["LE.le.ge_iff_eq'", "zero_le", "OfNat.ofNat"],
  "name": "nonpos_iff_eq_zero",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddZeroClass Œ±] [inst_1 : PartialOrder Œ±] [CanonicallyOrderedAdd Œ±] {a : Œ±}, a ‚â§ 0 ‚Üî a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "LinearIsometry.comp._proof_1",
   "LinearMap.comp"],
  "name": "LinearIsometry.comp",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {R‚ÇÉ : Type u_3} ‚Üí\n      {E : Type u_5} ‚Üí\n        {E‚ÇÇ : Type u_6} ‚Üí\n          {E‚ÇÉ : Type u_7} ‚Üí\n            [inst : Semiring R] ‚Üí\n              [inst_1 : Semiring R‚ÇÇ] ‚Üí\n                [inst_2 : Semiring R‚ÇÉ] ‚Üí\n                  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n                    {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} ‚Üí\n                      {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} ‚Üí\n                        [RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] ‚Üí\n                          [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                            [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                              [inst_6 : SeminormedAddCommGroup E‚ÇÉ] ‚Üí\n                                [inst_7 : _root_.Module R E] ‚Üí\n                                  [inst_8 : _root_.Module R‚ÇÇ E‚ÇÇ] ‚Üí\n                                    [inst_9 : _root_.Module R‚ÇÉ E‚ÇÉ] ‚Üí\n                                      (E‚ÇÇ ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÉ] E‚ÇÉ) ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÉ] E‚ÇÉ",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "Set.mem_smul_set",
   "OfNat.ofNat",
   "congrArg",
   "Exists.casesOn",
   "SetLike.coe",
   "Iff.mpr",
   "SMulMemClass.smul_mem",
   "HSMul.hSMul",
   "Eq.symm",
   "id",
   "Set.smulSet",
   "Set.ext",
   "Ne",
   "Eq.mpr",
   "smul_inv_smul‚ÇÄ",
   "And.casesOn"],
  "name": "smul_submodule_eq_self",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {E : Type u_2} [inst_1 : AddCommMonoid E] [inst_2 : _root_.Module ùïú E] {a : ùïú},\n  a ‚â† 0 ‚Üí ‚àÄ (M : Submodule ùïú E), a ‚Ä¢ ‚ÜëM = ‚ÜëM",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup.le_sup_left"],
  "name": "le_sup_left",
  "constType": "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, a ‚â§ a ‚äî b",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt_top_iff", "Top.top", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, (¬¨a < ‚ä§) = (a = ‚ä§)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Classical.choose_spec",
   "Not",
   "Eq.trans",
   "_private.Init.Classical.0.Classical.em.match_1_3",
   "eq_iff_iff._simp_1",
   "iff_false",
   "Classical.choose",
   "congrArg",
   "mt",
   "not_false_eq_true",
   "of_eq_true",
   "congr",
   "funext",
   "id",
   "_private.Init.Classical.0.Classical.em.match_1_1",
   "not_true_eq_false",
   "Eq.mpr",
   "Ne",
   "propext"],
  "name": "Classical.em",
  "constType": "‚àÄ (p : Prop), p ‚à® ¬¨p",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Membership.mem",
   "Metric.mem_closedBall._simp_1",
   "SProd.sprod",
   "Prod.snd",
   "Prod.fst",
   "congrArg",
   "Metric.closedBall",
   "iff_self",
   "of_eq_true",
   "Set.mem_prod._simp_1",
   "congr",
   "LE.le",
   "Dist.dist",
   "Set.ext",
   "sup_le_iff._simp_5"],
  "name": "closedBall_prod_same",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] (x : Œ±) (y : Œ≤) (r : ‚Ñù),\n  Metric.closedBall x r √óÀ¢ Metric.closedBall y r = Metric.closedBall (x, y) r",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Subtype.mk.injEq",
   "Eq.trans",
   "Classical.propDecidable",
   "Membership.mem.out",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "Set.Elem",
   "le_csSup",
   "iSup",
   "le_ciInf",
   "RingHom.id",
   "Eq.symm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "Set.Nonempty.coe_sort",
   "rfl",
   "le_top._simp_3",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Norm.norm",
   "Set.Nonempty.some_mem",
   "Submodule.coe_iSup_of_directed",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_13",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "Submodule.mem_iSup",
   "implies_true",
   "SetLike.coe",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "lowerBounds",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "IsChain",
   "LinearMap.mem_range",
   "Subspace",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "iInf",
   "propext",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Set",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_6",
   "OfNat.ofNat",
   "Subtype.range_coe_subtype",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "Classical.not_not._simp_1",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_16",
   "Set.iUnion_coe_set",
   "eq_of_le_of_ge",
   "zorn_le‚ÇÄ",
   "dite",
   "Set.mem_range",
   "And.casesOn",
   "Membership.mem",
   "Iff.mp",
   "Set.iUnion",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_3",
   "forall_congr",
   "funext",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "csInf_le",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_10",
   "Set.Nonempty.some",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_12",
   "Exists.casesOn",
   "SphericallyCompleteSpace.IsImmediate",
   "HasSubset.Subset",
   "Iff.of_eq",
   "upperBounds",
   "Iff.mpr",
   "id",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_4",
   "Metric.infDist_eq_iInf",
   "Eq.mp",
   "LinearMap.range",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_7",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_9",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_11",
   "IsChain.directed",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Subtype.prop",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "Dist.dist",
   "Set.iUnion_congr_Prop",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_14",
   "Metric.infDist",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "Not",
   "Set.Nonempty",
   "exists_prop_congr",
   "of_eq_true",
   "LE.le",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_8",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_5",
   "SphericallyCompleteSpace.imm_ext_nonempty",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_15"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (E‚ÇÄ : Type u_3) [inst_4 : NormedAddCommGroup E‚ÇÄ]\n  [inst_5 : NormedSpace ùïú E‚ÇÄ] [inst_6 : IsUltrametricDist E‚ÇÄ] [inst_7 : SphericallyCompleteSpace E‚ÇÄ] (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ),\n  ‚àÉ m, Maximal (fun x ‚Ü¶ x ‚àà SphericallyCompleteSpace.imm_ext_in_sph_comp E E‚ÇÄ f) m",
  "constCategory": "Theorem"},
 {"references": ["mul_le_mul_iff_right‚ÇÄ"],
  "name": "mul_le_mul_iff_of_pos_left",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] {a b c : Œ±} [PosMulMono Œ±] [PosMulReflectLE Œ±],\n  0 < a ‚Üí (a * b ‚â§ a * c ‚Üî b ‚â§ c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.le_succ",
  "constType": "‚àÄ (n : ‚Ñï), n ‚â§ n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "LT.lt", "div_pos_iff_of_pos_left", "propext", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._simp_6",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Semifield Œ±] [inst_1 : LinearOrder Œ±] [IsStrictOrderedRing Œ±] {a b : Œ±},\n  0 < a ‚Üí (0 < a / b) = (0 < b)",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "False.elim", "propext"],
  "name": "eq_false",
  "constType": "‚àÄ {p : Prop}, ¬¨p ‚Üí p = False",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "SMulMemClass.smul_mem",
  "constType":
  "‚àÄ {S : Type u_1} {R : outParam (Type u_2)} {M : Type u_3} {inst : SMul R M} {inst_1 : SetLike S M}\n  [self : SMulMemClass S R M] {s : S} (r : R) {m : M}, m ‚àà s ‚Üí r ‚Ä¢ m ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name": "gt_iff_lt._simp_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x y : Œ±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references": ["Int.negOfNat.match_1", "OfNat.ofNat", "Unit"],
  "name": "Int.negOfNat",
  "constType": "‚Ñï ‚Üí ‚Ñ§",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Classical.propDecidable",
   "Classical.arbitrary",
   "Exists.choose",
   "dite"],
  "name": "Function.invFun",
  "constType": "{Œ± : Sort u} ‚Üí {Œ≤ : Sort u_3} ‚Üí [Nonempty Œ±] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Œ≤ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": ["HSub.hSub", "Eq.ndrec"],
  "name": "Lean.Omega.Int.sub_congr",
  "constType": "‚àÄ {a b c d : ‚Ñ§}, a = b ‚Üí c = d ‚Üí a - c = b - d",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "eq_true", "zero_lt_one", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [ZeroLEOneClass Œ±] [NeZero 1],\n  (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl", "GT.gt"],
  "name": "gt_iff_lt",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x y : Œ±}, x > y ‚Üî y < x",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "nonpos_iff_eq_zero", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_20",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddZeroClass Œ±] [inst_1 : PartialOrder Œ±] [CanonicallyOrderedAdd Œ±] {a : Œ±}, (a ‚â§ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Top.top", "lp.instNormedSpace._proof_1"],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_2",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E], IsScalarTower ùïú ùïú ‚Ü•(lp (fun x ‚Ü¶ E) ‚ä§)",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff‚ÇÇ", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  (‚àÄ (b : Œ≤) (a : Œ±), p a ‚Üí f a = b ‚Üí q b) = ‚àÄ (a : Œ±), p a ‚Üí q (f a)",
  "constCategory": "Theorem"},
 {"references": ["lt_irrefl"],
  "name": "Mathlib.Tactic.Linarith.lt_irrefl",
  "constType": "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±}, ¬¨a < a",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "LinearMap.range", "Membership.mem", "Iff.rfl"],
  "name": "LinearMap.mem_range",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ}, x ‚àà LinearMap.range f ‚Üî ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["add_nonpos", "LE.le", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_nonpos",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] {a b : Œ±}, a ‚â§ 0 ‚Üí b ‚â§ 0 ‚Üí a + b ‚â§ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod.fst",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí Œ± √ó Œ≤ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat.cast",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNat_eq_true.match_1_1"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_true",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddMonoidWithOne Œ±] {a b : Œ±} {c : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNat a c ‚Üí Mathlib.Meta.NormNum.IsNat b c ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references": ["Nat.ofNat_pos'"],
  "name": "Nat.ofNat_pos",
  "constType":
  "‚àÄ {Œ± : Type u_3} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] [Nontrivial Œ±] {n : ‚Ñï}\n  [inst_4 : n.AtLeastTwo], 0 < OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_3} ‚Üí [inst : Add M] ‚Üí AddSubsemigroup M ‚Üí Set M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.isSphericallyComplete",
  "constType":
  "‚àÄ {Œ± : Type u_1} {inst : PseudoMetricSpace Œ±} [self : SphericallyCompleteSpace Œ±] ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n  (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_6",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "ZeroMemClass.zero_mem",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  0 ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Iff.mpr", "Nat.ceil", "OfNat.ofNat", "Nat.ceil_pos"],
  "name":
  "_private.Mathlib.Algebra.Order.Floor.Ring.0.Mathlib.Meta.Positivity.nat_ceil_pos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : FloorSemiring Œ±] {a : Œ±}, 0 < a ‚Üí 0 < ‚åàa‚åâ‚Çä",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Nat.cast",
   "Eq.trans",
   "Iff.mp",
   "and_true",
   "Nat.not_le",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "eq_self",
   "gt_iff_lt._simp_1",
   "LE.le",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "HSub.hSub",
   "id",
   "Int.ofNat_sub",
   "Eq.mpr",
   "dite"],
  "name": "Lean.Omega.Int.ofNat_sub_dichotomy",
  "constType": "‚àÄ {a b : ‚Ñï}, b ‚â§ a ‚àß ‚Üë(a - b) = ‚Üëa - ‚Üëb ‚à® a < b ‚àß ‚Üë(a - b) = 0",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Array.mkArray5"],
  "name": "Lean.Syntax.node5",
  "constType":
  "SourceInfo ‚Üí SyntaxNodeKind ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax",
  "constCategory": "Definition"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_9",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 ‚â§ ‚Äña‚Äñ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth._simp_1_2",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Classical.propDecidable",
   "HMul.hMul",
   "Submodule.span",
   "congrArg",
   "congr",
   "Set.smulSet",
   "Eq.symm",
   "Metric.infDist",
   "Eq.ndrec",
   "norm_zero",
   "Not",
   "infDist_smul‚ÇÄ",
   "Norm.norm",
   "Set",
   "Metric.infDist_zero_of_mem",
   "SphericallyCompleteSpace.Orth",
   "smul_submodule_eq_self",
   "OfNat.ofNat",
   "norm_smul",
   "SetLike.coe",
   "of_eq_true",
   "HSMul.hSMul",
   "SphericallyCompleteSpace.smul_orth_of_orth._simp_1_1",
   "id",
   "zero_smul",
   "Eq.mpr",
   "dite"],
  "name": "SphericallyCompleteSpace.smul_orth_of_orth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x y : E} (a : ùïú), (x ‚üÇ[ùïú] y) ‚Üí a ‚Ä¢ x ‚üÇ[ùïú] y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "neg_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "‚àÄ {R : Type u_2} [inst : CommRing R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Subtype.mk.injEq",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "eq_true",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Submodule.add_mem_sup",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "RingHom.id",
   "Eq.symm",
   "Subtype.coe_eta",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.smul_morth_of_morth'",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "norm_zero",
   "sub_mem_comm_iff",
   "sup_of_le_right",
   "Exists.choose_spec",
   "Norm.norm",
   "sub_neg_eq_add",
   "Prod.snd",
   "true_and",
   "SphericallyCompleteSpace.eq_zero_of_morth_of_mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "SetLike.coe",
   "SetLike.coe_eq_coe",
   "SMulMemClass.smul_mem",
   "Int.negOfNat",
   "Set.ext",
   "norm_neg",
   "Eq.mpr",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_5",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "add_neg_cancel_comm",
   "and_true",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Subspace",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Submodule.mem_sup",
   "congr",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_9",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "neg_eq_iff_eq_neg",
   "Metric.notMem_of_dist_lt_infDist",
   "neg_sub",
   "HPow.hPow",
   "OfNat.ofNat",
   "not_le_of_gt",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "and_self",
   "smul_add",
   "dite",
   "And.casesOn",
   "Submodule.neg_mem",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "add_add_add_comm",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_8",
   "add_comm",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "NegMemClass.neg_mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_10",
   "Neg.neg",
   "And.right",
   "add_zero",
   "zero_add",
   "Mathlib.Tactic.Ring.atom_pf",
   "sup_of_le_left",
   "Nat.cast_zero",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "AddMemClass.add_mem",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Prod.ext_iff",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_1",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Or.resolve_right",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "DFunLike.coe",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_7",
   "congrArg",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_2",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
   "Metric.infDist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "sub_eq_sub_iff_add_eq_add",
   "eq_of_le_of_not_lt",
   "Submodule.add_eq_sup",
   "Exists.choose",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_6",
   "Mathlib.Tactic.Ring.add_congr",
   "Submodule.sub_mem_iff_left",
   "Or.casesOn",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "le_of_lt",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_16",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ùïú E)\n  (hxF : SphericallyCompleteSpace.MOrth ùïú x F) (x_1 : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F),\n  ‚Äñ{ toFun := fun z ‚Ü¶ ‚ü®‚Üëz.1 + ‚Üëz.2, ‚ãØ‚ü©, map_add' := ‚ãØ, map_smul' := ‚ãØ,\n          invFun := ‚ãØ.mpr fun z ‚Ü¶ (‚ü®‚ãØ.choose, ‚ãØ‚ü©, ‚ü®‚ãØ.choose, ‚ãØ‚ü©), left_inv := ‚ãØ, right_inv := ‚ãØ }\n        x_1‚Äñ =\n    ‚Äñx_1‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Membership.mem", "Iff.rfl"],
  "name": "Submodule.mem_inf",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M} {x : M}, x ‚àà p ‚äì q ‚Üî x ‚àà p ‚àß x ‚àà q",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "LT.lt", "div_pos_iff_of_pos_right", "propext", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_18",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Semifield Œ±] [inst_1 : LinearOrder Œ±] [IsStrictOrderedRing Œ±] {a b : Œ±},\n  0 < b ‚Üí (0 < a / b) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.Subtype.Basic.0.Subtype.exists.match_1_3",
   "_private.Init.Data.Subtype.Basic.0.Subtype.exists.match_1_1"],
  "name": "Subtype.exists",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) ‚Üî ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.neg_mem",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "eq_true",
   "Submodule.span",
   "Subtype.val",
   "Submodule.add_mem_sup",
   "HSub.hSub",
   "Eq.symm",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.smul_morth_of_morth'",
   "Eq.ndrec",
   "add_comm",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "sub_mem_comm_iff",
   "Exists.choose_spec",
   "Neg.neg",
   "And.right",
   "Prod.snd",
   "true_and",
   "SphericallyCompleteSpace.eq_zero_of_morth_of_mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "SetLike.coe",
   "SetLike.coe_eq_coe",
   "Iff.mpr",
   "id",
   "Set.ext",
   "Eq.mpr",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_5",
   "Prod.ext_iff",
   "Eq.mp",
   "and_true",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_7",
   "Subspace",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "Submodule.mem_sup",
   "congr",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
   "propext",
   "sub_eq_sub_iff_add_eq_add",
   "Set",
   "neg_eq_iff_eq_neg",
   "Submodule.add_eq_sup",
   "neg_sub",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_6",
   "Exists.choose",
   "Submodule.sub_mem_iff_left",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "and_self",
   "Max.max",
   "of_eq_true",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_13",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ùïú E),\n  SphericallyCompleteSpace.MOrth ùïú x F ‚Üí\n    ‚àÄ (t : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F), ‚ãØ.mpr (fun z ‚Ü¶ (‚ü®‚ãØ.choose, ‚ãØ‚ü©, ‚ü®‚ãØ.choose, ‚ãØ‚ü©)) ‚ü®‚Üët.1 + ‚Üët.2, ‚ãØ‚ü© = t",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ", "Set", "Membership.mem", "eq_true", "Set.mem_univ"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_2",
  "constType": "‚àÄ {Œ± : Type u} (x : Œ±), (x ‚àà Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsLinearMap.map_smul",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} {M‚ÇÇ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M‚ÇÇ] {f : M ‚Üí M‚ÇÇ},\n  IsLinearMap R f ‚Üí ‚àÄ (c : R) (x : M), f (c ‚Ä¢ x) = c ‚Ä¢ f x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Classical.propDecidable",
   "iff_true",
   "eq_true",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "iff_self",
   "congr",
   "eq_false",
   "not_true_eq_false",
   "dite"],
  "name": "Lean.Grind.iff_eq",
  "constType": "‚àÄ (p q : Prop), (p ‚Üî q) = (p = q)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "Subtype.forall._simp_1",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": ["Quotient.mk''", "QuotientAddGroup.leftRel"],
  "name": "QuotientAddGroup.mk",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : AddGroup Œ±] ‚Üí {s : AddSubgroup Œ±} ‚Üí Œ± ‚Üí Œ± ‚ß∏ s",
  "constCategory": "Definition"},
 {"references": ["sub_mem"],
  "name": "Submodule.sub_mem",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x y : M}, x ‚àà p ‚Üí y ‚àà p ‚Üí x - y ‚àà p",
  "constCategory": "Theorem"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
  "constType": "{Œ± : Type u} ‚Üí [Semiring Œ±] ‚Üí AddMonoidWithOne Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "Eq.mp",
   "inv_smul_smul‚ÇÄ",
   "HSMul.hSMul",
   "SphericallyCompleteSpace.smul_morth_of_morth",
   "Ne",
   "SphericallyCompleteSpace.MOrth",
   "OfNat.ofNat",
   "Subspace",
   "congrArg"],
  "name": "SphericallyCompleteSpace.smul_morth_iff_morth_of_nonzero",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ùïú E} {a : ùïú},\n  a ‚â† 0 ‚Üí (SphericallyCompleteSpace.MOrth ùïú x F ‚Üî SphericallyCompleteSpace.MOrth ùïú (a ‚Ä¢ x) F)",
  "constCategory": "Theorem"},
 {"references": ["Ne.symm", "Top.top", "Ne", "Ne.lt_top"],
  "name": "Ne.lt_top'",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, ‚ä§ ‚â† a ‚Üí a < ‚ä§",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "le_sup_iff", "LE.le", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, (a ‚â§ max b c) = (a ‚â§ b ‚à® a ‚â§ c)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Nat.rawCast"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : AddMonoidWithOne Œ±] (n : ‚Ñï), Mathlib.Meta.NormNum.IsNat n.rawCast n",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Int.rawCast"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : Ring Œ±] (n : ‚Ñ§), Mathlib.Meta.NormNum.IsInt n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Prod.fst",
   "congrArg",
   "HDiv.hDiv",
   "congr",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (n : ‚Ñ§) (e : M) {t t_n t_d : Mathlib.Tactic.FieldSimp.NF M},\n  t.eval = t_n.eval / t_d.eval ‚Üí ((n, e) ::·µ£ t).eval = ((n, e) ::·µ£ t_n).eval / t_d.eval",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Metric.isBounded_closedBall",
   "Metric.diam",
   "EMetric.diam",
   "HMul.hMul",
   "Int.rawCast",
   "Membership.mem.out",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Ring.sub_pf",
   "And.left",
   "NNReal",
   "Exists.casesOn",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "Set.Ioc",
   "Nat.cast_zero",
   "NNDist.nndist",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "diam_le_radius_of_ultrametric",
   "Eq.mp",
   "Metric.dist_le_diam_of_mem",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "ENNReal.toNNReal",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "eq_of_le_of_ge",
   "And.casesOn",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense"],
  "name": "SphericallyCompleteSpace.exists_dist_lt_diam_iff_isSphericallyDense",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [hiud : IsUltrametricDist Œ±],\n  SphericallyCompleteSpace.IsSphericallyDense Œ± ‚Üî\n    ‚àÄ (z : Œ±) ‚¶Ér r' : NNReal‚¶Ñ,\n      r' < r ‚Üí ‚àÉ x y, x ‚àà Metric.closedBall z ‚Üër ‚àß y ‚àà Metric.closedBall z ‚Üër ‚àß nndist x y ‚àà Set.Ioc r' r",
  "constCategory": "Theorem"},
 {"references":
  ["neg_eq_zero_sub", "Neg.neg", "HSub.hSub", "Eq.symm", "OfNat.ofNat"],
  "name": "zero_sub",
  "constType": "‚àÄ {G : Type u_1} [inst : SubNegMonoid G] (a : G), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "And.right",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_11",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (z : ‚Ü•(ùïú ‚àô x ‚äî F)), ‚àÉ z_1 ‚àà F, ‚ãØ.choose + z_1 = ‚Üëz",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_3",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references": ["SemilinearIsometryClass.norm_map"],
  "name": "LinearIsometry.norm_map",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup E‚ÇÇ] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] (f : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (x : E), ‚Äñf x‚Äñ = ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_2",
   "Norm.norm",
   "lp",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_3",
   "GT.gt",
   "GE.ge",
   "Subtype.val",
   "OfNat.ofNat",
   "ENNReal",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_4",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_1",
   "LE.le",
   "Top.top",
   "setOf"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : ‚Ñï ‚Üí Type u_2) ‚Üí\n      [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)] ‚Üí [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] ‚Üí Submodule ùïú ‚Ü•(lp E ‚ä§)",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.coe", "HasSubset.Subset", "Set", "InfSet.sInf", "setOf"],
  "name": "Submodule.span",
  "constType":
  "(R : Type u_1) ‚Üí\n  {M : Type u_4} ‚Üí\n    [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : _root_.Module R M] ‚Üí Set M ‚Üí Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Submodule.eq_bot_iff",
   "Eq.trans",
   "Membership.mem",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.ne_bot_iff._simp_1_2",
   "Bot.bot",
   "OfNat.ofNat",
   "congrArg",
   "of_eq_true",
   "iff_self",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.ne_bot_iff._simp_1_1",
   "funext",
   "propext"],
  "name": "Submodule.ne_bot_iff",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), p ‚â† ‚ä• ‚Üî ‚àÉ x ‚àà p, x ‚â† 0",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "GT.gt",
  "constType": "{Œ± : Type u} ‚Üí [LT Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_13",
  "constType": "‚àÄ (n k : ‚Ñï), k + 1 ‚â• n + 1 ‚Üí ¬¨k = n ‚Üí ¬¨n ‚â§ k - 1 ‚Üí False",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "PreLp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "lp.instNormedSpace._proof_1"],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_5",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E],\n  ‚àÉ m,\n    Maximal\n      (fun x ‚Ü¶\n        x ‚àà\n          SphericallyCompleteSpace.imm_ext_in_sph_comp E (‚Ü•(lp (fun x ‚Ü¶ E) ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E)\n            (SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E))\n      m",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset", "Set", "Iff.mpr", "Inter.inter", "Set.inter_eq_right"],
  "name": "Set.inter_eq_self_of_subset_right",
  "constType": "‚àÄ {Œ± : Type u} {s t : Set Œ±}, t ‚äÜ s ‚Üí s ‚à© t = t",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Iff.rfl"],
  "name": "Submodule.mem_mk",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : AddSubmonoid M} {x : M} (h : ‚àÄ (c : R) {x : M}, x ‚àà S.carrier ‚Üí c ‚Ä¢ x ‚àà S.carrier),\n  x ‚àà { toAddSubmonoid := S, smul_mem' := h } ‚Üî x ‚àà S",
  "constCategory": "Theorem"},
 {"references": ["rfl", "funext"],
  "name": "forall_congr",
  "constType":
  "‚àÄ {Œ± : Sort u} {p q : Œ± ‚Üí Prop}, (‚àÄ (a : Œ±), p a = q a) ‚Üí (‚àÄ (a : Œ±), p a) = ‚àÄ (a : Œ±), q a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "add_neg", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_neg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsStrictOrderedRing Œ±] {a b : Œ±},\n  a < 0 ‚Üí b < 0 ‚Üí a + b < 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Prime",
  "constType": "‚Ñï ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulActionSemiHomClass.map_smul‚Çõ‚Çó",
   "Eq.trans",
   "of_eq_true",
   "RingHom.id",
   "outParam",
   "HSMul.hSMul",
   "DFunLike.coe",
   "congrArg"],
  "name": "ContinuousLinearMap.map_smul",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_1} [inst : Semiring R‚ÇÅ] {M‚ÇÅ : Type u_4} [inst_1 : TopologicalSpace M‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ]\n  {M‚ÇÇ : Type u_6} [inst_3 : TopologicalSpace M‚ÇÇ] [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : _root_.Module R‚ÇÅ M‚ÇÅ]\n  [inst_6 : _root_.Module R‚ÇÅ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (c : R‚ÇÅ) (x : M‚ÇÅ), f (c ‚Ä¢ x) = c ‚Ä¢ f x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), (y ‚àà f '' s) = ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Eq.ndrec"],
  "name": "Submodule.mk.congr_simp",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (toAddSubmonoid toAddSubmonoid_1 : AddSubmonoid M) (e_toAddSubmonoid : toAddSubmonoid = toAddSubmonoid_1)\n  (smul_mem' : ‚àÄ (c : R) {x : M}, x ‚àà toAddSubmonoid.carrier ‚Üí c ‚Ä¢ x ‚àà toAddSubmonoid.carrier),\n  { toAddSubmonoid := toAddSubmonoid, smul_mem' := smul_mem' } = { toAddSubmonoid := toAddSubmonoid_1, smul_mem' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Submodule.toAddSubmonoid",
   "Submodule.smul_mem'",
   "AddSubmonoid.toAddSubsemigroup"],
  "name": "Submodule.toSubMulAction",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : _root_.Module R M] ‚Üí Submodule R M ‚Üí SubMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "ConditionallyCompleteLattice.csInf_le",
   "Membership.mem",
   "BddBelow"],
  "name": "csInf_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, BddBelow s ‚Üí a ‚àà s ‚Üí sInf s ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mpr",
   "LE.le",
   "Membership.mem",
   "Eq.symm",
   "Submodule.mem_bot",
   "Iff.mp",
   "Bot.bot",
   "eq_bot_iff",
   "OfNat.ofNat"],
  "name": "Submodule.eq_bot_iff",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), p = ‚ä• ‚Üî ‚àÄ x ‚àà p, x = 0",
  "constCategory": "Theorem"},
 {"references": ["LinearMap.map_add", "DFunLike.coe", "LinearMap.map_zero"],
  "name": "LinearMap.toAddMonoidHom",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_5} ‚Üí\n    {M : Type u_8} ‚Üí\n      {M‚ÇÉ : Type u_11} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÉ] ‚Üí\n                [inst_4 : _root_.Module R M] ‚Üí [inst_5 : _root_.Module S M‚ÇÉ] ‚Üí {œÉ : R ‚Üí+* S} ‚Üí (M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ) ‚Üí M ‚Üí+ M‚ÇÉ",
  "constCategory": "Definition"},
 {"references":
  ["LinearEquiv.ofTop._proof_4",
   "LinearEquiv.ofTop._proof_1",
   "RingHom.id",
   "Membership.mem",
   "Top.top",
   "LinearEquiv.ofTop._proof_3",
   "Submodule.subtype"],
  "name": "LinearEquiv.ofTop",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_5} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí {module_M : _root_.Module R M} ‚Üí (p : Submodule R M) ‚Üí p = ‚ä§ ‚Üí ‚Ü•p ‚âÉ‚Çó[R] M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u ‚Üí Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set.Nonempty",
   "Set",
   "Antitone",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter"],
  "name": "SphericallyCompleteSpace.casesOn",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    {motive : SphericallyCompleteSpace Œ± ‚Üí Sort u} ‚Üí\n      (t : SphericallyCompleteSpace Œ±) ‚Üí\n        ((isSphericallyComplete :\n              ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n                (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí\n                  (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty) ‚Üí\n            motive ‚ãØ) ‚Üí\n          motive t",
  "constCategory": "Definition"},
 {"references": ["left_distrib"],
  "name": "mul_add",
  "constType":
  "‚àÄ {R : Type v} [inst : Mul R] [inst_1 : Add R] [LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Unit"],
  "name": "Bool.or",
  "constType": "Bool ‚Üí Bool ‚Üí Bool",
  "constCategory": "Definition"},
 {"references": ["Set.Nonempty", "Set", "Membership.mem", "Classical.choose"],
  "name": "Set.Nonempty.some",
  "constType": "{Œ± : Type u} ‚Üí {s : Set Œ±} ‚Üí s.Nonempty ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Subtype.exists", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_7",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) = ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.IsImmediate._proof_2",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "RingHom.id",
   "LinearMap.range",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.MOrth"],
  "name": "SphericallyCompleteSpace.IsImmediate",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [IsUltrametricDist E] ‚Üí\n            {F : Type v} ‚Üí\n              [inst_4 : SeminormedAddCommGroup F] ‚Üí\n                [inst_5 : NormedSpace ùïú F] ‚Üí [IsUltrametricDist F] ‚Üí (E ‚Üí‚Çó·µ¢[ùïú] F) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass.zero_add"],
  "name": "zero_add",
  "constType": "‚àÄ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "sup_eq_left", "Iff.mpr", "LE.le"],
  "name": "sup_of_le_left",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, b ‚â§ a ‚Üí a ‚äî b = a",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.Data.Subtype.Basic.0.Subtype.forall.match_1_1"],
  "name": "Subtype.forall",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) ‚Üî ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.spherically_dense",
  "constType":
  "‚àÄ {Œ± : Type u_1} {inst : PseudoMetricSpace Œ±} [self : SphericallyCompleteSpace.IsSphericallyDense Œ±] (c : Œ±)\n  (r : NNReal), Metric.diam (Metric.closedBall c ‚Üër) = ‚Üër",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim"],
  "name": "forall_const",
  "constType":
  "‚àÄ {b : Prop} (Œ± : Sort u_1) [i : Nonempty Œ±], (‚àÄ (a : Œ±), b) ‚Üî b",
  "constCategory": "Theorem"},
 {"references": ["padicNorm", "CauSeq.Completion.Cauchy", "Nat.Prime"],
  "name": "Padic",
  "constType": "(p : ‚Ñï) ‚Üí [Fact (Nat.Prime p)] ‚Üí Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_4",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [IsUltrametricDist E],\n  SphericallyCompleteSpace (‚Ü•(lp (fun x ‚Ü¶ E) ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_eq_left", "HasSubset.Subset", "Set", "Iff.mpr", "Inter.inter"],
  "name": "Set.inter_eq_self_of_subset_left",
  "constType": "‚àÄ {Œ± : Type u} {s t : Set Œ±}, s ‚äÜ t ‚Üí s ‚à© t = s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "zero_add",
   "Eq.trans",
   "of_eq_true",
   "HSMul.hSMul",
   "zero_zsmul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.zero_termg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (x a : Œ±), Mathlib.Tactic.Abel.termg 0 x a = a",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "HMul.hMul",
   "Iff.rfl",
   "OfNat.ofNat",
   "le_mul_inv_iff‚ÇÄ",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "LE.le",
   "id",
   "Eq.mpr",
   "propext"],
  "name": "le_div_iff‚ÇÄ",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [MulPosReflectLT G‚ÇÄ] {a b c : G‚ÇÄ},\n  0 < c ‚Üí (a ‚â§ b / c ‚Üî a * c ‚â§ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.mp",
  "constType": "{Œ± Œ≤ : Sort u} ‚Üí Œ± = Œ≤ ‚Üí Œ± ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.unfold_sub",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionMonoid Œ±] (a b c : Œ±), a + -b = c ‚Üí a - b = c",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.pi",
  "constType":
  "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí Set Œπ ‚Üí ((i : Œπ) ‚Üí Set (Œ± i)) ‚Üí Set ((i : Œπ) ‚Üí Œ± i)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "SphericallyCompleteSpace._aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___unexpand_SphericallyCompleteSpace_MOrth_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_trans"],
  "name": "le_trans",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b c : Œ±}, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_3",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Subtype.val", "OfNat.ofNat"],
  "name": "NNReal.toReal",
  "constType": "NNReal ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ",
   "Set",
   "Disjoint",
   "Set.univ_disjoint",
   "EmptyCollection.emptyCollection",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_10",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Disjoint Set.univ s = (s = ‚àÖ)",
  "constCategory": "Theorem"},
 {"references": ["Semigroup.mul_assoc"],
  "name": "mul_assoc",
  "constType":
  "‚àÄ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Eq.trans",
   "add_add_add_comm",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "heq_of_eq",
   "Subtype.val",
   "Set.Elem",
   "RingHom.id",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
   "eq_of_heq",
   "Submodule.mem_span_singleton",
   "funext",
   "forall_congr",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "ContinuousLinearMap.map_smul",
   "And.left",
   "rfl",
   "Submodule.toSubMulAction",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Exists.choose_spec",
   "Norm.norm",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "Submodule.smul_mem",
   "And.right",
   "Mathlib.Tactic.Abel.term_add_constg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "map_add",
   "zero_add",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.Abel.term_atomg",
   "Exists.choose.congr_simp",
   "Eq.mp",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "DFunLike.coe",
   "congrArg",
   "ContinuousLinearMap.map_add",
   "Subtype.prop",
   "Submodule.mem_sup",
   "congr",
   "eq_and_eq_of_add_eq_add_of_not_mem_submodule_span_singleton",
   "Mathlib.Tactic.Abel.termg",
   "Not",
   "Set.Nonempty",
   "Set",
   "smul_left_injective",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Exists.choose",
   "OfNat.ofNat",
   "Submodule.add_mem",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Max.max",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
   "of_eq_true",
   "add_assoc",
   "smul_smul",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "smul_add",
   "Ne",
   "add_smul"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (ha1 : a ‚àâ D) {F : Type u_3}\n  [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ùïú F]\n  [hsc : SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) {ùí∞ : Set (E ‚ÜíL[ùïú] F)} (hùí∞ : ùí∞.Nonempty) {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù}\n  (hŒµ1 : ‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) (hŒµ2 : ‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V))\n  (hŒµ3 : ‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ),\n  IsLinearMap ùïú (SphericallyCompleteSpace.rooij_lemma_4_4_T ha1 S hùí∞ hŒµ1 hŒµ2 hŒµ3)",
  "constCategory": "Definition"},
 {"references": [],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_2",
  "constType": "‚àÄ {E : Type u_1} [NormedAddCommGroup E], Nonempty E",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) ‚Üí [h : Decidable p] ‚Üí Bool",
  "constCategory": "Definition"},
 {"references":
  ["dist_self_add_right",
   "HAdd.hAdd",
   "Norm.norm",
   "dist_comm",
   "Dist.dist",
   "id",
   "Eq.mpr",
   "congrArg"],
  "name": "dist_self_add_left",
  "constType":
  "‚àÄ {E : Type u_2} [inst : SeminormedAddCommGroup E] (a b : E), dist (a + b) a = ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["setOf"],
  "name": "Set.range",
  "constType": "{Œ± : Type u} ‚Üí {Œπ : Sort u_1} ‚Üí (Œπ ‚Üí Œ±) ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.symm",
   "id",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Eq.mpr",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Prod.fst",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons_eq_eval_of_eq_of_eq",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (r : ‚Ñ§) (x : M) {t t' l' : Mathlib.Tactic.FieldSimp.NF M},\n  t.eval = t'.eval ‚Üí ((r, x) ::·µ£ t').eval = l'.eval ‚Üí ((r, x) ::·µ£ t).eval = l'.eval",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "HDiv.hDiv",
   "Inv.inv",
   "LE.le",
   "HMul.hMul",
   "mul_le_of_le_mul_inv‚ÇÄ",
   "OfNat.ofNat"],
  "name": "mul_le_of_le_div‚ÇÄ",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [MulPosReflectLT G‚ÇÄ] {a b c : G‚ÇÄ},\n  0 ‚â§ b ‚Üí 0 ‚â§ c ‚Üí a ‚â§ b / c ‚Üí a * c ‚â§ b",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "LinearMap.ker",
   "Membership.mem",
   "DFunLike.coe",
   "OfNat.ofNat",
   "propext",
   "LinearMap.mem_ker"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_2",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_11} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] {f : F} {y : M},\n  (y ‚àà LinearMap.ker f) = (f y = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddSubsemigroup.mem_mk", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_5",
  "constType":
  "‚àÄ {M : Type u_1} [inst : Add M] {s : Set M} {x : M} (h_add : ‚àÄ {a b : M}, a ‚àà s ‚Üí b ‚àà s ‚Üí a + b ‚àà s),\n  (x ‚àà { carrier := s, add_mem' := h_add }) = (x ‚àà s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.Coeffs.ofList",
  "constType": "List ‚Ñ§ ‚Üí Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["le_refl", "LE.le", "id", "Eq.mpr", "congrArg"],
  "name": "le_of_eq",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a = b ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Dist.dist",
  "constType": "{Œ± : Type u_3} ‚Üí [self : Dist Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["HasSubset.Subset", "Set", "Iff.rfl", "setOf"],
  "name": "Set.setOf_subset_setOf",
  "constType":
  "‚àÄ {Œ± : Type u} {p q : Œ± ‚Üí Prop}, {a | p a} ‚äÜ {a | q a} ‚Üî ‚àÄ (a : Œ±), p a ‚Üí q a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.mpr", "iSup_congr_Prop"],
  "name": "Set.iUnion_congr_Prop",
  "constType":
  "‚àÄ {Œ± : Type u_1} {p q : Prop} {f‚ÇÅ : p ‚Üí Set Œ±} {f‚ÇÇ : q ‚Üí Set Œ±} (pq : p ‚Üî q),\n  (‚àÄ (x : q), f‚ÇÅ ‚ãØ = f‚ÇÇ x) ‚Üí Set.iUnion f‚ÇÅ = Set.iUnion f‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "_private.Mathlib.Order.SetNotation.0.Set.mem_iInter.match_1_1",
   "Set",
   "Membership.mem",
   "Set.iInter",
   "Set.range",
   "setOf"],
  "name": "Set.mem_iInter",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, x ‚àà ‚ãÇ i, s i ‚Üî ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.not_sat_of_isImpossible",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.Constraint.not_sat'_of_isImpossible",
  "constType":
  "‚àÄ {c : Omega.Constraint}, c.isImpossible = true ‚Üí ‚àÄ {x y : Omega.Coeffs}, ¬¨c.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "le_refl",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "eq_true",
   "Submodule.span",
   "Set.iInter",
   "funext",
   "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_1",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "Set.iInter_congr_Prop",
   "Norm.norm",
   "Set.mem_range._simp_1",
   "And.right",
   "SphericallyCompleteSpace.Orth",
   "Set.singleton_subset_iff._simp_1",
   "Set.mem_iInter._simp_1",
   "Exists.casesOn",
   "SetLike.coe",
   "lt_iff_not_ge",
   "HasSubset.Subset",
   "Iff.of_eq",
   "id",
   "Set.ext",
   "Eq.mpr",
   "implies_congr_ctx",
   "setOf",
   "Submodule.nonempty",
   "Eq.mp",
   "Submodule.mem_span_singleton_self",
   "Metric.le_infDist",
   "Subspace",
   "Set.range",
   "congrArg",
   "ZeroMemClass.zero_mem",
   "congr",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "Not",
   "eq_of_le_of_not_lt",
   "Set",
   "dist_zero_right",
   "OfNat.ofNat",
   "LT.lt",
   "forall_const._simp_1",
   "Metric.infDist_lt_iff",
   "of_eq_true",
   "SetLike.mem_coe._simp_1",
   "LE.le",
   "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_2",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.morth_iff_forall_orth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ùïú E),\n  SphericallyCompleteSpace.MOrth ùïú x F ‚Üî ‚àÄ y ‚àà F, x ‚üÇ[ùïú] y",
  "constCategory": "Theorem"},
 {"references": ["Classical.propDecidable", "Decidable.not_and_iff_not_or_not"],
  "name": "not_and_or",
  "constType": "‚àÄ {a b : Prop}, ¬¨(a ‚àß b) ‚Üî ¬¨a ‚à® ¬¨b",
  "constCategory": "Theorem"},
 {"references": ["Not", "LT.lt", "left_lt_sup", "Max.max", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_6",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, (a < a ‚äî b) = ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "eq_true",
   "le_of_not_gt",
   "Eq.symm",
   "Submodule.exists_smul_notMem_of_rank_lt",
   "Nat.ble",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div'",
   "inv_pos._simp_1",
   "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
   "congr_arg",
   "Set.mem_image",
   "true_and",
   "SetLike.coe",
   "one_smul",
   "gt_iff_lt._simp_1",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_14",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "CancelDenoms.add_subst",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Prod.fst",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "_private.Mathlib.Algebra.Order.Floor.Ring.0.Mathlib.Meta.Positivity.nat_ceil_pos",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_11",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_8",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "eq_self",
   "sub_sub",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "Ne",
   "eq_of_le_of_ge",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_15",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
   "Membership.mem",
   "Inter.inter",
   "Right.add_pos_of_nonneg_of_pos",
   "Subtype.mk.congr_simp",
   "GT.gt",
   "GE.ge",
   "Nat.cast_pos'",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "forall_congr",
   "Mathlib.Tactic.Linarith.add_neg",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "Mathlib.Tactic.FieldSimp.subst_add",
   "add_nonneg",
   "And.right",
   "mul_add",
   "Mathlib.Tactic.Ring.mul_zero",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_6",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Module.rank",
   "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
   "AddMemClass.add_mem",
   "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "NNReal.toReal",
   "le_of_forall_pos_le_add",
   "Metric.le_infDist",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_eq_eval_of_eq_of_eq",
   "Nat.cast_nonneg'",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_10",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "Not",
   "Set.Nonempty",
   "Inv.inv",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
   "Mathlib.Tactic.Ring.cast_pos",
   "zero_lt_one",
   "Mathlib.Tactic.Ring.add_congr",
   "sub_sub_sub_cancel_right",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_congr",
   "add_assoc",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "CancelDenoms.mul_subst",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "Mathlib.Tactic.Ring.one_mul",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "Module.finrank_eq_rank'",
   "rfl",
   "Norm.norm",
   "Exists.choose_spec",
   "NNReal",
   "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
   "one_ne_zero",
   "Prod.snd",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_5",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_9",
   "Nat.rawCast",
   "one_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "dist_eq_norm",
   "Nat.cast_lt",
   "one_div",
   "Nat.ceil",
   "and_true",
   "div_pos",
   "Subspace",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_4",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "LT.lt.ne'",
   "congr",
   "Mathlib.Tactic.Ring.mul_add",
   "sub_mem",
   "propext",
   "lt_of_not_ge",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_7",
   "dist_comm",
   "OfNat.ofNat",
   "Metric.infDist_nonneg",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
   "Set.mem_of_mem_inter_left",
   "congr_arg‚ÇÇ",
   "inferInstance",
   "antitone_nat_of_succ_le",
   "neg_neg_of_pos",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_3",
   "Mathlib.Tactic.FieldSimp.NF.cons_pos",
   "HDiv.hDiv",
   "Module.finrank",
   "Mathlib.Meta.NormNum.isNat_add",
   "funext",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_13",
   "HSub.hSub",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_2",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.FieldSimp.NF.inv_eq_eval",
   "Nat.le_ceil",
   "Neg.neg",
   "add_pos",
   "Mathlib.Tactic.Linarith.natCast_nonneg",
   "Mathlib.Tactic.Linarith.without_one_mul",
   "CancelDenoms.sub_subst",
   "Set.image",
   "inv_le_iff_one_le_mul‚ÇÄ'",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "HSMul.hSMul",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball",
   "div_one",
   "Submodule.nonempty",
   "sub_eq_zero",
   "FiniteDimensional",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_12",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_16",
   "congrArg",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Mathlib.Tactic.FieldSimp.eq_div_of_subst",
   "Exists.choose",
   "Cardinal",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "exists_prop_congr",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "lt_mul_iff_one_lt_right'._simp_4",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (F : Subspace ùïú E) [sF : SphericallyCompleteSpace ‚Ü•F]\n  [FiniteDimensional ùïú E], Module.finrank ùïú ‚Ü•F < Module.finrank ùïú E ‚Üí ‚àÉ x, x ‚â† 0 ‚àß SphericallyCompleteSpace.MOrth ùïú x F",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_iff_eq_add'",
   "sub_eq_iff_eq_add",
   "sub_add_eq_add_sub",
   "Eq.trans",
   "eq_comm",
   "congrArg",
   "HAdd.hAdd",
   "iff_self",
   "of_eq_true",
   "congr",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "add_comm",
   "propext"],
  "name": "sub_eq_sub_iff_add_eq_add",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddCommGroup G] {a b c d : G}, a - b = c - d ‚Üî a + d = c + b",
  "constCategory": "Theorem"},
 {"references": ["ZeroLEOneClass.zero_le_one"],
  "name": "zero_le_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [ZeroLEOneClass Œ±], 0 ‚â§ 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual", "Set.Nonempty", "Set", "Set.Nonempty.csSup_mem", "Set.Finite"],
  "name": "Set.Nonempty.csInf_mem",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : ConditionallyCompleteLinearOrder Œ±] {s : Set Œ±}, s.Nonempty ‚Üí s.Finite ‚Üí sInf s ‚àà s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter",
   "OfNat.ofNat",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Metric.closedBall",
   "Filter.atTop",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter",
   "Antitone",
   "id",
   "Eq.mpr",
   "Filter.Tendsto",
   "nhds",
   "propext"],
  "name": "SphericallyCompleteSpace.instCompleteOfSphericallyComplete",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [sc : SphericallyCompleteSpace Œ±], CompleteSpace Œ±",
  "constCategory": "Theorem"},
 {"references":
  ["LinearEquiv.symm._proof_1",
   "LinearEquiv.toEquiv",
   "Equiv.left_inv",
   "LinearMap.inverse",
   "LinearEquiv.toLinearMap",
   "DFunLike.coe",
   "LinearEquiv.invFun",
   "LinearEquiv.symm._proof_2",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.symm",
   "LinearEquiv.right_inv",
   "LinearEquiv.left_inv"],
  "name": "LinearEquiv.symm",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_7} ‚Üí\n      {M‚ÇÇ : Type u_9} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                {module_M : _root_.Module R M} ‚Üí\n                  {module_S_M‚ÇÇ : _root_.Module S M‚ÇÇ} ‚Üí\n                    {œÉ : R ‚Üí+* S} ‚Üí\n                      {œÉ' : S ‚Üí+* R} ‚Üí\n                        {re‚ÇÅ : RingHomInvPair œÉ œÉ'} ‚Üí {re‚ÇÇ : RingHomInvPair œÉ' œÉ} ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M‚ÇÇ ‚âÉ‚Çõ‚Çó[œÉ'] M",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "AddMemClass.add_mem"],
  "name": "Submodule.add_mem",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x y : M}, x ‚àà p ‚Üí y ‚àà p ‚Üí x + y ‚àà p",
  "constCategory": "Theorem"},
 {"references":
  ["lt_add_of_pos_right", "AddLeftStrictMono", "zero_lt_one", "OfNat.ofNat"],
  "name": "lt_add_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : One Œ±] [inst_1 : AddZeroClass Œ±] [inst_2 : PartialOrder Œ±] [ZeroLEOneClass Œ±] [NeZero 1]\n  [AddLeftStrictMono Œ±] (a : Œ±), a < a + 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "trivial"],
  "name": "of_eq_true",
  "constType": "‚àÄ {p : Prop}, p = True ‚Üí p",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_7",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "‚àÄ {R : Type u_2} [inst : CommRing R] {a a' b : R}, a = a' ‚Üí -a' = b ‚Üí -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "LT.lt", "lt_iff_le_not_ge", "LE.le", "Iff.mp", "And.left"],
  "name": "le_of_lt",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup.add_assoc"],
  "name": "add_assoc",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_8",
  "constType": "‚àÄ {b a : Prop}, (‚àÉ (_ : a), b) = (a ‚àß b)",
  "constCategory": "Theorem"},
 {"references": ["Set", "IsSeqClosed", "SequentialSpace.isClosed_of_seq"],
  "name": "IsSeqClosed.isClosed",
  "constType":
  "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [SequentialSpace X] {s : Set X}, IsSeqClosed s ‚Üí IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_5",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Submodule.mem_mk",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_3",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : AddSubmonoid M} {x : M} (h : ‚àÄ (c : R) {x : M}, x ‚àà S.carrier ‚Üí c ‚Ä¢ x ‚àà S.carrier),\n  (x ‚àà { toAddSubmonoid := S, smul_mem' := h }) = (x ‚àà S)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "HSMul.hSMul",
   "Eq.symm",
   "add_comm",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.const_add_termg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (k : Œ±) (n : ‚Ñ§) (x a a' : Œ±),\n  k + a = a' ‚Üí k + Mathlib.Tactic.Abel.termg n x a = Mathlib.Tactic.Abel.termg n x a'",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÉ a, p a ‚àß a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_10",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references":
  ["or_false",
   "iff_self",
   "smul_eq_zero._simp_1",
   "Eq.trans",
   "of_eq_true",
   "eq_false",
   "HSMul.hSMul",
   "Ne",
   "OfNat.ofNat",
   "congrArg"],
  "name": "smul_eq_zero_iff_left",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] [NoZeroSMulDivisors R M]\n  {c : R} {x : M}, x ‚â† 0 ‚Üí (c ‚Ä¢ x = 0 ‚Üî c = 0)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LE.le", "add_lt_of_neg_of_le", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsStrictOrderedRing Œ±] {a b c : Œ±},\n  a < 0 ‚Üí b ‚â§ c ‚Üí a + b < c",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "exists_apply_eq_apply",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} (f : Œ± ‚Üí Œ≤) (a' : Œ±), ‚àÉ a, f a = f a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.trans",
  "constType": "‚àÄ {Œ± : Sort u} {a b c : Œ±}, a = b ‚Üí b = c ‚Üí a = c",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "dist_eq_norm",
   "Eq.trans",
   "Membership.mem",
   "Filter.atTop_basis",
   "IsDirectedOrder",
   "Metric.ball",
   "congrArg",
   "Set.mem_Ici._simp_1",
   "iff_self",
   "forall_congr",
   "funext",
   "Dist.dist",
   "Metric.mem_ball._simp_1",
   "HSub.hSub",
   "Filter.HasBasis.tendsto_iff",
   "nhds",
   "Filter.Tendsto",
   "Iff.trans",
   "Norm.norm",
   "Set",
   "Metric.nhds_basis_ball",
   "true_and",
   "OfNat.ofNat",
   "LT.lt",
   "Set.Ici",
   "Filter.atTop",
   "of_eq_true",
   "LE.le"],
  "name": "NormedAddCommGroup.tendsto_atTop",
  "constType":
  "‚àÄ {Œ± : Type u_2} [Nonempty Œ±] [inst : Preorder Œ±] [IsDirectedOrder Œ±] {Œ≤ : Type u_5} [inst_2 : SeminormedAddCommGroup Œ≤]\n  {f : Œ± ‚Üí Œ≤} {b : Œ≤}, Filter.Tendsto f Filter.atTop (nhds b) ‚Üî ‚àÄ (Œµ : ‚Ñù), 0 < Œµ ‚Üí ‚àÉ N, ‚àÄ (n : Œ±), N ‚â§ n ‚Üí ‚Äñf n - b‚Äñ < Œµ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearMap.toAddHom",
  "constType":
  "{R : Type u_14} ‚Üí\n  {S : Type u_15} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {M : Type u_16} ‚Üí\n            {M‚ÇÇ : Type u_17} ‚Üí\n              [inst_2 : AddCommMonoid M] ‚Üí\n                [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                  [inst_4 : _root_.Module R M] ‚Üí [inst_5 : _root_.Module S M‚ÇÇ] ‚Üí (M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M ‚Üí‚Çô+ M‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "eq_true",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh",
   "Set.iInter",
   "Subtype.val",
   "quotient_norm_mk_eq",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Eq.symm",
   "QuotientAddGroup.mk'",
   "csInf_le",
   "Norm.norm",
   "NNReal",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_7",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_3",
   "Submodule.toAddSubgroup",
   "add_zero",
   "Exists.casesOn",
   "implies_true",
   "Set.image",
   "SetLike.coe",
   "IsUltrametricDist.dist_triangle_max",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_10",
   "Antitone",
   "Iff.mpr",
   "lowerBounds",
   "id",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "Eq.mpr",
   "setOf",
   "dist_eq_norm",
   "HasQuotient.Quotient",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_8",
   "Eq.mp",
   "le_trans",
   "NNReal.toReal",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_2",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_6",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_3",
   "Subtype.prop",
   "congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_4",
   "InfSet.sInf",
   "Dist.dist",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_9",
   "sup_le_iff",
   "propext",
   "dist_self",
   "Set.Nonempty",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_4",
   "Set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "StrictAnti",
   "Metric.closedBall",
   "and_self",
   "Max.max",
   "lt_add_one",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_5",
   "QuotientAddGroup.mk",
   "inferInstance",
   "antitone_nat_of_succ_le",
   "Nat.le_add_right",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh_prop"],
  "name": "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [iud : IsUltrametricDist E] [scsk : SphericallyCompleteSpace E] {F : Submodule ùïú E},\n  SphericallyCompleteSpace (E ‚ß∏ F)",
  "constCategory": "Theorem"},
 {"references": ["Set.mem_setOf", "Set", "Membership.mem", "Iff.mp", "setOf"],
  "name": "Membership.mem.out",
  "constType": "‚àÄ {Œ± : Type u} {a : Œ±} {p : Œ± ‚Üí Prop}, a ‚àà {x | p x} ‚Üí p a",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_7",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.rawCast",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1_1",
   "Int.cast"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "‚àÄ {Œ± : Type u} {a : Œ±} {n : ‚Ñ§} [inst : Ring Œ±], Mathlib.Meta.NormNum.IsInt a n ‚Üí a = n.rawCast",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Eq.symm"],
  "name": "le_of_eq_of_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} {a b c : Œ±} [inst : LE Œ±], a = b ‚Üí b ‚â§ c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.MOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.MOrth.eq_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ùïú E),\n  SphericallyCompleteSpace.MOrth ùïú x F = (Metric.infDist x ‚ÜëF = ‚Äñx‚Äñ)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "sub_eq_add_neg",
  "constType":
  "‚àÄ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "Iff.rfl"],
  "name": "iff_self",
  "constType": "‚àÄ (p : Prop), (p ‚Üî p) = True",
  "constCategory": "Theorem"},
 {"references": ["add_lt_of_le_of_neg", "LT.lt", "LE.le", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.Linarith.add_lt_of_le_of_neg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsStrictOrderedRing Œ±] {a b c : Œ±},\n  b ‚â§ c ‚Üí a < 0 ‚Üí b + a < c",
  "constCategory": "Theorem"},
 {"references": ["Set", "EMetric.diam", "ENNReal.toReal_nonneg"],
  "name": "Metric.diam_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u} {s : Set Œ±} [inst : PseudoMetricSpace Œ±], 0 ‚â§ Metric.diam s",
  "constCategory": "Theorem"},
 {"references":
  ["dist_eq_norm", "Norm.norm", "Dist.dist", "HSub.hSub", "Eq.symm"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_7",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), ‚Äña - b‚Äñ = dist a b",
  "constCategory": "Theorem"},
 {"references": ["Module.finrank_eq_rank", "FiniteDimensional"],
  "name": "Module.finrank_eq_rank'",
  "constType":
  "‚àÄ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]\n  [FiniteDimensional K V], ‚Üë(Module.finrank K V) = Module.rank K V",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.PropLemmas.0.forall_exists_index.match_1_1"],
  "name": "forall_exists_index",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) ‚Üî ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_21",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÉ a, p a ‚àß a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "rfl",
  "constType": "‚àÄ {Œ± : Sort u} {a : Œ±}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["dist_nonneg",
   "Metric.closedBall",
   "_private.Mathlib.Topology.MetricSpace.Pseudo.Defs.0.Metric.nonempty_closedBall.match_1_1",
   "Set.Nonempty",
   "Set",
   "Dist.dist",
   "Membership.mem",
   "LE.le",
   "Metric.mem_closedBall_self",
   "OfNat.ofNat",
   "LE.le.trans"],
  "name": "Metric.nonempty_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, (Metric.closedBall x Œµ).Nonempty ‚Üî 0 ‚â§ Œµ",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "OfNat.ofNat"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["exists_and_left", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_13",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {b : Prop}, (‚àÉ x, b ‚àß p x) = (b ‚àß ‚àÉ x, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_6",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Set.forall_mem_image",
   "Iff.trans",
   "Set.Nonempty",
   "isGLB_ciInf_set",
   "Set",
   "Membership.mem",
   "BddBelow",
   "Subtype.val",
   "Set.Elem",
   "Set.image",
   "LE.le",
   "lowerBounds",
   "iInf",
   "le_isGLB_iff"],
  "name": "le_ciInf_set_iff",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {Œπ : Type u_5} {s : Set Œπ} {f : Œπ ‚Üí Œ±} {a : Œ±},\n  s.Nonempty ‚Üí BddBelow (f '' s) ‚Üí (a ‚â§ ‚®Ö i, f ‚Üëi ‚Üî ‚àÄ i ‚àà s, a ‚â§ f i)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_4",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "zero_le_one", "eq_true", "OfNat.ofNat"],
  "name": "zero_le_one._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [ZeroLEOneClass Œ±], (0 ‚â§ 1) = True",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.rfl", "Set.Elem"],
  "name": "Set.finite_coe_iff",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Finite ‚Üës ‚Üî s.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Inter.inter", "Membership.mem", "Set.mem_inter_iff", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} (x : Œ±) (a b : Set Œ±), (x ‚àà a ‚à© b) = (x ‚àà a ‚àß x ‚àà b)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_le_of_gt", "LT.lt", "Not", "LE.le", "Nat.ge_of_not_lt", "flip"],
  "name": "Nat.not_lt",
  "constType": "‚àÄ {a b : ‚Ñï}, ¬¨a < b ‚Üî b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_infinite_iff_finite", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_12",
  "constType": "‚àÄ {Œ± : Sort u_1}, (¬¨Infinite Œ±) = Finite Œ±",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ._simp_2",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NNDist.nndist",
  "constType": "{Œ± : Type u_3} ‚Üí [self : NNDist Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí NNReal",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.byContradiction", "Classical.propDecidable"],
  "name": "Classical.byContradiction",
  "constType": "‚àÄ {p : Prop}, (¬¨p ‚Üí False) ‚Üí p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_3} ‚Üí [inst : AddZeroClass M] ‚Üí AddSubmonoid M ‚Üí AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references": ["Not", "not_and", "propext"],
  "name": "Mathlib.Tactic.Push.not_and_eq",
  "constType": "‚àÄ (p q : Prop), (¬¨(p ‚àß q)) = (p ‚Üí ¬¨q)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast"],
  "name": "Nat.rawCast",
  "constType": "{Œ± : Type u} ‚Üí [AddMonoidWithOne Œ±] ‚Üí ‚Ñï ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.antitone_of_countable_chain_of_ball._simp_1_2",
   "le_trans",
   "Membership.mem",
   "Inter.inter",
   "NNReal.toReal",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_3",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "Prod.fst",
   "HDiv.hDiv",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_9",
   "InfSet.sInf",
   "And.left",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_4",
   "Set.Nonempty",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.eq_def",
   "Exists.choose_spec",
   "Set",
   "And.right",
   "NNReal",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.smaller_radius",
   "Prod.snd",
   "Exists.choose",
   "HPow.hPow",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_10",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_2",
   "Nonempty.some",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_8",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.match_1",
   "Metric.closedBall",
   "of_eq_true",
   "le_of_lt",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_1",
   "Min.min",
   "LE.le",
   "id",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric",
   "Eq.mpr",
   "antitone_nat_of_succ_le",
   "setOf"],
  "name":
  "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.antitone_of_countable_chain_of_ball",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [iud : IsUltrametricDist Œ±] [SphericallyCompleteSpace Œ±]\n  {S : Set (Œ± √ó NNReal)} [hS : Nonempty ‚ÜëS],\n  (‚àÄ (w1 w2 : ‚ÜëS), (Metric.closedBall (‚Üëw1).1 ‚Üë(‚Üëw1).2 ‚à© Metric.closedBall (‚Üëw2).1 ‚Üë(‚Üëw2).2).Nonempty) ‚Üí\n    ‚àÄ (hw : ‚àÄ w ‚àà S, sInf {x | ‚àÉ w ‚àà S, w.2 = x} < w.2),\n      Antitone fun n ‚Ü¶\n        Metric.closedBall (‚Üë(SphericallyCompleteSpace.countable_chain_of_ball‚úù hw n)).1\n          ‚Üë(‚Üë(SphericallyCompleteSpace.countable_chain_of_ball‚úù¬π hw n)).2",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mp",
   "eq_false",
   "id",
   "Classical.not_imp._simp_1",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg"],
  "name": "Lean.Grind.eq_false_of_imp_eq_false",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üí b) = False ‚Üí b = False",
  "constCategory": "Theorem"},
 {"references": ["Set.Pairwise", "Set"],
  "name": "IsChain",
  "constType": "{Œ± : Type u_1} ‚Üí (Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["_private.Init.Prelude.0.Or.elim.match_1_1"],
  "name": "Or.elim",
  "constType": "‚àÄ {a b c : Prop}, a ‚à® b ‚Üí (a ‚Üí c) ‚Üí (b ‚Üí c) ‚Üí c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNat_mul.match_1_1",
   "Nat.cast",
   "Eq.symm",
   "HMul.hMul",
   "Nat.cast_mul"],
  "name": "Mathlib.Meta.NormNum.isNat_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {f : Œ± ‚Üí Œ± ‚Üí Œ±} {a b : Œ±} {a' b' c : ‚Ñï},\n  f = HMul.hMul ‚Üí\n    Mathlib.Meta.NormNum.IsNat a a' ‚Üí\n      Mathlib.Meta.NormNum.IsNat b b' ‚Üí a'.mul b' = c ‚Üí Mathlib.Meta.NormNum.IsNat (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Std.le_trans",
   "Not.elim",
   "Eq.mp",
   "And.right",
   "LE.le",
   "id",
   "Eq.mpr",
   "And.left",
   "_private.Init.Data.Order.Lemmas.0.Std.instAsymmLtOfLawfulOrderLT._simp_1"],
  "name": "Std.lt_of_lt_of_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LE Œ±] [inst_1 : LT Œ±] [Trans (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) fun x1 x2 ‚Ü¶ x1 ‚â§ x2]\n  [LawfulOrderLT Œ±] {a b c : Œ±}, a < b ‚Üí b ‚â§ c ‚Üí a < c",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "Inv.inv", "Eq.symm", "inv_eq_one_div", "OfNat.ofNat"],
  "name": "one_div",
  "constType": "‚àÄ {G : Type u_1} [inst : DivInvMonoid G] (a : G), 1 / a = a‚Åª¬π",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "eq_true", "le_sup_left"],
  "name": "le_sup_left._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, (a ‚â§ a ‚äî b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "NNReal.toReal",
   "GT.gt",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball._proof_3",
   "Subtype.val",
   "Set.Countable",
   "Set.Elem",
   "congrArg",
   "Dense",
   "Prod.fst",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
   "Eq.symm",
   "Denumerable.ofNat",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "Not",
   "Set",
   "NNReal",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball._proof_1",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Unit",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball",
   "HAdd.hAdd",
   "eq_self",
   "Metric.closedBall",
   "of_eq_true",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball.eq_def",
   "HasSubset.Subset",
   "NNDist.nndist",
   "id",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball.match_1",
   "Eq.mpr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "TopologicalSpace.SeparableSpace.exists_countable_dense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_radius_eq",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [hiud : IsUltrametricDist Œ±]\n  [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] [nemp : Nonempty Œ±] [hsep : TopologicalSpace.SeparableSpace Œ±]\n  (hŒ±' : Denumerable ‚Üë‚ãØ.choose) (n : ‚Ñï),\n  (SphericallyCompleteSpace.fuck_chain_of_ball‚úù hŒ±' n).2 = SphericallyCompleteSpace.fuck_radius‚úù Œ± n",
  "constCategory": "Theorem"},
 {"references": ["FloorSemiring.ceil"],
  "name": "Nat.ceil",
  "constType":
  "{Œ± : Type u_2} ‚Üí [inst : Semiring Œ±] ‚Üí [inst_1 : PartialOrder Œ±] ‚Üí [FloorSemiring Œ±] ‚Üí Œ± ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["rfl", "Set", "Singleton.singleton", "Submodule.subset_span"],
  "name": "Submodule.mem_span_singleton_self",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (x : M),\n  x ‚àà R ‚àô x",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "PosMulReflectLT.toPosMulStrictMono",
   "HMul.hMul",
   "OfNat.ofNat",
   "mul_pos",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "Iff.mpr",
   "id",
   "Eq.mpr",
   "inv_pos"],
  "name": "div_pos",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a b : G‚ÇÄ},\n  0 < a ‚Üí 0 < b ‚Üí 0 < a / b",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "map_neg", "map_sub'"],
  "name": "map_sub",
  "constType":
  "‚àÄ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : AddGroup G]\n  [inst_2 : SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (a b : G), f (a - b) = f a - f b",
  "constCategory": "Theorem"},
 {"references": ["le_refl"],
  "name": "le_rfl",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, a ‚â§ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubgroup.toAddCommGroup._proof_1",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddCommGroup G], AddSubgroupClass (AddSubgroup G) G",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "eq_true", "SetLike.coe_mem", "Subtype.val"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_24",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ‚Ü•p), (‚Üëx ‚àà p) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name":
  "SphericallyCompleteSpace.instQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄOfIsUltrametricDist",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] [IsUltrametricDist ùïú],\n  SphericallyCompleteSpace (‚Ü•(lp (fun x ‚Ü¶ ùïú) ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ ùïú)",
  "constCategory": "Theorem"},
 {"references": ["Set.Ioc", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_Ioc",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b x : Œ±}, x ‚àà Set.Ioc a b ‚Üî a < x ‚àß x ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congr",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±}, f‚ÇÅ = f‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ ‚Üí f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "abs_norm_sub_norm_le",
   "HSub.hSub",
   "le_abs_self",
   "abs",
   "LE.le.trans"],
  "name": "norm_sub_norm_le",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), ‚Äña‚Äñ - ‚Äñb‚Äñ ‚â§ ‚Äña - b‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "NNReal.toReal",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_1",
   "Subtype.val",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_3",
   "DFunLike.coe",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_5",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_1",
   "HSub.hSub",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_2",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section.match_1",
   "QuotientAddGroup.mk'",
   "PreLp",
   "Norm.norm",
   "Set",
   "NNReal",
   "Submodule.quotientRel",
   "Nat.brecOn",
   "Submodule.toAddSubgroup",
   "Exists.choose",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section._proof_4",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "StrictAnti",
   "ENNReal",
   "Antitone",
   "Nat.below",
   "Top.top",
   "Quotient.out"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : ‚Ñï ‚Üí Type u_2) ‚Üí\n      [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)] ‚Üí\n        [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] ‚Üí\n          [‚àÄ (i : ‚Ñï), IsUltrametricDist (E i)] ‚Üí\n            {c : ‚Ñï ‚Üí ‚Ü•(lp E ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú E} ‚Üí\n              {r : ‚Ñï ‚Üí NNReal} ‚Üí\n                StrictAnti r ‚Üí\n                  (Antitone fun i ‚Ü¶ Metric.closedBall (c i) ‚Üë(r i)) ‚Üí\n                    (k : ‚Ñï) ‚Üí { z // (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú E).toAddSubgroup) z = c k }",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet.sInf",
  "constType": "{Œ± : Type u_1} ‚Üí [self : InfSet Œ±] ‚Üí Set Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Denumerable.decode_isSome", "Option.get", "Encodable.decode"],
  "name": "Denumerable.ofNat",
  "constType": "(Œ± : Type u_3) ‚Üí [Denumerable Œ±] ‚Üí ‚Ñï ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Norm.norm",
   "Exists.choose_spec",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthProj",
   "Exists.choose",
   "Subtype.val",
   "DFunLike.coe",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "RingHom.id",
   "LE.le",
   "id",
   "And.left"],
  "name": "SphericallyCompleteSpace.OrthProj_id",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  ‚àÄ a ‚àà F, ‚Üë((SphericallyCompleteSpace.OrthProj ùïú F) a) = a",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "ZeroHomClass.map_zero"],
  "name": "map_zero",
  "constType":
  "‚àÄ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]\n  [ZeroHomClass F M N] (f : F), f 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["RingHom.id"],
  "name": "SphericallyCompleteSpace.IsImmediate._proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_3} [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_2} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ùïú F],\n  SemilinearMapClass (E ‚Üí‚Çó·µ¢[ùïú] F) (RingHom.id ùïú) E F",
  "constCategory": "Theorem"},
 {"references": ["rfl", "DFunLike.coe", "ContinuousLinearMap.comp"],
  "name": "ContinuousLinearMap.comp_apply",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Semiring R‚ÇÉ]\n  {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} {M‚ÇÅ : Type u_4} [inst_3 : TopologicalSpace M‚ÇÅ]\n  [inst_4 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [inst_5 : TopologicalSpace M‚ÇÇ] [inst_6 : AddCommMonoid M‚ÇÇ] {M‚ÇÉ : Type u_7}\n  [inst_7 : TopologicalSpace M‚ÇÉ] [inst_8 : AddCommMonoid M‚ÇÉ] [inst_9 : _root_.Module R‚ÇÅ M‚ÇÅ]\n  [inst_10 : _root_.Module R‚ÇÇ M‚ÇÇ] [inst_11 : _root_.Module R‚ÇÉ M‚ÇÉ] [inst_12 : RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ]\n  (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M‚ÇÅ), (g.comp f) x = g (f x)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Metric.ball", "Iff.rfl"],
  "name": "Metric.mem_ball",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, y ‚àà Metric.ball x Œµ ‚Üî dist y x < Œµ",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÄ (a : Œ±), a = a' ‚Üí p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "congr",
   "HSub.hSub",
   "neg_neg",
   "neg_add_rev",
   "congrArg"],
  "name": "neg_sub",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionMonoid Œ±] (a b : Œ±), -(a - b) = b - a",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.ndrec"],
  "name": "Lean.Omega.Int.add_congr",
  "constType": "‚àÄ {a b c d : ‚Ñ§}, a = b ‚Üí c = d ‚Üí a + c = b + d",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono", "eq_false", "LE.le", "Nat.not_ofNat_le_one", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_24",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] [CharZero Œ±]\n  {n : ‚Ñï} [inst_5 : n.AtLeastTwo], (OfNat.ofNat n ‚â§ 1) = False",
  "constCategory": "Theorem"},
 {"references": ["RingHom.id", "LinearMap.range", "Membership.mem"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  [IsUltrametricDist E‚ÇÄ] (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ), IsUltrametricDist ‚Ü•(LinearMap.range f)",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_19",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references": ["Set.iUnion_subtype", "Set", "Membership.mem", "Set.Elem"],
  "name": "Set.iUnion_coe_set",
  "constType":
  "‚àÄ {Œ± : Type u_12} {Œ≤ : Type u_13} (s : Set Œ±) (f : ‚Üës ‚Üí Set Œ≤), ‚ãÉ i, f i = ‚ãÉ i, ‚ãÉ (h : i ‚àà s), f ‚ü®i, h‚ü©",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulAction.one_smul",
  "constType":
  "‚àÄ {Œ± : Type u_9} {Œ≤ : Type u_10} {inst : Monoid Œ±} [self : MulAction Œ± Œ≤] (b : Œ≤), 1 ‚Ä¢ b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Nat.zero_le",
   "Directed",
   "OfNat.ofNat",
   "Antitone.directed_ge",
   "HAdd.hAdd",
   "IsCompact.of_isClosed_subset",
   "HasSubset.Subset",
   "IsCompact",
   "IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed",
   "Antitone",
   "Superset",
   "antitone_nat_of_succ_le"],
  "name": "IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed",
  "constType":
  "‚àÄ {X : Type u} [inst : TopologicalSpace X] (t : ‚Ñï ‚Üí Set X),\n  (‚àÄ (i : ‚Ñï), t (i + 1) ‚äÜ t i) ‚Üí\n    (‚àÄ (i : ‚Ñï), (t i).Nonempty) ‚Üí IsCompact (t 0) ‚Üí (‚àÄ (i : ‚Ñï), IsClosed (t i)) ‚Üí (‚ãÇ i, t i).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "dite",
  "constType":
  "{Œ± : Sort u} ‚Üí (c : Prop) ‚Üí [h : Decidable c] ‚Üí (c ‚Üí Œ±) ‚Üí (¬¨c ‚Üí Œ±) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["absurd", "Not", "rfl", "ite", "_private.Init.Core.0.if_pos.match_1_1"],
  "name": "if_pos",
  "constType":
  "‚àÄ {c : Prop} {h : Decidable c}, c ‚Üí ‚àÄ {Œ± : Sort u} {t e : Œ±}, (if c then t else e) = t",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "TopologicalSpace.SeparableSpace.exists_countable_dense",
  "constType":
  "‚àÄ {Œ± : Type u} {t : TopologicalSpace Œ±} [self : TopologicalSpace.SeparableSpace Œ±], ‚àÉ s, s.Countable ‚àß Dense s",
  "constCategory": "Theorem"},
 {"references": ["exists_apply_eq_apply", "eq_true"],
  "name":
  "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} (f : Œ± ‚Üí Œ≤) (a' : Œ±), (‚àÉ a, f a = f a') = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "‚àÄ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "le_of_lt", "lt_of_lt_of_le"],
  "name": "lt_trans",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b c : Œ±}, a < b ‚Üí b < c ‚Üí a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_ne_zero", "Nat.cast", "Iff.mpr", "Ne", "NeZero.ne", "OfNat.ofNat"],
  "name": "OfNat.ofNat_ne_zero",
  "constType":
  "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] (n : ‚Ñï) [inst_2 : n.AtLeastTwo], OfNat.ofNat n ‚â† 0",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.isboundedlinearmap_of_glued_map._simp_2",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "add_left_comm",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "congrArg"],
  "name": "add_add_add_comm",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddCommSemigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidHomClass.isometry_of_norm",
   "LinearIsometry.toLinearMap",
   "LinearIsometry.norm_map",
   "DFunLike.coe"],
  "name": "LinearIsometry.isometry",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup E‚ÇÇ] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] (f : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ), Isometry ‚áëf",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Metric.closedBall",
   "Trans.trans",
   "add_le_add",
   "Set",
   "Iff.mpr",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "Bornology.IsBounded",
   "dist_triangle_right",
   "Metric.isBounded_iff"],
  "name": "Metric.isBounded_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u} {x : Œ±} {r : ‚Ñù} [inst : PseudoMetricSpace Œ±], Bornology.IsBounded (Metric.closedBall x r)",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "iSup", "EDist.edist", "Set", "Membership.mem"],
  "name": "EMetric.diam",
  "constType": "{Œ± : Type u_1} ‚Üí [PseudoEMetricSpace Œ±] ‚Üí Set Œ± ‚Üí ENNReal",
  "constCategory": "Definition"},
 {"references": ["OrderBot.bot_le"],
  "name": "bot_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LE Œ±] [inst_1 : OrderBot Œ±] {a : Œ±}, ‚ä• ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["iSup", "Set"],
  "name": "Set.iUnion",
  "constType": "{Œ± : Type u} ‚Üí {Œπ : Sort v} ‚Üí (Œπ ‚Üí Set Œ±) ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SProd.sprod",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : SProd Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["trivial"],
  "name": "Set.mem_univ",
  "constType": "‚àÄ {Œ± : Type u} (x : Œ±), x ‚àà Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Cardinal.toNat", "Module.rank", "Cardinal", "DFunLike.coe"],
  "name": "Module.finrank",
  "constType":
  "(R : Type u_1) ‚Üí (M : Type u_2) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [_root_.Module R M] ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_add",
   "HAdd.hAdd",
   "Nat.cast",
   "Nat.add",
   "Eq.symm",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNat_add.match_1_1"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] {f : Œ± ‚Üí Œ± ‚Üí Œ±} {a b : Œ±} {a' b' c : ‚Ñï},\n  f = HAdd.hAdd ‚Üí\n    Mathlib.Meta.NormNum.IsNat a a' ‚Üí\n      Mathlib.Meta.NormNum.IsNat b b' ‚Üí a'.add b' = c ‚Üí Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_3",
  "constType": "‚àÄ {a : Prop}, (¬¨¬¨a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "LT.lt",
   "mul_le_mul_iff_right‚ÇÄ",
   "LE.le",
   "id",
   "HMul.hMul",
   "mul_one",
   "Eq.mpr",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg"],
  "name": "mul_le_iff_le_one_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] {a b : Œ±} [inst_2 : Preorder Œ±] [PosMulMono Œ±]\n  [PosMulReflectLE Œ±], 0 < a ‚Üí (a * b ‚â§ a ‚Üî b ‚â§ 1)",
  "constCategory": "Theorem"},
 {"references":
  ["isometry_neg",
   "Set.neg",
   "Eq.trans",
   "Metric.infDist_eq_iInf",
   "HasQuotient.Quotient",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "Set.image_neg_eq_neg",
   "funext",
   "Dist.dist",
   "QuotientAddGroup.mk'_apply",
   "InfSet.sInf",
   "HSub.hSub",
   "sInf_image'",
   "Eq.symm",
   "neg_coe_set",
   "Metric.infDist",
   "iInf",
   "add_comm",
   "QuotientAddGroup.norm_mk",
   "QuotientAddGroup.mk'",
   "Norm.norm",
   "Set",
   "Neg.neg",
   "sub_neg_eq_add",
   "HAdd.hAdd",
   "eq_self",
   "dist_eq_norm'",
   "Set.image",
   "SetLike.coe",
   "of_eq_true",
   "Metric.infDist_image",
   "id",
   "QuotientAddGroup.mk",
   "Eq.mpr"],
  "name": "quotient_norm_mk_eq",
  "constType":
  "‚àÄ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (m : M),\n  ‚Äñ(QuotientAddGroup.mk' S) m‚Äñ = sInf ((fun x ‚Ü¶ ‚Äñm + x‚Äñ) '' ‚ÜëS)",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.trichotomy",
   "Eq.trans",
   "Singleton.singleton",
   "SummationFilter.unconditional",
   "Real.zero_rpow",
   "mem‚Ñìp_zero",
   "Set.range",
   "Set.range_const_subset",
   "congrArg",
   "LT.lt.ne'",
   "BddAbove.mono",
   "Mem‚Ñìp",
   "funext",
   "mem‚Ñìp_gen",
   "ENNReal.toReal",
   "Eq.symm",
   "not_true_eq_false",
   "_private.Mathlib.Analysis.Normed.Lp.lpSpace.0.zero_mem‚Ñìp._simp_1_1",
   "Eq.ndrec",
   "norm_zero",
   "Not",
   "Norm.norm",
   "Set",
   "HPow.hPow",
   "OfNat.ofNat",
   "BddAbove",
   "Summable",
   "LT.lt",
   "Or.casesOn",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "Set.finite_empty._simp_1",
   "id",
   "Top.top",
   "bddAbove_singleton",
   "Eq.mpr",
   "Set.Finite",
   "mem‚Ñìp_infty",
   "setOf"],
  "name": "zero_mem‚Ñìp",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} {p : ENNReal} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)], Mem‚Ñìp 0 p",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_13",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÉ a, p a ‚àß a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSub.hSub",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HSub Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "PreLp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "Set",
   "lp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Exists.choose",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.SphericalCompletion",
   "ENNReal",
   "Maximal",
   "Top.top",
   "inferInstance",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceSphericalCompletion",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace (SphericallyCompleteSpace.SphericalCompletion ùïú E)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsInt.to_isNat.match_1_1",
   "Int.cast_natCast",
   "Int.cast",
   "congrArg"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a : Œ±} {n : ‚Ñï},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) ‚Üí Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "max_def'",
   "Eq.trans",
   "Eq.mp",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "Max.max",
   "Lean.Grind.nestedDecidable",
   "LinearOrder.toDecidableLE'",
   "eq_false",
   "LE.le",
   "Classical.byContradiction",
   "id",
   "Eq.symm"],
  "name": "max_eq_left",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, b ‚â§ a ‚Üí max a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval_inv",
   "Inv.inv",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.inv_eq_eval",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] {l : Mathlib.Tactic.FieldSimp.NF M} {x : M}, x = l.eval ‚Üí x‚Åª¬π = l‚Åª¬π.eval",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Top.top", "eq_true", "Submodule.mem_top"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_5",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x ‚àà ‚ä§) = True",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl", "Nat.cast", "LE.le", "Nat.ceil_le", "Iff.mp", "Nat.ceil"],
  "name": "Nat.le_ceil",
  "constType":
  "‚àÄ {R : Type u_1} [inst : Semiring R] [inst_1 : LinearOrder R] [inst_2 : FloorSemiring R] (a : R), a ‚â§ ‚Üë‚åàa‚åâ‚Çä",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "NegMemClass.neg_mem",
  "constType":
  "‚àÄ {S : Type u_3} {G : outParam (Type u_4)} {inst : Neg G} {inst_1 : SetLike S G} [self : NegMemClass S G] {s : S}\n  {x : G}, x ‚àà s ‚Üí -x ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["Not", "by_contra"],
  "name": "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
  "constType": "‚àÄ {p q : Prop}, (¬¨q ‚Üí p) ‚Üí ¬¨p ‚Üí q",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff‚ÇÇ", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  (‚àÄ (b : Œ≤) (a : Œ±), p a ‚Üí f a = b ‚Üí q b) = ‚àÄ (a : Œ±), p a ‚Üí q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Isometry.injective", "LinearIsometry.isometry", "DFunLike.coe"],
  "name": "LinearIsometry.injective",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {E‚ÇÇ : Type u_6} {F : Type u_9} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_2 : SeminormedAddCommGroup E‚ÇÇ] [inst_3 : _root_.Module R‚ÇÇ E‚ÇÇ] [inst_4 : NormedAddCommGroup F]\n  [inst_5 : _root_.Module R F] (f‚ÇÅ : F ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ), Function.Injective ‚áëf‚ÇÅ",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Inter.inter", "Set.ext", "and_comm"],
  "name": "Set.inter_comm",
  "constType": "‚àÄ {Œ± : Type u} (a b : Set Œ±), a ‚à© b = b ‚à© a",
  "constCategory": "Theorem"},
 {"references":
  ["mul_inv_cancel‚ÇÄ",
   "Eq.trans",
   "Membership.mem",
   "Classical.propDecidable",
   "HMul.hMul",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop._simp_1_1",
   "Subtype.val",
   "Set.Elem",
   "RingHom.id",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Eq.symm",
   "mul_comm",
   "Eq.ndrec",
   "ContinuousLinearMap.map_smul",
   "Exists.choose_spec",
   "Norm.norm",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "smul_sub",
   "add_zero",
   "map_add",
   "mul_le_mul_iff_of_pos_left",
   "norm_pos_iff",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "zero_smul",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "mul_assoc",
   "DFunLike.coe",
   "congrArg",
   "congr",
   "propext",
   "Not",
   "Set.Nonempty",
   "Inv.inv",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "norm_smul",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "smul_smul",
   "smul_add",
   "Ne",
   "MulAction.one_smul",
   "dite"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (ha1 : a ‚àâ D) {F : Type u_3}\n  [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ùïú F]\n  [hsc : SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) {ùí∞ : Set (E ‚ÜíL[ùïú] F)} (hùí∞ : ùí∞.Nonempty) {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù}\n  (hŒµ1 : ‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) (hŒµ2 : ‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V))\n  (hŒµ3 : ‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ) (x : ‚Ü•D) (l : ùïú) (U : ‚Üëùí∞),\n  ‚ÄñS x + l ‚Ä¢ ‚ãØ.choose - ‚ÜëU (‚Üëx + l ‚Ä¢ a)‚Äñ ‚â§ Œµ U * ‚Äñ‚Üëx + l ‚Ä¢ a‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["AddZeroClass.add_zero"],
  "name": "add_zero",
  "constType": "‚àÄ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "LinearMap.ker",
   "sub_eq_zero",
   "Membership.mem",
   "Iff.rfl",
   "DFunLike.coe",
   "OfNat.ofNat",
   "map_sub",
   "congrArg",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "propext",
   "LinearMap.mem_ker"],
  "name": "LinearMap.sub_mem_ker_iff",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_7} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\n  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_11} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] {f : F} {x y : M},\n  x - y ‚àà LinearMap.ker f ‚Üî f x = f y",
  "constCategory": "Theorem"},
 {"references": ["zero_le", "LE.le", "eq_true", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddZeroClass Œ±] [inst_1 : LE Œ±] [CanonicallyOrderedAdd Œ±] (a : Œ±), (0 ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name": "Set.mem_iInter._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball._proof_2",
   "NNReal.toReal",
   "GT.gt",
   "Subtype.val",
   "Set.Countable",
   "Set.Elem",
   "Prod.fst",
   "Dense",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
   "Denumerable.ofNat",
   "Not",
   "Set",
   "NNReal",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball._proof_1",
   "Nat.brecOn",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "Metric.closedBall",
   "HasSubset.Subset",
   "Nat.below",
   "NNDist.nndist",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball.match_1",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    [hiud : IsUltrametricDist Œ±] ‚Üí\n      [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] ‚Üí\n        [nemp : Nonempty Œ±] ‚Üí [hsep : TopologicalSpace.SeparableSpace Œ±] ‚Üí Denumerable ‚Üë‚ãØ.choose ‚Üí ‚Ñï ‚Üí Œ± √ó NNReal",
  "constCategory": "Definition"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_1",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 ‚â§ ‚Äña‚Äñ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "LinearIsometry.isometry",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "Eq.symm",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Isometry.isometryEquivOnRange",
   "LinearIsometry.comp",
   "Exists.choose",
   "Function.Surjective",
   "Exists.casesOn",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "LinearMap.range_comp_le_range",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective",
   "LE.le",
   "id",
   "Top.top",
   "Eq.mpr",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_unique",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [IsUltrametricDist F] [SphericallyCompleteSpace F] {f : E ‚Üí‚Çó·µ¢[ùïú] F},\n  (‚àÄ (M : Submodule ùïú F), LinearMap.range f ‚â§ M ‚Üí SphericallyCompleteSpace ‚Ü•M ‚Üí M = ‚ä§) ‚Üí\n    Nonempty (SphericallyCompleteSpace.SphericalCompletion ùïú E ‚âÉ‚Çó·µ¢[ùïú] F)",
  "constCategory": "Theorem"},
 {"references":
  ["id",
   "HMul.hMul",
   "Eq.mpr",
   "HPow.hPow",
   "Eq.ndrec",
   "mul_left_comm",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_pf_right",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a b‚ÇÉ c : R} (b‚ÇÅ : R) (b‚ÇÇ : ‚Ñï), a * b‚ÇÉ = c ‚Üí a * (b‚ÇÅ ^ b‚ÇÇ * b‚ÇÉ) = b‚ÇÅ ^ b‚ÇÇ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.mk.injEq",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "eq_true",
   "Submodule.mem_sup_left",
   "Set.iInter",
   "Membership.mem.out",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.not_morth_iff_exists_dist_lt_norm",
   "RingHom.id",
   "Submodule.mem_span_singleton",
   "StrictAnti.antitone",
   "Eq.symm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "Eq.ndrec",
   "norm_zero",
   "norm_eq_of_norm_sub_lt_left",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_4",
   "sub_sub_eq_add_sub",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_21",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Norm.norm",
   "sub_neg_eq_add",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_3",
   "Submodule.smul_mem",
   "NNReal",
   "Mathlib.Tactic.Abel.term_add_constg",
   "true_and",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "Set.nonempty_iff_ne_empty",
   "max_lt",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SetLike.coe",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "IsUltrametricDist.dist_triangle_max",
   "eq_false",
   "Antitone",
   "Classical.byContradiction",
   "NNDist.nndist",
   "Int.negOfNat",
   "zero_smul",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_5",
   "Metric.mem_closedBall_self",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_16",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "max_le",
   "dist_eq_norm",
   "le_sup_left._simp_3",
   "EmptyCollection.emptyCollection",
   "Mathlib.Meta.NormNum.isInt_neg",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "Subspace",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_23",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_24",
   "Submodule.mem_sup",
   "congr",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "neg_smul",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Metric.infDist_zero_of_mem",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_1",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_22",
   "IsUltrametricDist.norm_add_eq_max_of_norm_ne_norm",
   "OfNat.ofNat",
   "le_sup_of_le_left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "not_le_of_gt",
   "eq_self",
   "Metric.closedBall",
   "Max.max",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_9",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_19",
   "smul_add",
   "Submodule.sub_mem",
   "Ne",
   "eq_of_le_of_ge",
   "dite",
   "And.casesOn",
   "Mathlib.Tactic.Push.not_forall_eq",
   "Membership.mem",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_14",
   "Submodule.span",
   "Submodule.subtype",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "not_false_eq_true",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_11",
   "add_comm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "max_comm",
   "LinearMap.toAddMonoidHom",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
   "Neg.neg",
   "lt_of_le_of_lt",
   "And.right",
   "add_zero",
   "Submodule.mk_eq_zero._simp_1",
   "Exists.casesOn",
   "zero_add",
   "mt",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "Iff.of_eq",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_12",
   "max_self",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "SphericallyCompleteSpace.smul_morth_of_morth",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_2",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "LinearMap.range",
   "le_trans",
   "NNReal.toReal",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_20",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "DFunLike.coe",
   "Metric.le_infDist",
   "congrArg",
   "add_sub",
   "SetLike.mem_coe",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_13",
   "Subtype.prop",
   "inv_smul_smul‚ÇÄ",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "le_of_eq",
   "NNReal.zero_le_coe",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "Set.not_nonempty_iff_eq_empty._simp_1",
   "Not",
   "Inv.inv",
   "Classical.not_imp._simp_2",
   "Set.Nonempty",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_6",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_15",
   "Exists.choose",
   "Mathlib.Tactic.Abel.term_neg",
   "exists_prop_congr",
   "sub_sub_sub_cancel_right",
   "LT.lt",
   "StrictAnti",
   "ZeroMemClass.zero_mem._simp_1",
   "SetLike.mem_coe._simp_1",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_10",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÅ"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (E‚ÇÄ : Type u_3) [inst_4 : NormedAddCommGroup E‚ÇÄ]\n  [inst_5 : NormedSpace ùïú E‚ÇÄ] [iud : IsUltrametricDist E‚ÇÄ] [hsc : SphericallyCompleteSpace E‚ÇÄ] (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ),\n  SphericallyCompleteSpace ‚Ü•‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references": ["implies_dep_congr_ctx"],
  "name": "implies_congr_ctx",
  "constType":
  "‚àÄ {p‚ÇÅ p‚ÇÇ q‚ÇÅ q‚ÇÇ : Prop}, p‚ÇÅ = p‚ÇÇ ‚Üí (p‚ÇÇ ‚Üí q‚ÇÅ = q‚ÇÇ) ‚Üí (p‚ÇÅ ‚Üí q‚ÇÅ) = (p‚ÇÇ ‚Üí q‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "HSMul.hSMul",
   "add_zero",
   "one_zsmul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.term_atomg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (x : Œ±), x = Mathlib.Tactic.Abel.termg 1 x 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_1",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_5",
   "eq_true",
   "GT.gt",
   "Subtype.val",
   "funext",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_4",
   "And.left",
   "And.right",
   "lt_of_le_of_lt",
   "Exists.casesOn",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_3",
   "Set.image",
   "SetLike.coe",
   "Iff.of_eq",
   "IsUltrametricDist.dist_triangle_max",
   "Iff.mpr",
   "id",
   "Set.ext",
   "Eq.mpr",
   "Submodule.nonempty",
   "FiniteDimensional",
   "le_sup_iff",
   "Eq.mp",
   "le_trans",
   "and_true",
   "Subspace",
   "congrArg",
   "congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_2",
   "Dist.dist",
   "Metric.infDist",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
   "propext",
   "Set",
   "dist_comm",
   "exists_prop_congr",
   "LT.lt",
   "Or.casesOn",
   "Metric.closedBall",
   "Max.max",
   "Metric.infDist_lt_iff",
   "le_of_lt",
   "LE.le",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball._simp_1_3"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.res_ball",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [iud : IsUltrametricDist E] (F : Subspace ùïú E) [SphericallyCompleteSpace ‚Ü•F]\n  [FiniteDimensional ùïú E] (a : E),\n  ‚àÄ s > Metric.infDist a ‚ÜëF, ‚àÉ z, Metric.closedBall a s ‚à© ‚ÜëF = (fun x ‚Ü¶ ‚Üëx) '' Metric.closedBall z s",
  "constCategory": "Theorem"},
 {"references": ["Prod.forall", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± √ó Œ≤ ‚Üí Prop}, (‚àÄ (x : Œ± √ó Œ≤), p x) = ‚àÄ (a : Œ±) (b : Œ≤), p (a, b)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Classical.propDecidable",
   "HMul.hMul",
   "sub_zero",
   "Subtype.val",
   "Set.Elem",
   "not_false_eq_true",
   "RingHom.id",
   "norm_pos_iff'._simp_4",
   "funext",
   "forall_congr",
   "Eq.symm",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_4",
   "HSub.hSub",
   "norm_zero",
   "forall_prop_domain_congr",
   "And.left",
   "Norm.norm",
   "And.right",
   "ContinuousLinearMap.norm_def",
   "true_and",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_1",
   "Exists.casesOn",
   "implies_true",
   "Iff.mpr",
   "eq_false",
   "max_self",
   "lowerBounds",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_3",
   "setOf",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_2",
   "forall_eq._simp_1",
   "Eq.mp",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.exists_extension_opNorm_le",
   "Subtype.prop",
   "csInf_le_csInf",
   "congr",
   "InfSet.sInf",
   "SphericallyCompleteSpace.hahn_banach'._simp_1_5",
   "Not",
   "Set.Nonempty",
   "ContinuousLinearMap.le_opNorm",
   "Set",
   "OfNat.ofNat",
   "LT.lt",
   "eq_self",
   "and_self",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "Subtype.forall._simp_1",
   "norm_nonneg'._simp_4",
   "ContinuousLinearMap.opNorm_le_iff",
   "Set.singleton_nonempty._simp_1",
   "Ne",
   "eq_of_le_of_ge",
   "Set.mem_singleton_iff._simp_1",
   "dite",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.hahn_banach'",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [IsUltrametricDist E] (D : Submodule ùïú E) {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [IsUltrametricDist F] [hf : SphericallyCompleteSpace F] (f : ‚Ü•D ‚ÜíL[ùïú] F),\n  ‚àÉ f', (‚àÄ (v : E) (hv : v ‚àà D), f' v = f ‚ü®v, hv‚ü©) ‚àß ‚Äñf'‚Äñ = ‚Äñf‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["sub_self",
   "eq_of_sub_eq_zero",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "sub_eq_zero",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 ‚Üî a = b",
  "constCategory": "Theorem"},
 {"references": ["MulDivCancelClass.mul_div_cancel", "Ne", "OfNat.ofNat"],
  "name": "mul_div_cancel_right‚ÇÄ",
  "constType":
  "‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : Div M‚ÇÄ] [MulDivCancelClass M‚ÇÄ] (a : M‚ÇÄ) {b : M‚ÇÄ},\n  b ‚â† 0 ‚Üí a * b / b = a",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Eq.trans",
   "sub_add_cancel",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Submodule.span",
   "Subtype.val",
   "Set.Elem",
   "RingHom.id",
   "eq_of_heq",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "And.left",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Norm.norm",
   "Exists.choose_spec",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "outParam",
   "And.right",
   "max_mul_of_nonneg",
   "Set.Nonempty.some_mem",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop",
   "Set.Nonempty.some",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "lt_max_of_lt_left",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "max_le_max",
   "le_trans",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear",
   "DFunLike.coe",
   "congrArg",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Not",
   "ContinuousLinearMap.le_opNorm",
   "Set.Nonempty",
   "Set",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Exists.choose",
   "Eq.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "norm_nonneg"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_boundedlinear",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (ha1 : a ‚àâ D) {F : Type u_3}\n  [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ùïú F]\n  [hsc : SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) {ùí∞ : Set (E ‚ÜíL[ùïú] F)} (hùí∞ : ùí∞.Nonempty) {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù}\n  (hŒµ1 : ‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) (hŒµ2 : ‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V))\n  (hŒµ3 : ‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ),\n  IsBoundedLinearMap ùïú (SphericallyCompleteSpace.rooij_lemma_4_4_T ha1 S hùí∞ hŒµ1 hŒµ2 hŒµ3)",
  "constCategory": "Definition"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "LinearMap.comp",
   "ContinuousLinearMap.comp._proof_1"],
  "name": "ContinuousLinearMap.comp",
  "constType":
  "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {R‚ÇÉ : Type u_3} ‚Üí\n      [inst : Semiring R‚ÇÅ] ‚Üí\n        [inst_1 : Semiring R‚ÇÇ] ‚Üí\n          [inst_2 : Semiring R‚ÇÉ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} ‚Üí\n                {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} ‚Üí\n                  {M‚ÇÅ : Type u_4} ‚Üí\n                    [inst_3 : TopologicalSpace M‚ÇÅ] ‚Üí\n                      [inst_4 : AddCommMonoid M‚ÇÅ] ‚Üí\n                        {M‚ÇÇ : Type u_6} ‚Üí\n                          [inst_5 : TopologicalSpace M‚ÇÇ] ‚Üí\n                            [inst_6 : AddCommMonoid M‚ÇÇ] ‚Üí\n                              {M‚ÇÉ : Type u_7} ‚Üí\n                                [inst_7 : TopologicalSpace M‚ÇÉ] ‚Üí\n                                  [inst_8 : AddCommMonoid M‚ÇÉ] ‚Üí\n                                    [inst_9 : _root_.Module R‚ÇÅ M‚ÇÅ] ‚Üí\n                                      [inst_10 : _root_.Module R‚ÇÇ M‚ÇÇ] ‚Üí\n                                        [inst_11 : _root_.Module R‚ÇÉ M‚ÇÉ] ‚Üí\n                                          [RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] ‚Üí\n                                            (M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) ‚Üí (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ",
  "constCategory": "Definition"},
 {"references": ["ZeroMemClass.zero_mem"],
  "name": "Submodule.zero_mem",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M), 0 ‚àà p",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_12",
  "constType": "‚àÄ n ‚â• 1, ‚àÄ (k : ‚Ñï), k + 1 ‚â• n + 1 ‚Üí ¬¨k - 1 + 1 = k ‚Üí False",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_13",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ‚àà p), (‚ü®x, h‚ü© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["exists_true_left", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_7",
  "constType": "‚àÄ {p : True ‚Üí Prop}, Exists p = p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "ite",
   "SummationFilter.unconditional",
   "HPow.hPow",
   "OfNat.ofNat",
   "BddAbove",
   "Set.range",
   "Summable",
   "ENNReal",
   "Top.top",
   "ENNReal.toReal",
   "Ne",
   "Set.Finite",
   "setOf"],
  "name": "Mem‚Ñìp",
  "constType":
  "{Œ± : Type u_3} ‚Üí {E : Œ± ‚Üí Type u_4} ‚Üí [(i : Œ±) ‚Üí NormedAddCommGroup (E i)] ‚Üí ((i : Œ±) ‚Üí E i) ‚Üí ENNReal ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Set.image", "Set", "HSMul.hSMul"],
  "name": "Set.smulSet",
  "constType": "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí [SMul Œ± Œ≤] ‚Üí SMul Œ± (Set Œ≤)",
  "constCategory": "Definition"},
 {"references": ["Eq.symm", "HSub.hSub", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "‚àÄ {R : Type u_2} [inst : CommRing R] {a a' b b' c : R}, a = a' ‚Üí b = b' ‚Üí a' - b' = c ‚Üí a - b = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkStr2",
  "constType": "String ‚Üí String ‚Üí Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PreLp",
  "constType":
  "{Œ± : Type u_3} ‚Üí (E : Œ± ‚Üí Type u_5) ‚Üí [(i : Œ±) ‚Üí NormedAddCommGroup (E i)] ‚Üí Type (max u_3 u_5)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "inv_pos._simp_1",
   "Inv.inv",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "LE.le",
   "_private.Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic.0.inv_nonneg._simp_1_1",
   "OfNat.ofNat",
   "_private.Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic.0.inv_nonneg._simp_1_2",
   "congrArg"],
  "name": "inv_nonneg",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a : G‚ÇÄ}, 0 ‚â§ a‚Åª¬π ‚Üî 0 ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["LE.le.eq_or_lt", "LT.lt", "Not", "LE.le", "Or.resolve_right"],
  "name": "eq_of_le_of_not_lt",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí ¬¨a < b ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.IsImmediate", "RingHom.id"],
  "name": "SphericallyCompleteSpace.IsImmediate.eq_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : SeminormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [inst_6 : IsUltrametricDist F] (f : E ‚Üí‚Çó·µ¢[ùïú] F),\n  SphericallyCompleteSpace.IsImmediate f = ‚àÄ (v : F), SphericallyCompleteSpace.MOrth ùïú v (LinearMap.range f) ‚Üí v = 0",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_6",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references": ["RingHom.id", "Membership.mem"],
  "name": "SphericallyCompleteSpace.OrthComp._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E), SemilinearMapClass (E ‚ÜíL[ùïú] ‚Ü•F) (RingHom.id ùïú) E ‚Ü•F",
  "constCategory": "Theorem"},
 {"references": ["Quotient"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Inter.inter",
   "Membership.mem",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "HDiv.hDiv",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_9",
   "Eq.symm",
   "Eq.ndrec",
   "NNReal.exists_add_one_div_pow_two_lt",
   "Nat.casesAuxOn",
   "And.left",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
   "Exists.choose_spec",
   "And.right",
   "lt_of_le_of_lt",
   "NNReal",
   "Prod.snd",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_2",
   "Unit",
   "Exists.casesOn",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.match_1",
   "HasSubset.Subset",
   "inf_le_left",
   "id",
   "Eq.mpr",
   "setOf",
   "NNReal.toReal",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_3",
   "Prod.fst",
   "congrArg",
   "InfSet.sInf",
   "Set.Nonempty",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_4",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.eq_def",
   "Set",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.smaller_radius",
   "HPow.hPow",
   "Exists.choose",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_10",
   "OfNat.ofNat",
   "Nonempty.some",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_8",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "le_of_lt",
   "Min.min",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_1",
   "LE.le",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric"],
  "name":
  "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.cofinal_of_countable_chain_of_ball",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [IsUltrametricDist Œ±] [SphericallyCompleteSpace Œ±] {S : Set (Œ± √ó NNReal)}\n  [hS : Nonempty ‚ÜëS],\n  (‚àÄ (w1 w2 : ‚ÜëS), (Metric.closedBall (‚Üëw1).1 ‚Üë(‚Üëw1).2 ‚à© Metric.closedBall (‚Üëw2).1 ‚Üë(‚Üëw2).2).Nonempty) ‚Üí\n    ‚àÄ (hw : ‚àÄ w ‚àà S, sInf {x | ‚àÉ w ‚àà S, w.2 = x} < w.2),\n      ‚àÄ s ‚àà S,\n        ‚àÉ n,\n          Metric.closedBall (‚Üë(SphericallyCompleteSpace.countable_chain_of_ball‚úù hw n)).1\n              ‚Üë(‚Üë(SphericallyCompleteSpace.countable_chain_of_ball‚úù¬π hw n)).2 ‚äÜ\n            Metric.closedBall s.1 ‚Üës.2",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mpr",
   "_private.Init.PropLemmas.0.exists_prop_congr.match_1_3",
   "Iff.mp",
   "_private.Init.PropLemmas.0.exists_prop_congr.match_1_1"],
  "name": "exists_prop_congr",
  "constType":
  "‚àÄ {p p' : Prop} {q q' : p ‚Üí Prop}, (‚àÄ (h : p), q h ‚Üî q' h) ‚Üí ‚àÄ (hp : p ‚Üî p'), Exists q ‚Üî ‚àÉ (h : p'), q' ‚ãØ",
  "constCategory": "Theorem"},
 {"references": ["NormSMulClass.norm_smul"],
  "name": "norm_smul",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Norm Œ±] [inst_1 : Norm Œ≤] [inst_2 : SMul Œ± Œ≤] [NormSMulClass Œ± Œ≤] (r : Œ±)\n  (x : Œ≤), ‚Äñr ‚Ä¢ x‚Äñ = ‚Äñr‚Äñ * ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Iff.trans",
   "Max.max",
   "not_congr",
   "LE.le",
   "LE.le.lt_iff_ne",
   "left_eq_sup",
   "Ne",
   "le_sup_left"],
  "name": "left_lt_sup",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, a < a ‚äî b ‚Üî ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["Nat.ge_of_not_lt"],
  "name": "Nat.le_of_not_lt",
  "constType": "‚àÄ {a b : ‚Ñï}, ¬¨a < b ‚Üí b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["ProperSpace.of_locallyCompactSpace", "inferInstance"],
  "name":
  "SphericallyCompleteSpace.SphericallyComplete.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E] [NormedSpace ùïú E]\n  [LocallyCompactSpace E], SphericallyCompleteSpace E",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Min.min",
  "constType": "{Œ± : Type u} ‚Üí [self : Min Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["id",
   "HMul.hMul",
   "mul_assoc",
   "Eq.mpr",
   "HPow.hPow",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_pf_left",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a‚ÇÉ b c : R} (a‚ÇÅ : R) (a‚ÇÇ : ‚Ñï), a‚ÇÉ * b = c ‚Üí a‚ÇÅ ^ a‚ÇÇ * a‚ÇÉ * b = a‚ÇÅ ^ a‚ÇÇ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Dvd.dvd",
   "dvd_rfl",
   "outParam",
   "Iff.mpr",
   "CharP.cast_eq_zero_iff",
   "OfNat.ofNat"],
  "name": "CharP.cast_eq_zero",
  "constType":
  "‚àÄ (R : Type u_1) [inst : AddMonoidWithOne R] (p : ‚Ñï) [CharP R p], ‚Üëp = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "add_left_comm",
   "Eq.trans",
   "of_eq_true",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a b‚ÇÇ c : R} (b‚ÇÅ : R), a + b‚ÇÇ = c ‚Üí a + (b‚ÇÅ + b‚ÇÇ) = b‚ÇÅ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_bound",
   "HMul.hMul",
   "ContinuousLinearMap.le_of_opNorm_le",
   "DFunLike.coe",
   "OfNat.ofNat"],
  "name": "ContinuousLinearMap.opNorm_le_iff",
  "constType":
  "‚àÄ {ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ùïú] [inst_3 : NontriviallyNormedField ùïú‚ÇÇ]\n  [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [RingHomIsometric œÉ‚ÇÅ‚ÇÇ] {f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F}\n  {M : ‚Ñù}, 0 ‚â§ M ‚Üí (‚Äñf‚Äñ ‚â§ M ‚Üî ‚àÄ (x : E), ‚Äñf x‚Äñ ‚â§ M * ‚Äñx‚Äñ)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_add",
   "Nat.cast_one",
   "HAdd.hAdd",
   "Nat.cast",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Decidable.decide",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "congrArg"],
  "name": "one_add_one_eq_two",
  "constType": "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references": ["Set.univ", "Equiv.Set.univ", "Equiv.finite_iff", "Set.Elem"],
  "name": "Set.finite_univ_iff",
  "constType": "‚àÄ {Œ± : Type u}, Set.univ.Finite ‚Üî Finite Œ±",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Set", "Membership.mem", "Eq.ndrec"],
  "name": "AddSubsemigroup.mk.congr_simp",
  "constType":
  "‚àÄ {M : Type u_3} [inst : Add M] (carrier carrier_1 : Set M) (e_carrier : carrier = carrier_1)\n  (add_mem' : ‚àÄ {a b : M}, a ‚àà carrier ‚Üí b ‚àà carrier ‚Üí a + b ‚àà carrier),\n  { carrier := carrier, add_mem' := add_mem' } = { carrier := carrier_1, add_mem' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "HasQuotient.Quotient",
   "Membership.mem",
   "NNReal.toReal",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh",
   "Subtype.val",
   "DFunLike.coe",
   "congrArg",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_3",
   "Subtype.prop",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_4",
   "Dist.dist",
   "HSub.hSub",
   "QuotientAddGroup.mk'",
   "dist_self",
   "Exists.choose_spec",
   "Norm.norm",
   "Set",
   "NNReal",
   "And.right",
   "Submodule.toAddSubgroup",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "Metric.closedBall",
   "StrictAnti",
   "lt_add_one",
   "Nat.le_succ",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhh",
   "of_eq_true",
   "Antitone",
   "LE.le",
   "id",
   "QuotientAddGroup.mk"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh_prop",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Submodule ùïú E} ‚¶Éc : ‚Ñï ‚Üí E ‚ß∏ F‚¶Ñ ‚¶Ér : ‚Ñï ‚Üí NNReal‚¶Ñ\n  (hr : StrictAnti r) (hanti : Antitone fun i ‚Ü¶ Metric.closedBall (c i) ‚Üë(r i)) (i' : ‚Ñï),\n  ‚Äñ‚Üë(SphericallyCompleteSpace.hhhh‚úù ùïú hr hanti (i' + 2)) - ‚Üë(SphericallyCompleteSpace.hhhh‚úù¬π ùïú hr hanti (i' + 1))‚Äñ <\n    ‚Üë(r i')",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "Submodule.mem_bot", "DFunLike.coe"],
  "name": "LinearMap.mem_ker",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_11} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] {f : F} {y : M},\n  y ‚àà LinearMap.ker f ‚Üî f y = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv", "div_one", "id", "Eq.mpr", "OfNat.ofNat", "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
  "constType":
  "‚àÄ {M : Type u_1} [inst : DivInvOneMonoid M] {l l_n n : M}, l = l_n / 1 ‚Üí l_n = n ‚Üí l = n",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "Function.invFun", "Function.invFun_eq", "Function.Injective"],
  "name": "Function.leftInverse_invFun",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} [inst : Nonempty Œ±] {f : Œ± ‚Üí Œ≤},\n  Function.Injective f ‚Üí Function.LeftInverse (Function.invFun f) f",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id", "SphericallyCompleteSpace.OrthProj", "Membership.mem"],
  "name": "SphericallyCompleteSpace.OrthProj.congr_simp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  SphericallyCompleteSpace.OrthProj ùïú F = SphericallyCompleteSpace.OrthProj ùïú F",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.rec",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    {motive : SphericallyCompleteSpace.IsSphericallyDense Œ± ‚Üí Sort u} ‚Üí\n      ((spherically_dense : ‚àÄ (c : Œ±) (r : NNReal), Metric.diam (Metric.closedBall c ‚Üër) = ‚Üër) ‚Üí motive ‚ãØ) ‚Üí\n        (t : SphericallyCompleteSpace.IsSphericallyDense Œ±) ‚Üí motive t",
  "constCategory": "Other"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Mathlib.Tactic.Linarith.lt_of_lt_of_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "Submodule.span",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Module.finrank_prod",
   "Module.finrank",
   "RingHom.id",
   "sub_eq_zero_of_eq",
   "Eq.symm",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.sub_pf",
   "add_comm",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.MOrth",
   "Neg.neg",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth",
   "Exists.casesOn",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.mpr",
   "id",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "FiniteDimensional.nonempty_continuousLinearEquiv_iff_finrank_eq",
   "Nat.cast",
   "Mathlib.Tactic.Zify.natCast_eq._simp_1",
   "Eq.mp",
   "FiniteDimensional",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "finrank_span_singleton",
   "Subspace",
   "congrArg",
   "LinearIsometryEquiv.toContinuousLinearEquiv",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "lt_of_not_ge",
   "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "_private.SphericalCompleteness.NormedVectorSpace.Basic.0.SphericallyCompleteSpace.induction_sphericallyCompleteSpace_of_finiteDimensional._simp_1_1",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "LinearIsometryEquiv.toIsometryEquiv",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Ne",
   "neg_neg_of_pos",
   "And.casesOn"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Basic.0.SphericallyCompleteSpace.induction_sphericallyCompleteSpace_of_finiteDimensional",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] [SphericallyCompleteSpace ùïú] (E : Type u_2)\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] [IsUltrametricDist E] [FiniteDimensional ùïú E],\n  ‚àÄ n < Module.finrank ùïú E,\n    (‚àÉ M, Module.finrank ùïú ‚Ü•M = n ‚àß SphericallyCompleteSpace ‚Ü•M) ‚Üí\n      ‚àÉ M', Module.finrank ùïú ‚Ü•M' = n + 1 ‚àß SphericallyCompleteSpace ‚Ü•M'",
  "constCategory": "Theorem"},
 {"references": ["mt"],
  "name": "Mathlib.Tactic.Contrapose.contrapose‚ÇÑ",
  "constType": "‚àÄ {p q : Prop}, (q ‚Üí p) ‚Üí ¬¨p ‚Üí ¬¨q",
  "constCategory": "Theorem"},
 {"references": ["Set", "ENNReal.toReal", "EMetric.diam"],
  "name": "Metric.diam",
  "constType": "{Œ± : Type u} ‚Üí [PseudoMetricSpace Œ±] ‚Üí Set Œ± ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons",
  "constType":
  "{M : Type u_1} ‚Üí ‚Ñ§ √ó M ‚Üí Mathlib.Tactic.FieldSimp.NF M ‚Üí Mathlib.Tactic.FieldSimp.NF M",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.T",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : IsUltrametricDist E] ‚Üí\n          [inst_3 : NormedSpace ùïú E] ‚Üí\n            {D : Submodule ùïú E} ‚Üí\n              {F : Type u_3} ‚Üí\n                [inst_4 : SeminormedAddCommGroup F] ‚Üí\n                  [inst_5 : IsUltrametricDist F] ‚Üí\n                    [inst_6 : NormedSpace ùïú F] ‚Üí\n                      [inst_7 : SphericallyCompleteSpace F] ‚Üí\n                        {S : ‚Ü•D ‚ÜíL[ùïú] F} ‚Üí\n                          {ùí∞ : Set (E ‚ÜíL[ùïú] F)} ‚Üí\n                            {hùí∞ : ùí∞.Nonempty} ‚Üí\n                              {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù} ‚Üí\n                                (self : SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ) ‚Üí\n                                  ‚Ü•(SphericallyCompleteSpace.PartialExtension.M‚úù self) ‚ÜíL[ùïú] F",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "HSMul.hSMul",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (M : Submodule ùïú E‚ÇÄ) (hc : LinearMap.range f ‚â§ M) (x : ùïú) (x_1 : ‚Ü•(LinearMap.range f)),\n  ‚ü®‚Üë(x ‚Ä¢ x_1), ‚ãØ‚ü© = ‚ü®‚Üë(x ‚Ä¢ x_1), ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._simp_2",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x y : Œ±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id._proof_3",
   "RingHom.id._proof_4",
   "id",
   "RingHom.id._proof_2",
   "RingHom.id._proof_1"],
  "name": "RingHom.id",
  "constType": "(Œ± : Type u_5) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí Œ± ‚Üí+* Œ±",
  "constCategory": "Definition"},
 {"references": ["rfl"],
  "name": "Eq.symm",
  "constType": "‚àÄ {Œ± : Sort u} {a b : Œ±}, a = b ‚Üí b = a",
  "constCategory": "Theorem"},
 {"references": ["CommMagma.mul_comm"],
  "name": "mul_comm",
  "constType": "‚àÄ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.normalize_sat",
   "Lean.Omega.normalizeCoeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.tidyCoeffs",
   "Prod.fst",
   "congrArg",
   "Lean.Omega.positivize?_eq_some",
   "Lean.Omega.positivizeConstraint",
   "Lean.Omega.positivizeCoeffs",
   "Eq.symm",
   "Eq.ndrec",
   "Lean.Omega.normalize",
   "Lean.Omega.normalizeConstraint",
   "Lean.Omega.positivize?",
   "Lean.Omega.normalize?",
   "Lean.Omega.positivize_sat",
   "Lean.Omega.tidy?.match_1",
   "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
   "Option.getD",
   "Lean.Omega.tidyConstraint",
   "Prod.snd",
   "Unit",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.normalize?_eq_some",
   "id",
   "Lean.Omega.Constraint.sat'",
   "And.casesOn"],
  "name": "Lean.Omega.tidy_sat",
  "constType":
  "‚àÄ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true ‚Üí (Omega.tidyConstraint s x).sat' (Omega.tidyCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddHom.toFun",
  "constType":
  "{M : Type u_10} ‚Üí {N : Type u_11} ‚Üí [inst : Add M] ‚Üí [inst_1 : Add N] ‚Üí (M ‚Üí‚Çô+ N) ‚Üí M ‚Üí N",
  "constCategory": "Definition"},
 {"references": ["Membership.mem"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E‚ÇÄ : Type u_1) [inst_1 : NormedAddCommGroup E‚ÇÄ]\n  [inst_2 : NormedSpace ùïú E‚ÇÄ] [IsUltrametricDist E‚ÇÄ] (M : Submodule ùïú E‚ÇÄ), IsUltrametricDist ‚Ü•M",
  "constCategory": "Theorem"},
 {"references": ["rfl", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
  "constType":
  "‚àÄ (M : Type u_1) [inst : GroupWithZero M], 1 = Mathlib.Tactic.FieldSimp.NF.eval []",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "Submodule.comap", "Bot.bot"],
  "name": "LinearMap.ker",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {M : Type u_5} ‚Üí\n      {M‚ÇÇ : Type u_7} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                [inst_4 : _root_.Module R M] ‚Üí\n                  [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ] ‚Üí\n                    {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n                      {F : Type u_11} ‚Üí [inst_6 : FunLike F M M‚ÇÇ] ‚Üí [SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] ‚Üí F ‚Üí Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_finiteDimensional._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, (dist x y ‚â§ ‚Üëc) = (nndist x y ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "invertibleOne",
   "Nat.cast",
   "Invertible.invOf",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "invOf_one'",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNNRat.to_isNat.match_1_1",
   "OfNat.ofNat",
   "congrArg",
   "Invertible.congr",
   "eq_self",
   "of_eq_true"],
  "name": "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {a : Œ±} {n : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNNRat a n 1 ‚Üí Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["congrArg"],
  "name": "congr_arg",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Membership.mem.out",
   "Subtype.val",
   "DFunLike.coe",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.IsImmediate",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "LE.le",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_3",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  ‚ü®(SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) (x + x_1), ‚ãØ‚ü© =\n    ‚ü®(SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) (x + x_1), ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Submodule.toAddSubmonoid",
   "AddSubmonoid.coe_iSup_of_directed",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "Set.iUnion",
   "Directed",
   "le_iSup",
   "iSup_le",
   "AddSubsemigroup.carrier",
   "Set.mem_iUnion",
   "iSup",
   "SetLike.coe",
   "Submodule.smul_mem'",
   "Iff.mpr",
   "HSMul.hSMul",
   "LE.le",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0.Submodule.coe_iSup_of_directed.match_1_1",
   "Eq.symm",
   "Set.iUnion_subset",
   "AddSubmonoid.toAddSubsemigroup",
   "le_antisymm",
   "AddSubmonoid.copy"],
  "name": "Submodule.coe_iSup_of_directed",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {Œπ : Sort u_9} [Nonempty Œπ] (S : Œπ ‚Üí Submodule R M), Directed (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) S ‚Üí ‚Üë(iSup S) = ‚ãÉ i, ‚Üë(S i)",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_11",
  "constType": "‚àÄ n ‚â• 1, ‚àÄ (k : ‚Ñï), k + 1 ‚â• n + 1 ‚Üí ¬¨k - 1 + 2 = k + 1 ‚Üí False",
  "constCategory": "Theorem"},
 {"references": ["And.right", "trivial", "propext"],
  "name": "true_and",
  "constType": "‚àÄ (p : Prop), (True ‚àß p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "norm_eq_zero",
   "Eq.mp",
   "Metric.infDist_zero_of_mem",
   "Membership.mem",
   "Iff.mp",
   "Subspace",
   "OfNat.ofNat",
   "congrArg",
   "SetLike.coe",
   "id",
   "Eq.symm",
   "Metric.infDist",
   "SphericallyCompleteSpace.MOrth"],
  "name": "SphericallyCompleteSpace.eq_zero_of_morth_of_mem",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ùïú E},\n  x ‚àà F ‚Üí SphericallyCompleteSpace.MOrth ùïú x F ‚Üí x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "sub_neg_eq_add",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "zero_add",
   "dist_triangle",
   "congr",
   "LE.le",
   "Dist.dist",
   "HSub.hSub",
   "dist_eq_norm_sub"],
  "name": "norm_add_le",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), ‚Äña + b‚Äñ ‚â§ ‚Äña‚Äñ + ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "IsBoundedLinearMap.toContinuousLinearMap.match_1",
   "HMul.hMul",
   "LinearMap.toAddHom",
   "IsBoundedLinearMap.bound",
   "AddMonoidHomClass.continuous_of_bound",
   "DFunLike.coe",
   "OfNat.ofNat",
   "IsBoundedLinearMap.toLinearMap",
   "LT.lt",
   "RingHom.id",
   "LE.le",
   "AddHom.toFun"],
  "name": "IsBoundedLinearMap.toContinuousLinearMap._proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_3} [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_2} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}\n  (hf : IsBoundedLinearMap ùïú f), Continuous (IsBoundedLinearMap.toLinearMap f hf).toFun",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "AddHomClass.map_add"],
  "name": "map_add",
  "constType":
  "‚àÄ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Add M] [inst_1 : Add N] [inst_2 : FunLike F M N]\n  [AddHomClass F M N] (f : F) (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "trivial"],
  "name": "implies_true",
  "constType": "‚àÄ (Œ± : Sort u), (‚àÄ (a : Œ±), True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Exists.choose_spec",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthProj",
   "And.right",
   "Exists.choose",
   "Subtype.val",
   "DFunLike.coe",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "RingHom.id",
   "LE.le",
   "id"],
  "name": "SphericallyCompleteSpace.norm_OrthProj_le_one",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  ‚ÄñSphericallyCompleteSpace.OrthProj ùïú F‚Äñ ‚â§ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_5",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LE.le", "setOf"],
  "name": "Set.Ioc",
  "constType": "{Œ± : Type u_1} ‚Üí [Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_3",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_4",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "RingHom.id",
   "LinearMap.range",
   "Membership.mem",
   "Function.invFun",
   "Set.rangeFactorization",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_1",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_5",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_2",
   "DFunLike.coe"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup F] ‚Üí\n              [inst_4 : NormedSpace ùïú F] ‚Üí (f : E ‚Üí‚Çó·µ¢[ùïú] F) ‚Üí ‚Ü•(LinearMap.range f) ‚Üí‚Çó·µ¢[ùïú] E",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top.top",
  "constType": "{Œ± : Type u_1} ‚Üí [self : Top Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_5",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.mpr",
  "constType": "{Œ± Œ≤ : Sort u} ‚Üí Œ± = Œ≤ ‚Üí Œ≤ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_5",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, (dist x y ‚â§ ‚Üëc) = (nndist x y ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "Membership.mem",
   "LE.le",
   "id",
   "Eq.mpr",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Metric.mem_closedBall_self",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, 0 ‚â§ Œµ ‚Üí x ‚àà Metric.closedBall x Œµ",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Elem"],
  "name": "Set.Finite",
  "constType": "{Œ± : Type u} ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["iff_self",
   "Eq.trans",
   "of_eq_true",
   "SetLike.coe_eq_coe",
   "Membership.mem",
   "Eq.symm",
   "Subtype.val",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "AddSubmonoid.mk_eq_zero",
  "constType":
  "‚àÄ {M : Type u_4} [inst : AddZeroClass M] (S : AddSubmonoid M) {a : M} {ha : a ‚àà S}, ‚ü®a, ha‚ü© = 0 ‚Üî a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Bind.bind",
   "Lean.MonadRef.withRef",
   "Lean.MonadRef.getRef",
   "Lean.replaceRef"],
  "name": "Lean.withRef",
  "constType":
  "{m : Type ‚Üí Type} ‚Üí [Monad m] ‚Üí [MonadRef m] ‚Üí {Œ± : Type} ‚Üí Syntax ‚Üí m Œ± ‚Üí m Œ±",
  "constCategory": "Definition"},
 {"references": ["LT.lt"],
  "name": "StrictMono",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [Preorder Œ±] ‚Üí [Preorder Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["HDiv.hDiv",
   "HAdd.hAdd",
   "Eq.symm",
   "id",
   "add_div",
   "add_self_div_two",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "add_halves",
  "constType":
  "‚àÄ {K : Type u_1} [inst : DivisionSemiring K] [NeZero 2] (a : K), a / 2 + a / 2 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Submodule.mem_bot", "Bot.bot", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_3",
  "constType":
  "‚àÄ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x ‚àà ‚ä•) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "forall_eq._simp_1",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÄ (a : Œ±), a = a' ‚Üí p a) = p a'",
  "constCategory": "Theorem"},
 {"references": ["LinearIsometry.coe_injective", "funext", "DFunLike.coe"],
  "name": "LinearIsometry.ext",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {E : Type u_5} {E‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup E‚ÇÇ] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] {f g : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ}, (‚àÄ (x : E), f x = g x) ‚Üí f = g",
  "constCategory": "Theorem"},
 {"references":
  ["PadicAlgCl",
   "NNReal",
   "PadicComplex",
   "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric",
   "Padic",
   "Nat.Prime"],
  "name":
  "SphericallyCompleteSpace.instPadicComplex_not_sphercallyCompleteSpace",
  "constType":
  "‚àÄ (p : ‚Ñï) [hp : Fact (Nat.Prime p)], ¬¨SphericallyCompleteSpace ‚ÑÇ_[p]",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "Neg.neg",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "mul_assoc",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.zpow'_neg",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "mul_inv",
   "congrArg",
   "Prod.fst",
   "HDiv.hDiv",
   "eq_self",
   "of_eq_true",
   "congr",
   "Eq.symm",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.div_eq_eval‚ÇÉ",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] {a‚ÇÅ : ‚Ñ§ √ó M} (a‚ÇÇ : ‚Ñ§ √ó M) {l‚ÇÅ l‚ÇÇ l : Mathlib.Tactic.FieldSimp.NF M},\n  (a‚ÇÅ ::·µ£ l‚ÇÅ).eval / l‚ÇÇ.eval = l.eval ‚Üí (a‚ÇÅ ::·µ£ l‚ÇÅ).eval / (a‚ÇÇ ::·µ£ l‚ÇÇ).eval = ((-a‚ÇÇ.1, a‚ÇÇ.2) ::·µ£ l).eval",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isInt_neg.match_1_1",
   "Neg.neg",
   "Eq.symm",
   "Int.neg",
   "Int.cast",
   "Int.cast_neg"],
  "name": "Mathlib.Meta.NormNum.isInt_neg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {f : Œ± ‚Üí Œ±} {a : Œ±} {a' b : ‚Ñ§},\n  f = Neg.neg ‚Üí Mathlib.Meta.NormNum.IsInt a a' ‚Üí a'.neg = b ‚Üí Mathlib.Meta.NormNum.IsInt (-a) b",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (M : Submodule ùïú E‚ÇÄ), LinearMap.range f ‚â§ M ‚Üí ‚àÄ (x : ‚Ü•(LinearMap.range f)), ‚Üëx ‚àà M",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_14",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "le_of_not_gt",
   "StrictAnti.antitone",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "norm_zero",
   "rfl",
   "sub_self",
   "Norm.norm",
   "NNReal",
   "Nat.recAux",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_11",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.mk_eq_and_norm_sub_lt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_15",
   "Nat.le_succ",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "Nat.rawCast",
   "max_le",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "HasQuotient.Quotient",
   "Mathlib.Tactic.Ring.add_mul",
   "Nat.le_add_left",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "congr",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_9",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_8",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "ENNReal.top_ne_zero",
   "Mem‚Ñìp.neg",
   "HPow.hPow",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Max.max",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_10",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "QuotientAddGroup.mk",
   "inferInstance",
   "dite",
   "neg_neg_of_pos",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "HMul.hMul",
   "Int.rawCast",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "sub_add_sub_cancel",
   "GE.ge",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_13",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "zero_mem‚Ñìp",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "QuotientAddGroup.mk'",
   "And.left",
   "Mem‚Ñìp.add",
   "Neg.neg",
   "And.right",
   "lt_of_le_of_lt",
   "Mathlib.Tactic.Ring.mul_zero",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "Submodule.toAddSubgroup",
   "BddAbove",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "lp.norm_apply_le_norm",
   "Nat.cast_zero",
   "Iff.mpr",
   "id",
   "mem‚Ñìp_infty",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_6",
   "Nat.cast",
   "IsUltrametricDist.norm_add_le_max",
   "lp",
   "Eq.mp",
   "Metric.mem_closedBall",
   "le_trans",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "bddAbove_def",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_12",
   "Subtype.prop",
   "Mem‚Ñìp",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "dist_self",
   "PreLp",
   "Set.Nonempty",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "lt_add_one",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_7",
   "Mathlib.Tactic.Ring.neg_congr",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Nat.le_add_right"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_2) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] [‚àÄ (i : ‚Ñï), IsUltrametricDist (E i)],\n  SphericallyCompleteSpace (‚Ü•(lp E ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú E)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Mem‚Ñìp",
   "zero_mem‚Ñìp",
   "forall_congr",
   "funext",
   "Set.range_const",
   "PreLp",
   "Mem‚Ñìp.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Mem‚Ñìp.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "Iff.mpr",
   "LE.le",
   "HSMul.hSMul",
   "id",
   "Top.top",
   "Eq.mpr",
   "mem‚Ñìp_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_6",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (c : ùïú) (x : E), (fun x_1 ‚Ü¶ c ‚Ä¢ x) ‚àà lp (fun x ‚Ü¶ E) ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm", "dist_zero_left", "Dist.dist", "funext", "OfNat.ofNat"],
  "name": "dist_zero",
  "constType": "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E], dist 0 = norm",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Top.top", "lt_top_iff_ne_top", "Iff.not_left"],
  "name": "not_lt_top_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, ¬¨a < ‚ä§ ‚Üî a = ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap.bound",
   "RingHom.id",
   "DFunLike.coe",
   "LinearMap.isLinear"],
  "name": "ContinuousLinearMap.isBoundedLinearMap",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ùïú F]\n  (f : E ‚ÜíL[ùïú] F), IsBoundedLinearMap ùïú ‚áëf",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_11",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), (y ‚àà f '' s) = ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.PropLemmas.0.exists_and_left.match_1_1",
   "_private.Init.PropLemmas.0.exists_and_left.match_1_3"],
  "name": "exists_and_left",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {b : Prop}, (‚àÉ x, b ‚àß p x) ‚Üî b ‚àß ‚àÉ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set.Nonempty",
   "Set",
   "Antitone",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter"],
  "name": "SphericallyCompleteSpace.recOn",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    {motive : SphericallyCompleteSpace Œ± ‚Üí Sort u} ‚Üí\n      (t : SphericallyCompleteSpace Œ±) ‚Üí\n        ((isSphericallyComplete :\n              ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n                (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí\n                  (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty) ‚Üí\n            motive ‚ãØ) ‚Üí\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), (y ‚àà f '' s) = ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_iUnion", "Set", "Membership.mem", "Set.iUnion", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_6",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÉ i, s i) = ‚àÉ i, x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_prop", "Set", "Membership.mem", "eq_true", "Subtype.val"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Type u_1} {S : Set Œ±} (a : { a // a ‚àà S }), (‚Üëa ‚àà S) = True",
  "constCategory": "Theorem"},
 {"references": ["Left.mul_nonneg"],
  "name": "mul_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : MulZeroClass Œ±] {a b : Œ±} [inst_1 : Preorder Œ±] [PosMulMono Œ±], 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a * b",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl", "GE.ge"],
  "name": "ge_iff_le",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, x ‚â• y ‚Üî y ‚â§ x",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "le_refl",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "LinearIsometry.isometry",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "DFunLike.coe",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.sphericalCompletion_minimal",
   "LinearIsometryEquiv.symm",
   "RingHom.id",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Isometry.isometryEquivOnRange",
   "LinearIsometryEquiv.toIsometryEquiv",
   "Exists.choose",
   "Function.Surjective",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "LinearIsometryEquiv.ofSurjective",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_eq_sphericalCompletion",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace E ‚Üî Function.Surjective ‚áë(SphericallyCompleteSpace.SphericalCompletionEmbedding ùïú E)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_or", "propext"],
  "name": "not_or._simp_2",
  "constType": "‚àÄ {p q : Prop}, (¬¨(p ‚à® q)) = (¬¨p ‚àß ¬¨q)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Norm.norm",
   "ite",
   "ENNReal.top_ne_zero._simp_1",
   "SummationFilter.unconditional",
   "ite_cond_eq_true",
   "HPow.hPow",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "BddAbove",
   "Set.range",
   "congrArg",
   "Summable",
   "eq_self",
   "ENNReal",
   "iff_self",
   "of_eq_true",
   "ENNReal.toReal",
   "Top.top",
   "Ne",
   "Set.Finite",
   "setOf"],
  "name": "mem‚Ñìp_infty_iff",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] {f : (i : Œ±) ‚Üí E i},\n  Mem‚Ñìp f ‚ä§ ‚Üî BddAbove (Set.range fun i ‚Ü¶ ‚Äñf i‚Äñ)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.ndrec"],
  "name": "AddHom.mk.congr_simp",
  "constType":
  "‚àÄ {M : Type u_10} {N : Type u_11} [inst : Add M] [inst_1 : Add N] (toFun toFun_1 : M ‚Üí N) (e_toFun : toFun = toFun_1)\n  (map_add' : ‚àÄ (x y : M), toFun (x + y) = toFun x + toFun y),\n  { toFun := toFun, map_add' := map_add' } = { toFun := toFun_1, map_add' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["not_le_of_gt", "LT.lt", "le_of_lt", "le_trans", "LE.le", "lt_of_le_not_ge"],
  "name": "lt_of_lt_of_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b c : Œ±}, a < b ‚Üí b ‚â§ c ‚Üí a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.biUnion_of_singleton",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq.symm",
   "id",
   "Set.Finite.isClosed_biUnion",
   "Set.iUnion",
   "Eq.mpr",
   "Set.Finite",
   "isClosed_singleton",
   "congrArg"],
  "name": "Set.Finite.isClosed",
  "constType":
  "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [T1Space X] {s : Set X}, s.Finite ‚Üí IsClosed s",
  "constCategory": "Theorem"},
 {"references": ["rfl", "eq_true"],
  "name": "eq_self",
  "constType": "‚àÄ {Œ± : Sort u_1} (a : Œ±), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Metric.diam",
   "csInf_le_csInf'",
   "Set.iInter",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "dist_le_coe",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_4",
   "le_of_not_gt",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "rfl",
   "NNReal",
   "IsUltrametricDist.dist_triangle_max",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "NNDist.nndist",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "diam_le_radius_of_ultrametric",
   "Mathlib.Tactic.Ring.add_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_6",
   "Metric.dist_le_diam_of_mem",
   "and_true",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "InfSet.sInf",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_2",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_7",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_8",
   "HPow.hPow",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "Nat.cast_add",
   "eq_self",
   "Metric.closedBall",
   "Max.max",
   "OrderBot.bddBelow",
   "antitone_nat_of_succ_le",
   "neg_neg_of_pos",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_10",
   "And.casesOn",
   "Mathlib.Tactic.Ring.zero_mul",
   "Nat.cast_one",
   "le_refl",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Metric.isBounded_closedBall",
   "Membership.mem",
   "Int.rawCast",
   "HMul.hMul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_5",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_3",
   "csInf_le",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_9",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Exists.casesOn",
   "Mathlib.Tactic.Ring.atom_pf",
   "HasSubset.Subset",
   "Iff.mpr",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "max_le_iff",
   "NNReal.toReal",
   "le_csInf_iff''",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "dist_self",
   "Set.Nonempty",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.add_congr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_1",
   "LT.lt",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [iud : IsUltrametricDist Œ±],\n  SphericallyCompleteSpace Œ± ‚Üî\n    ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n      Antitone ri ‚Üí\n        (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.node5",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "SphericallyCompleteSpace._aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___unexpand_SphericallyCompleteSpace_Orth_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_22",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, (dist x y ‚â§ ‚Üëc) = (nndist x y ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Subtype.prop",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "id",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_2",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (z : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F), ‚Üëz.1 + ‚Üëz.2 ‚àà ùïú ‚àô x + F",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "NNReal",
   "NNDist.nndist",
   "NNReal.coe_eq_zero",
   "NNReal.toReal",
   "Iff.mp",
   "OfNat.ofNat"],
  "name": "nndist_self",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (a : Œ±), nndist a a = 0",
  "constCategory": "Theorem"},
 {"references": ["le_antisymm"],
  "name": "eq_of_le_of_ge",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references": ["Module.add_smul"],
  "name": "add_smul",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (r s : R)\n  (x : M), (r + s) ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_forall", "propext"],
  "name": "Mathlib.Tactic.Push.not_forall_eq",
  "constType": "‚àÄ {Œ± : Sort u_1} (s : Œ± ‚Üí Prop), (¬¨‚àÄ (x : Œ±), s x) = ‚àÉ x, ¬¨s x",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_15",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) = ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp", "Membership.mem", "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.OrthComp.congr_simp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F F_1 : Submodule ùïú E) (e_F : F = F_1)\n  [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  SphericallyCompleteSpace.OrthComp ùïú F = SphericallyCompleteSpace.OrthComp ùïú F_1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "IsLinearMap.mk'",
   "Eq.trans",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_4",
   "Classical.propDecidable",
   "LinearMap.toAddHom",
   "Set.iInter",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "StrictAnti.comp_strictMono",
   "zero_le",
   "RingHom.id",
   "congrFun",
   "Eq.symm",
   "Classical.not_not._simp_3",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_7",
   "AddHom.toFun",
   "Eq.ndrec",
   "norm_zero",
   "rfl",
   "sub_self",
   "Norm.norm",
   "Exists.choose_spec",
   "NNReal",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_6",
   "MulZeroClass.mul_zero",
   "true_and",
   "implies_true",
   "Filter.atTop",
   "Antitone",
   "Submodule.mem_bot",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
   "Exists.choose.congr_simp",
   "StrictMono",
   "dist_eq_norm",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_5",
   "congr",
   "Nat.lt_succ_self",
   "map_zero",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_2",
   "propext",
   "exists_bijective_subseq_of_finite_duplication",
   "Set",
   "dist_comm",
   "StrictMono.tendsto_atTop",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Set.univ",
   "eq_self",
   "Metric.closedBall",
   "and_self",
   "Max.max",
   "inferInstance",
   "Ne",
   "dite",
   "Mathlib.Tactic.Push.not_forall_eq",
   "Function.Injective",
   "And.casesOn",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "GT.gt",
   "trichotomous",
   "eq_of_heq",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "max_eq_left",
   "Filter.Tendsto",
   "And.left",
   "binderNameHint",
   "lt_of_le_of_lt",
   "And.right",
   "add_zero",
   "Bot.bot",
   "Exists.casesOn",
   "Set.image",
   "max_self",
   "HSMul.hSMul",
   "id",
   "smul_zero",
   "Eq.mp",
   "Metric.mem_closedBall",
   "NNReal.toReal",
   "DFunLike.coe",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "SphericallyCompleteSpace.exists_extension_opNorm_le",
   "Subtype.prop",
   "Dist.dist",
   "continuous_of_const",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_1",
   "Not",
   "dist_self",
   "Classical.not_imp._simp_2",
   "Set.Nonempty",
   "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_3",
   "Function.comp",
   "StrictMono.monotone",
   "Exists.choose",
   "Eq.casesOn",
   "LT.lt",
   "Or.casesOn",
   "StrictAnti",
   "of_eq_true",
   "le_of_lt",
   "Filter.tendsto_atTop_atTop_iff_of_monotone",
   "LE.le",
   "max_eq_right"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] {F : Type u_3} [inst_4 : SeminormedAddCommGroup F]\n  [IsUltrametricDist F] [inst_6 : NormedSpace ùïú F] [SphericallyCompleteSpace F], SphericallyCompleteSpace (E ‚ÜíL[ùïú] F)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "zero_add",
   "Eq.trans",
   "of_eq_true",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "‚àÄ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "le_of_le_of_eq",
  "constType":
  "‚àÄ {Œ± : Type u_1} {a b c : Œ±} [inst : LE Œ±], a ‚â§ b ‚Üí b = c ‚Üí a ‚â§ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inter.inter",
  "constType": "{Œ± : Type u} ‚Üí [self : Inter Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : IsUltrametricDist E] ‚Üí\n          [inst_3 : NormedSpace ùïú E] ‚Üí\n            {D : Submodule ùïú E} ‚Üí\n              {F : Type u_3} ‚Üí\n                [inst_4 : SeminormedAddCommGroup F] ‚Üí\n                  [inst_5 : IsUltrametricDist F] ‚Üí\n                    [inst_6 : NormedSpace ùïú F] ‚Üí\n                      [inst_7 : SphericallyCompleteSpace F] ‚Üí\n                        {S : ‚Ü•D ‚ÜíL[ùïú] F} ‚Üí\n                          {ùí∞ : Set (E ‚ÜíL[ùïú] F)} ‚Üí\n                            {hùí∞ : ùí∞.Nonempty} ‚Üí\n                              {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù} ‚Üí SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ ‚Üí Submodule ùïú E",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "lp",
   "Membership.mem",
   "GT.gt",
   "GE.ge",
   "Subtype.val",
   "congrArg",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_2",
   "funext",
   "forall_congr",
   "norm_zero",
   "PreLp",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_3",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_4",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
   "LT.lt",
   "ENNReal",
   "le_of_lt",
   "LE.le",
   "Top.top",
   "id",
   "Eq.mpr",
   "setOf"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._proof_3",
  "constType":
  "‚àÄ (E : ‚Ñï ‚Üí Type u_1) [inst : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)], 0 ‚àà {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ}",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Iff.rfl",
   "Set.singleton_subset_iff",
   "congrArg",
   "SetLike.mem_coe",
   "SetLike.coe",
   "HasSubset.Subset",
   "Submodule.span_le",
   "LE.le",
   "id",
   "Eq.mpr",
   "propext"],
  "name": "Submodule.span_singleton_le_iff_mem",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (m : M)\n  (p : Submodule R M), R ‚àô m ‚â§ p ‚Üî m ‚àà p",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.coe_eq_zero",
   "Membership.mem",
   "Subtype.val",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_14",
  "constType":
  "‚àÄ {A : Type u_3} {M‚ÇÅ : Type u_4} [inst : SetLike A M‚ÇÅ] [inst_1 : Zero M‚ÇÅ] [hA : ZeroMemClass A M‚ÇÅ] {S' : A} {x : ‚Ü•S'},\n  (‚Üëx = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec"],
  "name": "Subtype.mk.congr_simp",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (val val_1 : Œ±) (e_val : val = val_1) (property : p val), ‚ü®val, property‚ü© = ‚ü®val_1, ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "HasQuotient.Quotient",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Mem‚Ñìp",
   "zero_mem‚Ñìp",
   "forall_congr",
   "funext",
   "Set.range_const",
   "QuotientAddGroup.mk'",
   "rfl",
   "PreLp",
   "Mem‚Ñìp.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Mem‚Ñìp.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "HAdd.hAdd",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "Iff.mpr",
   "LE.le",
   "Top.top",
   "id",
   "Eq.mpr",
   "mem‚Ñìp_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_5",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x y : E),\n  (have this := ‚ãØ;\n    (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup) ‚ü®fun x_1 ‚Ü¶ x + y, this‚ü©) =\n    have this := ‚ãØ;\n    (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup) ‚ü®fun x_1 ‚Ü¶ x + y, this‚ü©",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "left_eq_sup", "propext"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, (a = a ‚äî b) = (b ‚â§ a)",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "Submodule.toAddSubmonoid",
   "HasQuotient.Quotient",
   "lp",
   "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ._proof_1",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "AddSubsemigroup.carrier",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
   "Top.top",
   "inferInstance",
   "AddSubmonoid.toAddSubsemigroup"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u_2) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí NormedAddCommGroup (‚Ü•(lp (fun x ‚Ü¶ E) ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E)",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Mem‚Ñìp",
   "zero_mem‚Ñìp",
   "forall_congr",
   "funext",
   "Set.range_const",
   "PreLp",
   "Mem‚Ñìp.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Mem‚Ñìp.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "Iff.mpr",
   "LE.le",
   "id",
   "Top.top",
   "Eq.mpr",
   "mem‚Ñìp_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_2",
  "constType":
  "‚àÄ (E : Type u_1) [inst : NormedAddCommGroup E] (x : E), (fun x_1 ‚Ü¶ x) ‚àà lp (fun x ‚Ü¶ E) ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "add_left_comm",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ c‚ÇÅ c‚ÇÇ : R},\n  a‚ÇÅ + b‚ÇÅ = c‚ÇÅ ‚Üí a‚ÇÇ + b‚ÇÇ = c‚ÇÇ ‚Üí a‚ÇÅ + a‚ÇÇ + (b‚ÇÅ + b‚ÇÇ) = c‚ÇÅ + c‚ÇÇ",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "id",
   "iff_true",
   "Eq.mpr",
   "eq_iff_iff._simp_1",
   "iff_false"],
  "name": "Lean.Grind.eq_false_of_imp_eq_true",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üí b) = True ‚Üí b = False ‚Üí a = False",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "Eq.mp",
   "SphericallyCompleteSpace.sorth_symm",
   "Membership.mem",
   "SphericallyCompleteSpace.SOrth",
   "propext",
   "congrArg",
   "SphericallyCompleteSpace.sorth_orthcomp"],
  "name": "SphericallyCompleteSpace.morth_of_mem_orthComp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F]\n  {x : E}, x ‚àà SphericallyCompleteSpace.OrthComp ùïú F ‚Üí SphericallyCompleteSpace.MOrth ùïú x F",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "HSMul.hSMul",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_9",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (M : Submodule ùïú E‚ÇÄ), LinearMap.range f ‚â§ M ‚Üí ‚àÄ (x : ùïú) (x_1 : ‚Ü•(LinearMap.range f)), ‚Üë(x ‚Ä¢ x_1) ‚àà M",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_11",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ}, (x ‚àà LinearMap.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace",
  "constType": "(Œ± : Type u_1) ‚Üí [PseudoMetricSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Norm.norm",
   "LinearMap.range",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "HAdd.hAdd",
   "RingHom.id",
   "LE.le",
   "Subtype.property",
   "HSMul.hSMul"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (M : Submodule ùïú E‚ÇÄ) (hc : LinearMap.range f ‚â§ M) (x : ‚Ü•(LinearMap.range f)),\n  ‚Äñ{ toFun := fun x ‚Ü¶ ‚ü®‚Üëx, ‚ãØ‚ü©, map_add' := ‚ãØ, map_smul' := ‚ãØ } x‚Äñ =\n    ‚Äñ{ toFun := fun x ‚Ü¶ ‚ü®‚Üëx, ‚ãØ‚ü©, map_add' := ‚ãØ, map_smul' := ‚ãØ } x‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["SetLike.coe", "Norm.norm", "Metric.infDist", "Subspace"],
  "name": "SphericallyCompleteSpace.MOrth",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí [inst_2 : NormedSpace ùïú E] ‚Üí [IsUltrametricDist E] ‚Üí E ‚Üí Subspace ùïú E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And.left",
  "constType": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "LE.le",
   "Submodule.span_singleton_le_iff_mem",
   "Submodule.span",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_7",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (m : M)\n  (p : Submodule R M), (R ‚àô m ‚â§ p) = (m ‚àà p)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul.match_1", "Nat.add", "Nat.below", "Nat.brecOn", "OfNat.ofNat"],
  "name": "Nat.mul",
  "constType": "‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["Left.add_nonneg"],
  "name": "add_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±] [AddLeftMono Œ±] {a b : Œ±}, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a + b",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate._simp_1_2",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "Subtype.mk.injEq",
   "Submodule.ext",
   "Eq.trans",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_5",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "heq_of_eq",
   "Membership.mem.out",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_2",
   "RingHom.id",
   "funext",
   "eq_of_heq",
   "Eq.symm",
   "AddHom.toFun",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "Eq.ndrec",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.MOrth",
   "HEq.casesOn",
   "And.left",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_21",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Norm.norm",
   "Exists.choose_spec",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_7",
   "Submodule.toAddSubgroup",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "Exists.casesOn",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "Iff.of_eq",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_12",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Top.top",
   "Eq.mpr",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_20",
   "DFunLike.coe",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "Subspace",
   "congrArg",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
   "congr",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "propext",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Exists.choose",
   "Eq.casesOn",
   "exists_prop_congr",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_8",
   "ENNReal",
   "of_eq_true",
   "LE.le",
   "QuotientAddGroup.mk",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_1",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace.IsImmediate (SphericallyCompleteSpace.SphericalCompletionEmbedding ùïú E)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "ENNReal.trichotomy",
   "Eq.trans",
   "NNReal.coe_nonneg",
   "Singleton.singleton",
   "Membership.mem",
   "Mem‚Ñìp.summable",
   "Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg",
   "HMul.hMul",
   "Real.rpow_le_rpow",
   "Union.union",
   "NNNorm.nnnorm",
   "NNReal.coe_le_coe",
   "Fin.instUnique._proof_1",
   "HSub.hSub",
   "ENNReal.toReal",
   "Eq.symm",
   "Finset.sum",
   "Classical.not_not._simp_3",
   "Eq.ndrec",
   "rfl",
   "Norm.norm",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
   "NNReal",
   "add_zero",
   "norm_add_le",
   "BddAbove",
   "_private.Mathlib.Analysis.Normed.Lp.lpSpace.0.Mem‚Ñìp.add._simp_1_1",
   "Exists.casesOn",
   "if_neg",
   "Summable.of_nonneg_of_le",
   "upperBounds",
   "Iff.mpr",
   "Matrix.vecEmpty",
   "id",
   "Top.top",
   "Eq.mpr",
   "Fin.sum_univ_succ",
   "mem‚Ñìp_infty",
   "one_mul",
   "Mem‚Ñìp.finite_dsupport",
   "Fin.succ",
   "setOf",
   "Nat.cast",
   "Matrix.vecCons",
   "Summable.add",
   "Eq.mp",
   "SummationFilter.unconditional",
   "le_trans",
   "NNReal.toReal",
   "mem‚Ñìp_zero",
   "Set.range",
   "LE.le.trans",
   "congrArg",
   "Finset.sum_congr",
   "Fintype.card",
   "Mem‚Ñìp.bddAbove",
   "Fintype.card_fin",
   "add_le_add",
   "Mem‚Ñìp",
   "Finset.univ_unique",
   "Set.Finite.union",
   "congr",
   "mem‚Ñìp_gen",
   "ge_iff_le._simp_1",
   "LT.lt.le",
   "Not",
   "Finset.univ",
   "Set.Finite.subset",
   "Set",
   "ite",
   "Finset.card",
   "Real.rpow_nonneg",
   "NNReal.rpow_add_le_add_rpow",
   "HPow.hPow",
   "Summable.mul_left",
   "not_or._simp_2",
   "OfNat.ofNat",
   "Or.casesOn",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "LE.le",
   "_private.Mathlib.Analysis.Normed.Lp.lpSpace.0.Mem‚Ñìp.add._simp_1_2",
   "norm_nonneg",
   "Ne",
   "dite",
   "Finset.sum_singleton",
   "if_pos",
   "And.casesOn"],
  "name": "Mem‚Ñìp.add",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} {p : ENNReal} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] {f g : (i : Œ±) ‚Üí E i},\n  Mem‚Ñìp f p ‚Üí Mem‚Ñìp g p ‚Üí Mem‚Ñìp (f + g) p",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le", "PosMulMono.mul_le_mul_of_nonneg_left", "OfNat.ofNat"],
  "name": "mul_le_mul_of_nonneg_left",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] {a b c : Œ±} [PosMulMono Œ±],\n  b ‚â§ c ‚Üí 0 ‚â§ a ‚Üí a * b ‚â§ a * c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "‚àÄ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "AddSubgroup.mem_mk",
   "Neg.neg",
   "Set",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] {s : AddSubmonoid G} {x : G} (h_neg : ‚àÄ {x : G}, x ‚àà s.carrier ‚Üí -x ‚àà s.carrier),\n  (x ‚àà { toAddSubmonoid := s, neg_mem' := h_neg }) = (x ‚àà s)",
  "constCategory": "Theorem"},
 {"references": ["Iff.mpr", "trivial", "propext"],
  "name": "iff_true",
  "constType": "‚àÄ (p : Prop), (p ‚Üî True) = p",
  "constCategory": "Theorem"},
 {"references": ["rfl", "HasSubset.Subset", "Set"],
  "name": "Set.subset_def",
  "constType": "‚àÄ {Œ± : Type u} {s t : Set Œ±}, (s ‚äÜ t) = ‚àÄ x ‚àà s, x ‚àà t",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Int.rawCast",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "le_of_not_gt",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.sub_pf",
   "Metric.nonempty_closedBall",
   "Neg.neg",
   "NNReal",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.mpr",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "id",
   "Int.negOfNat",
   "Metric.isClosed_closedBall",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Tactic.Ring.add_mul",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.sub_congr",
   "ProperSpace.isCompact_closedBall",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Set.Nonempty",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed",
   "neg_neg_of_pos"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpaceOfProperSpace",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [ProperSpace Œ±], SphericallyCompleteSpace Œ±",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists.casesOn",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {motive : Exists p ‚Üí Prop} (t : Exists p), (‚àÄ (w : Œ±) (h : p w), motive ‚ãØ) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Subtype.prop",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "id",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_3",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (x_1 y : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F), ‚Üë(x_1 + y).1 + ‚Üë(x_1 + y).2 ‚àà ùïú ‚àô x + F",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.Orth"],
  "name": "SphericallyCompleteSpace.Orth.congr_simp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  x = x_1 ‚Üí ‚àÄ (y y_1 : E), y = y_1 ‚Üí (x ‚üÇ[ùïú] y) = (x_1 ‚üÇ[ùïú] y_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "not_le",
   "norm_le_zero_iff",
   "Norm.norm",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Ne",
   "propext"],
  "name": "norm_pos_iff",
  "constType":
  "‚àÄ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, 0 < ‚Äña‚Äñ ‚Üî a ‚â† 0",
  "constCategory": "Theorem"},
 {"references":
  ["IsometryEquiv.symm._proof_1", "IsometryEquiv.toEquiv", "Equiv.symm"],
  "name": "IsometryEquiv.symm",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí Œ± ‚âÉ·µ¢ Œ≤ ‚Üí Œ≤ ‚âÉ·µ¢ Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "AddMemClass.add_mem",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Add M} {inst_1 : SetLike S M} [self : AddMemClass S M] {s : S}\n  {a b : M}, a ‚àà s ‚Üí b ‚àà s ‚Üí a + b ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÄ (a : Œ±), a = a' ‚Üí p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Left.one_le_inv_iff._simp_4",
   "Eq.trans",
   "Neg.neg",
   "Eq.mp",
   "HMul.hMul",
   "mul_nonneg_of_nonpos_of_nonpos",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "le_of_lt",
   "neg_mul",
   "LE.le",
   "neg_neg_of_pos",
   "ge_iff_le._simp_1"],
  "name": "Mathlib.Tactic.Linarith.mul_nonpos",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Ring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] {a b : Œ±}, a ‚â§ 0 ‚Üí 0 < b ‚Üí b * a ‚â§ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.ediam_le_of_forall_dist_le",
   "Set",
   "Dist.dist",
   "Membership.mem",
   "LE.le",
   "EMetric.diam",
   "ENNReal.toReal_le_of_le_ofReal",
   "OfNat.ofNat"],
  "name": "Metric.diam_le_of_forall_dist_le",
  "constType":
  "‚àÄ {Œ± : Type u} {s : Set Œ±} [inst : PseudoMetricSpace Œ±] {C : ‚Ñù},\n  0 ‚â§ C ‚Üí (‚àÄ x ‚àà s, ‚àÄ y ‚àà s, dist x y ‚â§ C) ‚Üí Metric.diam s ‚â§ C",
  "constCategory": "Theorem"},
 {"references": ["NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} ‚Üí [NatCast R] ‚Üí ‚Ñï ‚Üí R",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_7",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.casesOn",
   "HAdd.hAdd",
   "LT.lt",
   "AddLeftReflectLT",
   "LE.le",
   "Eq.symm",
   "Eq.ndrec",
   "pos_of_lt_add_right",
   "le_of_forall_gt_imp_ge_of_dense",
   "OfNat.ofNat",
   "LT.lt.le",
   "ExistsAddOfLE.exists_add_of_le"],
  "name": "le_of_forall_pos_le_add",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] [DenselyOrdered Œ±] [inst_2 : AddMonoid Œ±] [ExistsAddOfLE Œ±] [AddLeftReflectLT Œ±]\n  {a b : Œ±}, (‚àÄ (Œµ : Œ±), 0 < Œµ ‚Üí a ‚â§ b + Œµ) ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_6",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Int.sub_self", "id", "HSub.hSub", "Eq.mpr", "OfNat.ofNat", "congrArg"],
  "name": "Int.sub_eq_zero_of_eq",
  "constType": "‚àÄ {a b : ‚Ñ§}, a = b ‚Üí a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "LE.le",
   "HMul.hMul",
   "Real.sInf_nonneg",
   "DFunLike.coe",
   "OfNat.ofNat",
   "And.left",
   "setOf"],
  "name": "ContinuousLinearMap.opNorm_nonneg",
  "constType":
  "‚àÄ {ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ùïú] [inst_3 : NontriviallyNormedField ùïú‚ÇÇ]\n  [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F), 0 ‚â§ ‚Äñf‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Elem"],
  "name": "Set.Countable",
  "constType": "{Œ± : Type u} ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ne.lt_top'",
   "Eq.trans",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.isboundedlinearmap_of_glued_map._simp_2",
   "Singleton.singleton",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
   "Membership.mem",
   "HMul.hMul",
   "eq_true",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.T",
   "Submodule.span",
   "GT.gt",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_2",
   "congrFun",
   "RingHom.id",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "rfl",
   "zorn_le_nonempty",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_1",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hDM",
   "Norm.norm",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "LinearEquiv.ofTop",
   "And.right",
   "Exists.casesOn",
   "implies_true",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hT",
   "SetLike.coe",
   "HSMul.hSMul",
   "Classical.byContradiction",
   "id",
   "Top.top",
   "Eq.mpr",
   "one_mul",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_4",
   "IsChain",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_1",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "DFunLike.coe",
   "Submodule.mem_top",
   "congrArg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_2",
   "ContinuousLinearMap.isBoundedLinearMap",
   "Subtype.prop",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_1",
   "Submodule.mem_sup",
   "congr",
   "IsMax",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1",
   "propext",
   "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_3",
   "Not",
   "Set.exists_of_ssubset",
   "Set.Nonempty",
   "Set",
   "Submodule.add_eq_sup",
   "Function.comp",
   "LinearEquiv.symm",
   "OfNat.ofNat",
   "IsBoundedLinearMap.comp",
   "not_le_of_gt",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension",
   "Max.max",
   "and_self",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
   "of_eq_true",
   "le_of_lt",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hU",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_iff",
   "Ne",
   "trivial",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] (D : Submodule ùïú E) {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ùïú F]\n  [SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) {ùí∞ : Set (E ‚ÜíL[ùïú] F)},\n  ùí∞.Nonempty ‚Üí\n    ‚àÄ (Œµ : ‚Üëùí∞ ‚Üí ‚Ñù),\n      (‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) ‚Üí\n        (‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V)) ‚Üí\n          (‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ) ‚Üí ‚àÉ T, (‚àÄ (x : ‚Ü•D), T ‚Üëx = S x) ‚àß ‚àÄ (U : ‚Üëùí∞), ‚ÄñT - ‚ÜëU‚Äñ ‚â§ Œµ U",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "Nat.cast",
   "Nat.cast_zero",
   "LE.le",
   "Nat.zero_le",
   "Nat.mono_cast",
   "OfNat.ofNat"],
  "name": "Nat.cast_nonneg'",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] (n : ‚Ñï),\n  0 ‚â§ ‚Üën",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_10",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, (x ‚â• y) = (y ‚â§ x)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "eq_self", "Eq.trans", "of_eq_true", "add_assoc", "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a‚ÇÇ b c : R} (a‚ÇÅ : R), a‚ÇÇ + b = c ‚Üí a‚ÇÅ + a‚ÇÇ + b = a‚ÇÅ + c",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.SOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.SOrth.eq_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (F1 F2 : Subspace ùïú E),\n  SphericallyCompleteSpace.SOrth ùïú F1 F2 = ‚àÄ x ‚àà F1, SphericallyCompleteSpace.MOrth ùïú x F2",
  "constCategory": "Theorem"},
 {"references":
  ["Isometry.preimage_closedBall",
   "Metric.closedBall",
   "Set.preimage",
   "Set",
   "IsometryEquiv.symm",
   "IsometryEquiv.apply_symm_apply",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "IsometryEquiv.isometry",
   "DFunLike.coe",
   "congrArg"],
  "name": "IsometryEquiv.preimage_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) (x : Œ≤) (r : ‚Ñù),\n  ‚áëh ‚Åª¬π' Metric.closedBall x r = Metric.closedBall (h.symm x) r",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "sub_eq_zero",
   "Eq.mp",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Classical.propDecidable",
   "Submodule.span",
   "congrArg",
   "False.elim",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "HSub.hSub",
   "add_comm",
   "propext",
   "rfl",
   "Not",
   "Inv.inv",
   "sub_eq_sub_iff_add_eq_add",
   "Set",
   "Submodule.smul_mem",
   "Submodule.sub_mem_iff_left",
   "OfNat.ofNat",
   "eq_inv_smul_iff‚ÇÄ",
   "HAdd.hAdd",
   "Exists.casesOn",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "zero_smul",
   "Eq.mpr",
   "dite"],
  "name": "eq_and_eq_of_add_eq_add_of_not_mem_submodule_span_singleton",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : _root_.Module ùïú V]\n  {D : Submodule ùïú V} {a : V},\n  a ‚àâ D ‚Üí ‚àÄ d1 ‚àà D, ‚àÄ la1 ‚àà ùïú ‚àô a, ‚àÄ d2 ‚àà D, ‚àÄ la2 ‚àà ùïú ‚àô a, d1 + la1 = d2 + la2 ‚Üí d1 = d2 ‚àß la1 = la2",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "IsMax",
  "constType": "{Œ± : Type u_1} ‚Üí [LE Œ±] ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "mul_inv_rev",
   "Inv.inv",
   "Nat.cast",
   "Nat.cast_ne_zero",
   "Eq.trans",
   "Invertible.invOf",
   "invOf_eq_inv",
   "Mathlib.Meta.NormNum.IsNNRat.casesOn",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "Nat.cast_add",
   "HAdd.hAdd",
   "eq_self",
   "inv_inv",
   "invertibleOfNonzero",
   "of_eq_true",
   "congr",
   "Iff.mpr",
   "Nat.succ_ne_zero",
   "Eq.symm",
   "Ne",
   "Eq.ndrec"],
  "name": "Mathlib.Meta.NormNum.isNNRat_inv_pos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : DivisionSemiring Œ±] [CharZero Œ±] {a : Œ±} {n d : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNNRat a n.succ d ‚Üí Mathlib.Meta.NormNum.IsNNRat a‚Åª¬π d n.succ",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLeftReflectLE",
  "constType": "(M : Type u_1) ‚Üí [Add M] ‚Üí [LE M] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set.univ", "Set", "Membership.mem", "eq_true", "Set.mem_univ"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_1",
  "constType": "‚àÄ {Œ± : Type u} (x : Œ±), (x ‚àà Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Not",
  "constType": "Prop ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Nat.rawCast",
   "add_zero",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.cast_pos.match_1_1",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ‚Ñï}, Mathlib.Meta.NormNum.IsNat a n ‚Üí a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "SProd.sprod", "Iff.rfl"],
  "name": "Set.mem_prod",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {s : Set Œ±} {t : Set Œ≤} {p : Œ± √ó Œ≤}, p ‚àà s √óÀ¢ t ‚Üî p.1 ‚àà s ‚àß p.2 ‚àà t",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Submodule.neg_mem",
   "Neg.neg",
   "Membership.mem",
   "Submodule.add_mem_iff_left",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "congrArg"],
  "name": "Submodule.sub_mem_iff_left",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x y : M}, y ‚àà p ‚Üí (x - y ‚àà p ‚Üî x ‚àà p)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "sub_neg_eq_add",
   "neg_sub",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "sub_add_sub_cancel",
   "congrArg"],
  "name": "sub_sub_sub_cancel_right",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - c - (b - c) = a - b",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "forall_const._simp_1",
  "constType":
  "‚àÄ {b : Prop} (Œ± : Sort u_1) [i : Nonempty Œ±], (‚àÄ (a : Œ±), b) = b",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt_of_ge", "le_of_not_gt", "LE.le"],
  "name": "not_lt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, ¬¨a < b ‚Üî b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["sub_nonpos_of_le", "LE.le"],
  "name": "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Ring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] {a b : Œ±}, a ‚â§ b ‚Üí a - b ‚â§ 0",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.OrthComp",
   "Eq.trans",
   "LinearIsometry.isometry",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Submodule.ne_bot_iff",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.isCompl_orthcomp",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "False.elim",
   "LinearIsometryEquiv.symm",
   "RingHom.id",
   "funext",
   "SphericallyCompleteSpace.morth_of_mem_orthComp",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_4",
   "And.right",
   "Bot.bot",
   "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_1",
   "Exists.casesOn",
   "SphericallyCompleteSpace.SphericalCompletion",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "sup_of_le_left",
   "Iff.of_eq",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "Iff.mpr",
   "LinearIsometryEquiv.ofSurjective",
   "Classical.byContradiction",
   "Top.top",
   "id",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "IsCompl.sup_eq_top",
   "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_2",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "SphericallyCompleteSpace.MaximallyComplete",
   "HasQuotient.Quotient",
   "lp",
   "Eq.mp",
   "LinearMap.range",
   "DFunLike.coe",
   "congrArg",
   "propext",
   "Not",
   "PreLp",
   "Classical.not_imp._simp_2",
   "Set",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Isometry.isometryEquivOnRange",
   "LinearIsometryEquiv.toIsometryEquiv",
   "Exists.choose",
   "Function.Surjective",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "ENNReal",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "Ne",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding",
   "And.casesOn",
   "Mathlib.Tactic.Push.not_forall_eq"],
  "name": "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E],\n  SphericallyCompleteSpace E ‚Üî SphericallyCompleteSpace.MaximallyComplete ùïú E",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Omega.LinearCombo.coeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.const",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.eval",
  "constType": "Omega.LinearCombo ‚Üí Omega.Coeffs ‚Üí ‚Ñ§",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "False.elim", "lt_irrefl"],
  "name": "lt_self_iff_false",
  "constType": "‚àÄ {Œ± : Type u_2} [inst : Preorder Œ±] (x : Œ±), x < x ‚Üî False",
  "constCategory": "Theorem"},
 {"references": ["Not", "by_contra"],
  "name": "Mathlib.Tactic.Contrapose.contrapose‚ÇÅ",
  "constType": "‚àÄ {p q : Prop}, (¬¨q ‚Üí ¬¨p) ‚Üí p ‚Üí q",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_15",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Exists.choose_spec",
   "Set",
   "And.right",
   "NNReal",
   "Membership.mem",
   "NNReal.toReal",
   "zero_lt_one",
   "Prod.snd",
   "Membership.mem.out",
   "GT.gt",
   "Exists.choose",
   "OfNat.ofNat",
   "Nonempty.some",
   "one_lt_two",
   "Prod.fst",
   "LT.lt",
   "Metric.closedBall",
   "Set.Ioc",
   "LE.le",
   "NNDist.nndist",
   "And.left",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] [nemp : Nonempty Œ±],\n  ‚àÉ z, nndist z.1 z.2 > 0",
  "constCategory": "Theorem"},
 {"references":
  ["iSup.eq_1",
   "iSup",
   "Set",
   "SupSet.sSup",
   "Singleton.singleton",
   "id",
   "Set.range_const",
   "csSup_singleton",
   "Eq.mpr",
   "Set.range",
   "congrArg"],
  "name": "ciSup_const",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} [inst : ConditionallyCompleteLattice Œ±] [hŒπ : Nonempty Œπ] {a : Œ±}, ‚®Ü x, a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.rangeFactorization_injective",
   "LinearMap.range",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "map_smul",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "RingHom.id",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Subtype.val_injective",
   "Set",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "Set.rangeFactorization_surjective",
   "Eq.casesOn",
   "Function.RightInverse",
   "Function.rightInverse_invFun",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_4",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí‚Çó·µ¢[ùïú] F)\n  (c : ùïú) (x : ‚Ü•(LinearMap.range f)),\n  Function.invFun (Set.rangeFactorization ‚áëf) (c ‚Ä¢ x) = (RingHom.id ùïú) c ‚Ä¢ Function.invFun (Set.rangeFactorization ‚áëf) x",
  "constCategory": "Theorem"},
 {"references":
  ["iff_self",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "_private.Init.PropLemmas.0.forall_apply_eq_imp_iff._simp_1_1",
   "forall_eq'._simp_1",
   "congrArg"],
  "name": "forall_apply_eq_imp_iff",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Prop}, (‚àÄ (b : Œ≤) (a : Œ±), f a = b ‚Üí p b) ‚Üî ‚àÄ (a : Œ±), p (f a)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "exists_eq",
  "constType": "‚àÄ {Œ± : Sort u_1} {a' : Œ±}, ‚àÉ a, a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["List.getLastD",
   "implies_congr",
   "List.getLastD_mem_cons",
   "_private.Mathlib.Data.List.TFAE.0.List.tfae_of_cycle._simp_1_1",
   "Eq.trans",
   "Eq.mp",
   "_private.Mathlib.Data.List.TFAE.0.List.tfae_of_cycle._simp_1_2",
   "Iff.mp",
   "eq_true",
   "List.tfae_singleton._simp_1",
   "and_true",
   "List.getLast?",
   "congrArg",
   "congr",
   "forall_congr",
   "List.TFAE",
   "List.IsChain.singleton._simp_1",
   "List.getLastD_cons",
   "List.getLastD_eq_getLast?",
   "_private.Mathlib.Data.List.TFAE.0.List.tfae_of_cycle._simp_1_3",
   "And.right",
   "Option.getD",
   "Function.comp",
   "implies_true",
   "and_self",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "List.isChain_cons_cons._simp_1",
   "And.casesOn"],
  "name": "List.tfae_of_cycle",
  "constType":
  "‚àÄ {a b : Prop} {l : List Prop},\n  List.IsChain (fun x1 x2 ‚Ü¶ x1 ‚Üí x2) (a :: b :: l) ‚Üí (l.getLastD b ‚Üí a) ‚Üí (a :: b :: l).TFAE",
  "constCategory": "Theorem"},
 {"references": ["Set", "iInf"],
  "name": "Set.iInter",
  "constType": "{Œ± : Type u} ‚Üí {Œπ : Sort v} ‚Üí (Œπ ‚Üí Set Œ±) ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mp",
   "LE.le",
   "mul_le_mul_of_nonneg_left",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Left.mul_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : MulZeroClass Œ±] {a b : Œ±} [inst_1 : Preorder Œ±] [PosMulMono Œ±], 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_4",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, (dist x y ‚â§ ‚Üëc) = (nndist x y ‚â§ c)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Elem",
  "constType": "{Œ± : Type u} ‚Üí Set Œ± ‚Üí Type u",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "Membership.mem",
   "AddMemClass.add_mem",
   "Submodule.mem_sup_right",
   "Submodule.mem_sup_left"],
  "name": "Submodule.add_mem_sup",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S T : Submodule R M} {s t : M}, s ‚àà S ‚Üí t ‚àà T ‚Üí s + t ‚àà S ‚äî T",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "NNReal", "NNReal.toReal", "Iff.rfl"],
  "name": "NNReal.coe_le_coe",
  "constType": "‚àÄ {r‚ÇÅ r‚ÇÇ : NNReal}, ‚Üër‚ÇÅ ‚â§ ‚Üër‚ÇÇ ‚Üî r‚ÇÅ ‚â§ r‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.OrthComp",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.isCompl_orthcomp",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "funext",
   "SphericallyCompleteSpace.morth_of_mem_orthComp",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.MOrth",
   "SphericallyCompleteSpace.sphericalCompletion_minimal._simp_1_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "Submodule.eq_bot_iff",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "SphericallyCompleteSpace.Orth",
   "Bot.bot",
   "Exists.casesOn",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "sup_of_le_left",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "Iff.not",
   "Classical.byContradiction",
   "Top.top",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "IsCompl.sup_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "Eq.mp",
   "LinearMap.range",
   "Subspace",
   "congrArg",
   "propext",
   "SphericallyCompleteSpace.morth_iff_forall_orth",
   "Not",
   "PreLp",
   "Classical.not_imp._simp_2",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "ENNReal",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "Ne",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding",
   "Mathlib.Tactic.Push.not_forall_eq",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_minimal",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E]\n  (M : Submodule ùïú (SphericallyCompleteSpace.SphericalCompletion ùïú E)),\n  LinearMap.range (SphericallyCompleteSpace.SphericalCompletionEmbedding ùïú E) ‚â§ M ‚Üí SphericallyCompleteSpace ‚Ü•M ‚Üí M = ‚ä§",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_5",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_7",
   "Submodule.toAddSubgroup",
   "DFunLike.coe",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_8",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_2",
   "RingHom.id",
   "Top.top",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_3",
   "QuotientAddGroup.mk'"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u_2) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí E ‚Üí‚Çó·µ¢[ùïú] ‚Ü•(lp (fun x ‚Ü¶ E) ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False.elim",
  "constType": "{C : Sort u} ‚Üí False ‚Üí C",
  "constCategory": "Definition"},
 {"references":
  ["LinearIsometryEquiv.symm._proof_1",
   "LinearIsometryEquiv.toLinearEquiv",
   "LinearEquiv.symm"],
  "name": "LinearIsometryEquiv.symm",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : _root_.Module R E] ‚Üí\n                          [inst_7 : _root_.Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E‚ÇÇ ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÅ] E",
  "constCategory": "Definition"},
 {"references": ["Nat.ofNat_pos", "LT.lt", "eq_true", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_17",
  "constType":
  "‚àÄ {Œ± : Type u_3} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] [Nontrivial Œ±] {n : ‚Ñï}\n  [inst_4 : n.AtLeastTwo], (0 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Singleton.singleton",
   "Submodule.smul_mem",
   "Membership.mem",
   "HMul.hMul",
   "Submodule.span",
   "Submodule.span_induction",
   "Eq.casesOn",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Exists.casesOn",
   "eq_self",
   "of_eq_true",
   "smul_smul",
   "HSMul.hSMul",
   "one_smul",
   "Eq.symm",
   "zero_smul",
   "Set.mem_singleton_iff._simp_1",
   "Eq.ndrec",
   "Submodule.subset_span",
   "add_smul"],
  "name": "Submodule.mem_span_singleton",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x y : M},\n  x ‚àà R ‚àô y ‚Üî ‚àÉ a, a ‚Ä¢ y = x",
  "constCategory": "Theorem"},
 {"references": ["IsometryEquiv.toEquiv", "Equiv.apply_symm_apply"],
  "name": "IsometryEquiv.apply_symm_apply",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤) (y : Œ≤),\n  h (h.symm y) = y",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.add_overlap_pf_zero._simp_1_3",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "Nat.cast_zero",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1_1"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ‚Ñï),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 ‚Üí Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Set.range_eq_singleton"],
  "name": "Set.range_const",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} [Nonempty Œπ] {c : Œ±}, (Set.range fun x ‚Ü¶ c) = {c}",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Subspace",
   "congrArg",
   "Exists.casesOn",
   "HSMul.hSMul",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "id",
   "SphericallyCompleteSpace.smul_morth_of_morth",
   "Eq.mpr",
   "SphericallyCompleteSpace.MOrth"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.MOrth.0.SphericallyCompleteSpace.smul_morth_of_morth'",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ùïú E),\n  SphericallyCompleteSpace.MOrth ùïú x F ‚Üí ‚àÄ a ‚àà ùïú ‚àô x, SphericallyCompleteSpace.MOrth ùïú a F",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Set.mem_pi._simp_1",
   "dist_pi_le_iff",
   "Eq.trans",
   "Set",
   "Set.pi",
   "Membership.mem",
   "Set.mem_univ._simp_1",
   "Metric.mem_closedBall._simp_1",
   "OfNat.ofNat",
   "congrArg",
   "Set.univ",
   "Metric.closedBall",
   "forall_const._simp_1",
   "iff_self",
   "of_eq_true",
   "congr",
   "forall_congr",
   "LE.le",
   "Dist.dist",
   "Set.ext",
   "propext"],
  "name": "closedBall_pi",
  "constType":
  "‚àÄ {Œ≤ : Type u_2} {X : Œ≤ ‚Üí Type u_3} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (X b)] (x : (b : Œ≤) ‚Üí X b)\n  {r : ‚Ñù}, 0 ‚â§ r ‚Üí Metric.closedBall x r = Set.univ.pi fun b ‚Ü¶ Metric.closedBall (x b) r",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq.casesOn",
  "constType":
  "{Œ± : Sort u} ‚Üí\n  {a : Œ±} ‚Üí\n    {motive : {Œ≤ : Sort u} ‚Üí (a_1 : Œ≤) ‚Üí a ‚âç a_1 ‚Üí Sort u_1} ‚Üí\n      {Œ≤ : Sort u} ‚Üí {a_1 : Œ≤} ‚Üí (t : a ‚âç a_1) ‚Üí motive a ‚ãØ ‚Üí motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "add_assoc",
   "congr",
   "HSub.hSub",
   "neg_neg",
   "neg_add_rev",
   "congrArg"],
  "name": "sub_sub_eq_add_sub",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionMonoid Œ±] (a b c : Œ±), a - (b - c) = a + c - b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "congrArg",
   "Submodule.add_mem_sup",
   "Prod.fst",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "Subtype.prop",
   "of_eq_true",
   "SMulMemClass.smul_mem",
   "HSMul.hSMul",
   "id",
   "smul_add",
   "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_7",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (m : ùïú) (a : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F),\n  ‚ü®m ‚Ä¢ ‚Üëa.1 + m ‚Ä¢ ‚Üëa.2, ‚ãØ‚ü© = ‚ü®m ‚Ä¢ (‚Üëa.1 + ‚Üëa.2), ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "add_neg_cancel",
   "OfNat.ofNat",
   "congrArg"],
  "name": "sub_self",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Norm.norm",
  "constType": "{E : Type u_8} ‚Üí [self : Norm E] ‚Üí E ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "OfNat.ofNat"],
  "name": "Nat.recAux",
  "constType":
  "{motive : ‚Ñï ‚Üí Sort u} ‚Üí motive 0 ‚Üí ((n : ‚Ñï) ‚Üí motive n ‚Üí motive (n + 1)) ‚Üí (t : ‚Ñï) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.symm"],
  "name": "forall_eq",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÄ (a : Œ±), a = a' ‚Üí p a) ‚Üî p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "sup_le_iff", "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_7",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b c : Œ±}, (a ‚äî b ‚â§ c) = (a ‚â§ c ‚àß b ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Trans.trans",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "add_left_cancel_iff",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "add_eq_left",
  "constType":
  "‚àÄ {M : Type u_4} [inst : AddMonoid M] [IsLeftCancelAdd M] {a b : M}, a + b = a ‚Üî b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hT",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] {D : Submodule ùïú E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ùïú F]\n  [inst_7 : SphericallyCompleteSpace F] {S : ‚Ü•D ‚ÜíL[ùïú] F} {ùí∞ : Set (E ‚ÜíL[ùïú] F)} {hùí∞ : ùí∞.Nonempty} {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù}\n  (self : SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ) (x : ‚Ü•D),\n  (SphericallyCompleteSpace.PartialExtension.T‚úù self) ‚ü®‚Üëx, ‚ãØ‚ü© = S x",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding_isImmediate",
   "PreLp",
   "HasQuotient.Quotient",
   "lp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.SphericalCompletion",
   "ENNReal",
   "RingHom.id",
   "Top.top",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_universal_property",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [IsUltrametricDist F] [SphericallyCompleteSpace F] (f : E ‚Üí‚Çó·µ¢[ùïú] F),\n  ‚àÉ T, T.comp (SphericallyCompleteSpace.SphericalCompletionEmbedding ùïú E) = f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_1",
  "constType":
  "‚àÄ {F : Type u_1} [inst : SeminormedAddCommGroup F] [iud : IsUltrametricDist F], IsTopologicalAddGroup F",
  "constCategory": "Theorem"},
 {"references": ["Set", "LE.le", "Membership.mem", "setOf"],
  "name": "lowerBounds",
  "constType": "{Œ± : Type u_1} ‚Üí [LE Œ±] ‚Üí Set Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["Set", "funext", "Membership.mem", "propext"],
  "name": "Set.ext",
  "constType":
  "‚àÄ {Œ± : Type u} {a b : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà a ‚Üî x ‚àà b) ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "setOf",
  "constType": "{Œ± : Type u} ‚Üí (Œ± ‚Üí Prop) ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SphericallyCompleteSpace.Orth",
   "SphericallyCompleteSpace.MOrth",
   "propext",
   "Subspace",
   "SphericallyCompleteSpace.morth_iff_forall_orth"],
  "name": "SphericallyCompleteSpace.sorth_iff_forall_orth._simp_1_2",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E) (F : Subspace ùïú E),\n  SphericallyCompleteSpace.MOrth ùïú x F = ‚àÄ y ‚àà F, x ‚üÇ[ùïú] y",
  "constCategory": "Theorem"},
 {"references": ["le_rfl", "LE.le", "sup_le_sup"],
  "name": "sup_le_sup_right",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, a ‚â§ b ‚Üí ‚àÄ (c : Œ±), a ‚äî c ‚â§ b ‚äî c",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono", "Nat.strictMono_cast", "Nat.cast", "StrictMono.lt_iff_lt"],
  "name": "Nat.cast_lt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] [CharZero Œ±]\n  {m n : ‚Ñï}, ‚Üëm < ‚Üën ‚Üî m < n",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Ne"],
  "name": "Ne.symm",
  "constType": "‚àÄ {Œ± : Sort u} {a b : Œ±}, a ‚â† b ‚Üí b ‚â† a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "HMul.hMul",
   "Filter.Eventually.of_forall",
   "Set.mem_smul_set_iff_inv_smul_mem‚ÇÄ",
   "IsCompact.smul",
   "False.elim",
   "iff_self",
   "eq_of_heq",
   "Eq.symm",
   "Filter.Tendsto.atTop_mul_const",
   "Eq.ndrec",
   "norm_zero",
   "Filter.Tendsto",
   "Metric.exists_isCompact_closedBall",
   "ProperSpace.of_seq_closedBall",
   "pow_ne_zero",
   "Norm.norm",
   "Exists.casesOn",
   "Filter.atTop",
   "IsCompact",
   "norm_pos_iff",
   "eq_false",
   "Iff.mpr",
   "HSMul.hSMul",
   "Set.ext",
   "Eq.mpr",
   "inv_mul_le_iff‚ÇÄ",
   "Eq.mp",
   "congrArg",
   "norm_mul",
   "LE.le.not_gt",
   "congr",
   "norm_pow",
   "Dist.dist",
   "Set.smulSet",
   "propext",
   "Inv.inv",
   "Set",
   "zero_le_one",
   "NormedField.exists_one_lt_norm",
   "HPow.hPow",
   "dist_zero_right",
   "Eq.casesOn",
   "OfNat.ofNat",
   "LT.lt",
   "Metric.closedBall",
   "of_eq_true",
   "tendsto_pow_atTop_atTop_of_one_lt",
   "LE.le",
   "_private.Mathlib.Analysis.Normed.Field.ProperSpace.0.ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace._simp_1_1",
   "Ne",
   "norm_inv",
   "And.casesOn"],
  "name": "ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] [WeaklyLocallyCompactSpace ùïú], ProperSpace ùïú",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "Lean.Syntax.node1",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "SphericallyCompleteSpace.¬´_aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___macroRules_SphericallyCompleteSpace_term_‚üÇ‚Çõ__1¬ª",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["NNReal", "NNReal.coe_eq_zero", "NNReal.toReal", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_25",
  "constType": "‚àÄ {r : NNReal}, (‚Üër = 0) = (r = 0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{Œ± : Type u} ‚Üí [self : EmptyCollection Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "AddSubmonoid.mem_mk",
   "propext",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
  "constType":
  "‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubsemigroup M} {x : M} (h_zero : 0 ‚àà s.carrier),\n  (x ‚àà { toAddSubsemigroup := s, zero_mem' := h_zero }) = (x ‚àà s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subspace",
  "constType":
  "(R : Type u) ‚Üí (M : Type v) ‚Üí [inst : DivisionRing R] ‚Üí [inst_1 : AddCommGroup M] ‚Üí [_root_.Module R M] ‚Üí Type v",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Nat.cast",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "add_add_add_comm",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.IsNat.out",
   "id",
   "Eq.mpr",
   "Eq.ndrec",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ c : R},\n  Mathlib.Meta.NormNum.IsNat (a‚ÇÅ + b‚ÇÅ) 0 ‚Üí a‚ÇÇ + b‚ÇÇ = c ‚Üí a‚ÇÅ + a‚ÇÇ + (b‚ÇÅ + b‚ÇÇ) = c",
  "constCategory": "Theorem"},
 {"references":
  ["dist_eq_norm", "Norm.norm", "Dist.dist", "HSub.hSub", "Eq.symm"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_23",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), ‚Äña - b‚Äñ = dist a b",
  "constCategory": "Theorem"},
 {"references": ["ne_of_gt"],
  "name": "LT.lt.ne'",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, b < a ‚Üí a ‚â† b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "le_refl",
   "AddRightMono",
   "LE.le",
   "le_imp_le_of_le_of_le",
   "add_le_add_left",
   "add_le_add_right"],
  "name": "add_le_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±] [AddLeftMono Œ±] [AddRightMono Œ±] {a b c d : Œ±},\n  a ‚â§ b ‚Üí c ‚â§ d ‚Üí a + c ‚â§ b + d",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le", "OfNat.ofNat", "MulPosMono.mul_le_mul_of_nonneg_right"],
  "name": "mul_le_mul_of_nonneg_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] {a b c : Œ±} [MulPosMono Œ±],\n  b ‚â§ c ‚Üí 0 ‚â§ a ‚Üí b * a ‚â§ c * a",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_5",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references": ["HasDistribNeg.neg_mul"],
  "name": "neg_mul",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : HasDistribNeg Œ±] (a b : Œ±), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_17",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsLinearMap.map_add",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} {M‚ÇÇ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M‚ÇÇ] {f : M ‚Üí M‚ÇÇ},\n  IsLinearMap R f ‚Üí ‚àÄ (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "mul_add",
   "HMul.hMul",
   "add_zero",
   "Eq.ndrec",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a b‚ÇÅ b‚ÇÇ c‚ÇÅ c‚ÇÇ d : R},\n  a * b‚ÇÅ = c‚ÇÅ ‚Üí a * b‚ÇÇ = c‚ÇÇ ‚Üí c‚ÇÅ + 0 + c‚ÇÇ = d ‚Üí a * (b‚ÇÅ + b‚ÇÇ) = d",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_7",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references": ["Metric.closedBall", "NNReal", "NNReal.toReal", "Metric.diam"],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.casesOn",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    {motive : SphericallyCompleteSpace.IsSphericallyDense Œ± ‚Üí Sort u} ‚Üí\n      (t : SphericallyCompleteSpace.IsSphericallyDense Œ±) ‚Üí\n        ((spherically_dense : ‚àÄ (c : Œ±) (r : NNReal), Metric.diam (Metric.closedBall c ‚Üër) = ‚Üër) ‚Üí motive ‚ãØ) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "Membership.mem",
   "id",
   "HSub.hSub",
   "AddMemClass.add_mem",
   "Eq.mpr",
   "NegMemClass.neg_mem",
   "congrArg"],
  "name": "sub_mem",
  "constType":
  "‚àÄ {M : Type u_3} {S : Type u_4} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [hSM : AddSubgroupClass S M] {H : S}\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x - y ‚àà H",
  "constCategory": "Theorem"},
 {"references": ["inferInstance"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpaceComplex",
  "constType": "SphericallyCompleteSpace ‚ÑÇ",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_cancel",
   "HAdd.hAdd",
   "eq_neg_of_add_eq_zero_left",
   "Neg.neg",
   "HSMul.hSMul",
   "Eq.symm",
   "id",
   "zero_smul",
   "Eq.mpr",
   "add_smul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "neg_smul",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] (r : R) (x : M),\n  -r ‚Ä¢ x = -(r ‚Ä¢ x)",
  "constCategory": "Theorem"},
 {"references": ["exists_imp"],
  "name": "not_exists",
  "constType": "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop}, (¬¨‚àÉ x, p x) ‚Üî ‚àÄ (x : Œ±), ¬¨p x",
  "constCategory": "Theorem"},
 {"references": ["PseudoMetricSpace.dist_comm"],
  "name": "dist_comm",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x y : Œ±), dist x y = dist y x",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "Eq.symm", "neg_neg"],
  "name": "neg_eq_iff_eq_neg",
  "constType":
  "‚àÄ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = b ‚Üî a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.sorth_of_sorth",
   "SphericallyCompleteSpace.SOrth",
   "Subspace"],
  "name": "SphericallyCompleteSpace.sorth_symm",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F1 F2 : Subspace ùïú E},\n  SphericallyCompleteSpace.SOrth ùïú F1 F2 ‚Üî SphericallyCompleteSpace.SOrth ùïú F2 F1",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_3",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["LinearEquiv.toEquiv",
   "LinearIsometryEquiv.toLinearEquiv",
   "LinearIsometryEquiv.isometry"],
  "name": "LinearIsometryEquiv.toIsometryEquiv",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : _root_.Module R E] ‚Üí [inst_7 : _root_.Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚âÉ·µ¢ E‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_5",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "Classical.propDecidable",
   "LinearIsometry.norm_map",
   "HMul.hMul",
   "sub_zero",
   "Subtype.val",
   "False.elim",
   "RingHom.id",
   "HSub.hSub",
   "Eq.symm",
   "Classical.not_not._simp_3",
   "norm_eq_of_norm_sub_lt_left",
   "norm_zero",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "rfl",
   "LinearIsometry.toContinuousLinearMap",
   "Norm.norm",
   "And.right",
   "lt_of_le_of_lt",
   "LinearIsometry.norm_toContinuousLinearMap",
   "LinearIsometry.comp",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_4",
   "Bot.bot",
   "Exists.casesOn",
   "SphericallyCompleteSpace.IsImmediate",
   "SetLike.coe",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "eq_false",
   "Iff.mpr",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv",
   "id",
   "Eq.mpr",
   "one_mul",
   "dist_eq_norm",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_3",
   "Submodule.nonempty",
   "Classical.not_not",
   "Eq.mp",
   "LinearMap.range",
   "lt_of_le_of_ne",
   "DFunLike.coe",
   "map_sub",
   "ContinuousLinearMap.comp",
   "Subspace",
   "congrArg",
   "norm_sub_rev",
   "ZeroMemClass.zero_mem",
   "congr",
   "Dist.dist",
   "Metric.infDist",
   "map_zero",
   "Metric.infDist_le_dist_of_mem",
   "propext",
   "le_refl._simp_1",
   "Not",
   "ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap.le_opNorm",
   "Set",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate._simp_1_1",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "zero_le_one",
   "dist_zero_right",
   "OfNat.ofNat",
   "LT.lt",
   "eq_self",
   "Metric.infDist_lt_iff",
   "of_eq_true",
   "LE.le",
   "and_false",
   "Ne",
   "ContinuousLinearMap.opNorm_le_iff",
   "eq_of_le_of_ge",
   "Submodule.nontrivial_iff_ne_bot",
   "dite"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [inst_6 : IsUltrametricDist F] {H : Type u_4} [inst_7 : NormedAddCommGroup H]\n  [inst_8 : NormedSpace ùïú H] [IsUltrametricDist H] [SphericallyCompleteSpace H] (f : E ‚Üí‚Çó·µ¢[ùïú] F),\n  SphericallyCompleteSpace.IsImmediate f ‚Üí\n    ‚àÄ (g : E ‚Üí‚Çó·µ¢[ùïú] H) (h : F ‚ÜíL[ùïú] H),\n      ‚Äñh‚Äñ = ‚Äñg.toContinuousLinearMap.comp (SphericallyCompleteSpace.LinearIsometry.weakInv‚úù f).toContinuousLinearMap‚Äñ ‚Üí\n        (‚àÄ (v : F) (x : E) (h_1 : f x = v), h v = g ((SphericallyCompleteSpace.LinearIsometry.weakInv‚úù¬π f) ‚ü®v, ‚ãØ‚ü©)) ‚Üí\n          ‚àÄ (v : F), ‚Äñ‚Üëh v‚Äñ = ‚Äñv‚Äñ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Surjective",
  "constType": "{Œ± : Sort u_1} ‚Üí {Œ≤ : Sort u_2} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Not", "LT.lt", "lt_iff_le_not_ge", "LE.le", "And.right", "Iff.mp"],
  "name": "not_le_of_gt",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Max.max",
  "constType": "{Œ± : Type u} ‚Üí [self : Max Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.cast", "Iff.mpr", "Int.ofNat_lt"],
  "name": "Lean.Omega.Int.ofNat_lt_of_lt",
  "constType": "‚àÄ {x y : ‚Ñï}, x < y ‚Üí ‚Üëx < ‚Üëy",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "mul_one",
   "List.prod",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
  "constType":
  "‚àÄ {M : Type u_1} [inst : GroupWithZero M] (x : M), x = Mathlib.Tactic.FieldSimp.NF.eval [(1, x)]",
  "constCategory": "Theorem"},
 {"references": ["congrArg‚ÇÇ"],
  "name": "congr_arg‚ÇÇ",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) {x x' : Œ±} {y y' : Œ≤}, x = x' ‚Üí y = y' ‚Üí f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{Œ± : Sort u} ‚Üí [i : Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pure.pure",
  "constType":
  "{f : Type u ‚Üí Type v} ‚Üí [self : Pure f] ‚Üí {Œ± : Type u} ‚Üí Œ± ‚Üí f Œ±",
  "constCategory": "Definition"},
 {"references":
  ["dist_nonneg",
   "Norm.norm",
   "Dist.dist",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dist_zero_right",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_nonneg",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), 0 ‚â§ ‚Äña‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Commute.right_comm",
   "Nat.cast",
   "Invertible.invOf",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNNRat.casesOn",
   "Eq.mp",
   "HMul.hMul",
   "congrArg",
   "congr",
   "Eq.symm",
   "Nat.cast_mul",
   "Eq.ndrec",
   "mul_invOf_cancel_right'",
   "Nat.mul",
   "Nat.cast_commute",
   "Commute.invOf_right",
   "congr_arg",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNNRat_mul._simp_1_1",
   "Commute.invOf_left",
   "invertibleMul",
   "eq_self",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.invertibleOfMul'"],
  "name": "Mathlib.Meta.NormNum.isNNRat_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {f : Œ± ‚Üí Œ± ‚Üí Œ±} {a b : Œ±} {na nb nc da db dc k : ‚Ñï},\n  f = HMul.hMul ‚Üí\n    Mathlib.Meta.NormNum.IsNNRat a na da ‚Üí\n      Mathlib.Meta.NormNum.IsNNRat b nb db ‚Üí\n        na.mul nb = k.mul nc ‚Üí da.mul db = k.mul dc ‚Üí Mathlib.Meta.NormNum.IsNNRat (f a b) nc dc",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "LinearMap.ker",
   "Norm.norm",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthProj",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Exists.choose",
   "SphericallyCompleteSpace.OrthComp._proof_2",
   "Subtype.val",
   "DFunLike.coe",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "OfNat.ofNat",
   "RingHom.id",
   "LE.le",
   "id"],
  "name": "SphericallyCompleteSpace.orthcomp_eq_ker_OrthProj",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  SphericallyCompleteSpace.OrthComp ùïú F = LinearMap.ker (SphericallyCompleteSpace.OrthProj ùïú F)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1_1",
   "Nat.rawCast"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "‚àÄ {Œ± : Type u} {a : Œ±} {n : ‚Ñï} [inst : AddMonoidWithOne Œ±], Mathlib.Meta.NormNum.IsNat a n ‚Üí a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "AddLeftReflectLT",
   "AddLeftStrictMono",
   "lt_add_iff_pos_right",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : LT Œ±] [AddLeftStrictMono Œ±] [AddLeftReflectLT Œ±] (a : Œ±) {b : Œ±},\n  (a < a + b) = (0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval.match_1",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "List.map",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "HPow.hPow",
   "List.prod",
   "Mathlib.Tactic.FieldSimp.zpow'_of_ne_zero_left",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "mul_pos",
   "congrArg",
   "LT.lt",
   "LT.lt.ne'",
   "zpow_pos",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons_pos",
  "constType":
  "‚àÄ {M : Type u_1} [inst : GroupWithZero M] [inst_1 : PartialOrder M] [PosMulStrictMono M] [PosMulReflectLT M]\n  [ZeroLEOneClass M] (r : ‚Ñ§) {x : M},\n  0 < x ‚Üí ‚àÄ {l : Mathlib.Tactic.FieldSimp.NF M}, 0 < l.eval ‚Üí 0 < ((r, x) ::·µ£ l).eval",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl", "Norm.norm", "LE.le", "ContinuousLinearMap.le_of_opNorm_le_of_le"],
  "name": "ContinuousLinearMap.le_of_opNorm_le",
  "constType":
  "‚àÄ {ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ùïú] [inst_3 : NontriviallyNormedField ùïú‚ÇÇ]\n  [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [RingHomIsometric œÉ‚ÇÅ‚ÇÇ] (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)\n  {c : ‚Ñù}, ‚Äñf‚Äñ ‚â§ c ‚Üí ‚àÄ (x : E), ‚Äñf x‚Äñ ‚â§ c * ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["IsTrichotomous.trichotomous"],
  "name": "trichotomous",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [IsTrichotomous Œ± r] (a b : Œ±), r a b ‚à® a = b ‚à® r b a",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Bot.bot"],
  "name": "Disjoint",
  "constType":
  "{Œ± : Type u_1} ‚Üí [inst : PartialOrder Œ±] ‚Üí [OrderBot Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_9",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Quot.sound", "id", "Quot.liftOn", "congrArg"],
  "name": "funext",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {f g : (x : Œ±) ‚Üí Œ≤ x}, (‚àÄ (x : Œ±), f x = g x) ‚Üí f = g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.mk",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±],\n  (‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n      (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty) ‚Üí\n    SphericallyCompleteSpace Œ±",
  "constCategory": "Other"},
 {"references":
  ["Int.add_assoc",
   "Eq.trans",
   "Lean.Omega.Coeffs",
   "congrArg",
   "HAdd.hAdd",
   "congr",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Eq.mpr",
   "Lean.Omega.LinearCombo.casesOn",
   "Int.add_left_comm",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.add_eval",
  "constType":
  "‚àÄ (l‚ÇÅ l‚ÇÇ : Omega.LinearCombo) (v : Omega.Coeffs), (l‚ÇÅ + l‚ÇÇ).eval v = l‚ÇÅ.eval v + l‚ÇÇ.eval v",
  "constCategory": "Theorem"},
 {"references": ["Set", "top_disjoint"],
  "name": "Set.univ_disjoint",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Disjoint Set.univ s ‚Üî s = ‚àÖ",
  "constCategory": "Theorem"},
 {"references": ["inferInstance", "Padic", "Nat.Prime"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpacePadic",
  "constType":
  "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], SphericallyCompleteSpace ‚Ñö_[p]",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_3",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_4",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ}, (x ‚àà LinearMap.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "And.right",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "HAdd.hAdd",
   "HSMul.hSMul",
   "Submodule.mem_span_singleton",
   "And.left"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (M : ‚Ü•(D + ùïú ‚àô a)) (this : ‚àÉ y ‚àà D, ‚àÉ z ‚àà ùïú ‚àô a, y + z = ‚ÜëM),\n  ‚àÉ a_1, a_1 ‚Ä¢ a = ‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name": "Set.mem_range._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort u_1} {f : Œπ ‚Üí Œ±} {x : Œ±}, (x ‚àà Set.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_10",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) = ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": ["not_le", "LT.lt", "Not", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, (¬¨a ‚â§ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": ["Left.add_pos"],
  "name": "add_pos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±] [AddLeftStrictMono Œ±] {a b : Œ±},\n  0 < a ‚Üí 0 < b ‚Üí 0 < a + b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubgroupClass.toAddGroup._proof_1",
  "constType":
  "‚àÄ {G : Type u_2} [inst : AddGroup G] {S : Type u_1} [inst_1 : SetLike S G] [AddSubgroupClass S G], AddSubmonoidClass S G",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_7",
  "constType": "‚àÄ {a b c : Prop}, (a ‚àß b ‚Üí c) = (a ‚Üí b ‚Üí c)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast_nonneg"],
  "name": "Mathlib.Tactic.Linarith.natCast_nonneg",
  "constType":
  "‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] (n : ‚Ñï), 0 ‚â§ ‚Üën",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_2",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ}, (x ‚àà LinearMap.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Unit"],
  "name": "cond",
  "constType": "{Œ± : Sort u} ‚Üí Bool ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Eq.mp", "HMul.hMul", "one_mul", "OfNat.ofNat", "congrArg"],
  "name": "Mathlib.Tactic.Linarith.without_one_mul",
  "constType":
  "‚àÄ {M : Type u_1} [inst : MulOneClass M] {a b : M}, 1 * a = b ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references": ["Set.Nonempty", "upperBounds", "Set"],
  "name": "BddAbove",
  "constType": "{Œ± : Type u_1} ‚Üí [LE Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Exists.choose_spec",
   "Set",
   "Membership.mem",
   "NNReal",
   "And.right",
   "NNReal.toReal",
   "Exists.choose",
   "Subtype.val",
   "Set.Elem",
   "Set.Countable",
   "OfNat.ofNat",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball",
   "Prod.fst",
   "Dense",
   "HAdd.hAdd",
   "Metric.closedBall",
   "lt_add_one",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_sub_closedball_not_belong",
   "HasSubset.Subset",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_strictanti",
   "Denumerable.ofNat",
   "TopologicalSpace.SeparableSpace.exists_countable_dense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.not_in_fuck_chain_of_ball",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [hiud : IsUltrametricDist Œ±]\n  [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] [nemp : Nonempty Œ±] [hsep : TopologicalSpace.SeparableSpace Œ±]\n  (hŒ±' : Denumerable ‚Üë‚ãØ.choose) (n : ‚Ñï),\n  ‚Üë(Denumerable.ofNat (‚Üë‚ãØ.choose) n) ‚àâ\n    Metric.closedBall (SphericallyCompleteSpace.fuck_chain_of_ball‚úù hŒ±' (n + 1)).1\n      ‚Üë(SphericallyCompleteSpace.fuck_chain_of_ball‚úù¬π hŒ±' (n + 1)).2",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.PropLemmas.0.exists_prop.match_1_3",
   "_private.Init.PropLemmas.0.exists_prop.match_1_1"],
  "name": "exists_prop",
  "constType": "‚àÄ {b a : Prop}, (‚àÉ (_ : a), b) ‚Üî a ‚àß b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "absurd", "Not", "_private.Init.Core.0.if_neg.match_1_1", "ite"],
  "name": "if_neg",
  "constType":
  "‚àÄ {c : Prop} {h : Decidable c}, ¬¨c ‚Üí ‚àÄ {Œ± : Sort u} {t e : Œ±}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Iff.mpr",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí b ‚Üí a",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne.natCast_zero"],
  "name": "Nat.cast_zero",
  "constType": "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R], ‚Üë0 = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSMul.hSMul",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HSMul Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_4",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "‚àÄ (Œ± : Type u) [inst : AddMonoidWithOne Œ±] {a : Œ±} {n : ‚Ñï}, ‚Üën = a ‚Üí Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "Maximal",
   "Set",
   "RingHom.id",
   "Membership.mem",
   "inferInstance",
   "Exists.choose"],
  "name": "SphericallyCompleteSpace.instNormedAddCommGroupSphericalCompletion",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u_2) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [inst_3 : IsUltrametricDist E] ‚Üí\n            (E‚ÇÄ : Type u_3) ‚Üí\n              [inst_4 : NormedAddCommGroup E‚ÇÄ] ‚Üí\n                [inst_5 : NormedSpace ùïú E‚ÇÄ] ‚Üí\n                  [inst_6 : IsUltrametricDist E‚ÇÄ] ‚Üí\n                    [inst_7 : SphericallyCompleteSpace E‚ÇÄ] ‚Üí (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) ‚Üí NormedAddCommGroup ‚Ü•‚ãØ.choose",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "add_eq_left", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_1",
  "constType":
  "‚àÄ {M : Type u_4} [inst : AddMonoid M] [IsLeftCancelAdd M] {a b : M}, (a + b = a) = (b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe", "Set", "Membership.mem", "OfNat.ofNat", "Submodule.zero_mem"],
  "name": "Submodule.nonempty",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M), (‚Üëp).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_3",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ‚àà p), (‚ü®x, h‚ü© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) = ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "id", "Eq.mpr", "congrArg"],
  "name": "Mathlib.Tactic.Abel.subst_into_addg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (l r tl tr t : Œ±), l = tl ‚Üí r = tr ‚Üí tl + tr = t ‚Üí l + r = t",
  "constCategory": "Theorem"},
 {"references": ["IsometryEquiv.isometry_toFun"],
  "name": "IsometryEquiv.isometry",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤), Isometry ‚áëh",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "lt_self_iff_false", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_16",
  "constType": "‚àÄ {Œ± : Type u_2} [inst : Preorder Œ±] (x : Œ±), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "closure"],
  "name": "Dense",
  "constType": "{X : Type u} ‚Üí [TopologicalSpace X] ‚Üí Set X ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Max.max", "LE.le", "sup_le_iff", "propext"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b c : Œ±}, (a ‚äî b ‚â§ c) = (a ‚â§ c ‚àß b ‚â§ c)",
  "constCategory": "Theorem"},
 {"references": ["propext", "exists_eq_right"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_2",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÉ a, p a ‚àß a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (i : ‚Ñï), IsBoundedSMul ùïú E",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Classical.propDecidable",
   "lt_of_le_of_ne",
   "GE.ge",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "strictMono_nat_of_lt_succ",
   "strictAnti_nat_of_succ_lt",
   "False.elim",
   "congr",
   "forall_congr",
   "funext",
   "Eq.symm",
   "not_true_eq_false",
   "Eq.ndrec",
   "eventually_stable_or_exists_strictanti_of_antitone._simp_1_4",
   "And.left",
   "Not",
   "eventually_stable_or_exists_strictanti_of_antitone._simp_1_5",
   "_private.SphericalCompleteness.External.Sequence.0.esoesoa._proof_2",
   "binderNameHint",
   "_private.SphericalCompleteness.External.Sequence.0.esoesoa",
   "Classical.not_imp._simp_2",
   "Exists.choose_spec",
   "And.right",
   "Function.comp",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "StrictAnti",
   "Antitone",
   "LE.le",
   "id",
   "and_false",
   "Ne",
   "dite",
   "Exists.choose.congr_simp",
   "StrictMono",
   "Mathlib.Tactic.Push.not_forall_eq"],
  "name": "eventually_stable_or_exists_strictanti_of_antitone",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {f : ‚Ñï ‚Üí Œ±},\n  Antitone f ‚Üí (‚àÉ N, ‚àÄ n ‚â• N, f n = f N) ‚à® ‚àÉ œÜ, StrictMono œÜ ‚àß StrictAnti (f ‚àò œÜ)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_4",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, (x ‚â• y) = (y ‚â§ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul",
   "Int.cast_mul",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isInt_mul.match_1_1",
   "Eq.symm",
   "HMul.hMul",
   "Int.cast"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {f : Œ± ‚Üí Œ± ‚Üí Œ±} {a b : Œ±} {a' b' c : ‚Ñ§},\n  f = HMul.hMul ‚Üí\n    Mathlib.Meta.NormNum.IsInt a a' ‚Üí\n      Mathlib.Meta.NormNum.IsInt b b' ‚Üí a'.mul b' = c ‚Üí Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth",
   "SphericallyCompleteSpace.orth_symm",
   "Eq.mp",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.Orth",
   "propext",
   "congrArg"],
  "name": "SphericallyCompleteSpace.orth_smul_of_orth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x y : E} (a : ùïú), (x ‚üÇ[ùïú] y) ‚Üí x ‚üÇ[ùïú] a ‚Ä¢ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bind.bind",
  "constType":
  "{m : Type u ‚Üí Type v} ‚Üí [self : Bind m] ‚Üí {Œ± Œ≤ : Type u} ‚Üí m Œ± ‚Üí (Œ± ‚Üí m Œ≤) ‚Üí m Œ≤",
  "constCategory": "Definition"},
 {"references": ["Set", "Singleton.singleton", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_singleton_iff",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, a ‚àà {b} ‚Üî a = b",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÄ (a : Œ±), a = a' ‚Üí p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast", "LE.le", "propext", "Mathlib.Tactic.Zify.natCast_le"],
  "name": "Mathlib.Tactic.Zify.natCast_le._simp_1",
  "constType": "‚àÄ (a b : ‚Ñï), (a ‚â§ b) = (‚Üëa ‚â§ ‚Üëb)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.subsingleton_singleton",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq.symm",
   "Set.Subsingleton.eq_singleton_of_mem",
   "Set.Subsingleton"],
  "name": "Set.subsingleton_iff_singleton",
  "constType":
  "‚àÄ {Œ± : Type u} {s : Set Œ±} {x : Œ±}, x ‚àà s ‚Üí (s.Subsingleton ‚Üî s = {x})",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.casesOn",
  "constType":
  "{Œ± : Sort u_1} ‚Üí\n  {a : Œ±} ‚Üí {motive : (a_1 : Œ±) ‚Üí a = a_1 ‚Üí Sort u} ‚Üí {a_1 : Œ±} ‚Üí (t : a = a_1) ‚Üí motive a ‚ãØ ‚Üí motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_right_neg",
   "Int.add_le_add_right",
   "HAdd.hAdd",
   "Eq.mp",
   "Neg.neg",
   "LE.le",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.sub_nonneg_of_le",
  "constType": "‚àÄ {a b : ‚Ñ§}, b ‚â§ a ‚Üí 0 ‚â§ a - b",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd"],
  "name": "Int.ofNat_nonneg",
  "constType": "‚àÄ (n : ‚Ñï), 0 ‚â§ ‚Üën",
  "constCategory": "Theorem"},
 {"references": ["ite", "Classical.propDecidable", "HPow.hPow", "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.zpow'",
  "constType": "{Œ± : Type u_1} ‚Üí [GroupWithZero Œ±] ‚Üí Œ± ‚Üí ‚Ñ§ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, (x ‚â• y) = (y ‚â§ x)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_3",
   "Eq.trans",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension._simp_1_9",
   "Membership.mem",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
   "Iff.mp",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.T",
   "HMul.hMul",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_4",
   "Subtype.val",
   "Set.Elem",
   "iSup",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
   "RingHom.id",
   "forall_congr",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "Submodule.mem_iSup_of_directed",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hDM",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_1",
   "Set.Nonempty.to_subtype",
   "Norm.norm",
   "Exists.choose_spec",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "Set.Nonempty.some_mem",
   "Set.Nonempty.some",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.glued_map._proof_2",
   "Submodule.mem_iSup",
   "Exists.casesOn",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hT",
   "Iff.of_eq",
   "upperBounds",
   "Iff.mpr",
   "id",
   "Eq.mpr",
   "IsChain",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_7",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.isboundedlinearmap_of_glued_map",
   "le_trans",
   "IsChain.directed",
   "DFunLike.coe",
   "congrArg",
   "Subtype.prop",
   "congr",
   "Preorder.mk.congr_simp",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.directed_chain",
   "Submodule.mem_iSup_of_mem",
   "propext",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension._simp_1_5",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.glued_map",
   "Not",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_6",
   "Set.Nonempty",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension._simp_1_8",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hU",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.glued_map._proof_1",
   "And.casesOn"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.bddAbove_of_chain_of_partial_extension",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] {D : Submodule ùïú E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ùïú F]\n  [inst_7 : SphericallyCompleteSpace F] {S : ‚Ü•D ‚ÜíL[ùïú] F} {ùí∞ : Set (E ‚ÜíL[ùïú] F)} (hùí∞ : ùí∞.Nonempty) (Œµ : ‚Üëùí∞ ‚Üí ‚Ñù),\n  (‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) ‚Üí\n    ‚àÄ (P : Set (SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ)),\n      IsChain (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) P ‚Üí P.Nonempty ‚Üí BddAbove P",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú], RingHomInvPair (RingHom.id ùïú) (RingHom.id ùïú)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.neg_eval",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.sub_eq_add_neg",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.eval",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.sub_eval",
  "constType":
  "‚àÄ (l‚ÇÅ l‚ÇÇ : Omega.LinearCombo) (v : Omega.Coeffs), (l‚ÇÅ - l‚ÇÇ).eval v = l‚ÇÅ.eval v - l‚ÇÇ.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SetLike.mem_coe._simp_1",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "rfl", "Nat.cast"],
  "name": "Int.natCast_add",
  "constType": "‚àÄ (n m : ‚Ñï), ‚Üë(n + m) = ‚Üën + ‚Üëm",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_2",
   "Eq.mp",
   "Membership.mem",
   "NNReal.toReal",
   "Iff.mp",
   "SProd.sprod",
   "and_true",
   "Set.iInter",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_4",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_1",
   "Prod.fst",
   "congrArg",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_6",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "congr",
   "forall_congr",
   "funext",
   "Dist.dist",
   "Eq.symm",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_5",
   "And.left",
   "dist_self",
   "Set.Nonempty",
   "Set",
   "And.right",
   "NNReal",
   "Prod.snd",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_3",
   "true_and",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_7",
   "Set.mem_prod",
   "OfNat.ofNat",
   "Exists.casesOn",
   "closedBall_prod_same",
   "Metric.closedBall",
   "HasSubset.Subset",
   "Antitone",
   "NNDist.nndist",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace",
  "constType":
  "‚àÄ {E : Type u_1} {F : Type u_2} [inst : PseudoMetricSpace E] [inst_1 : PseudoMetricSpace F]\n  [hse : SphericallyCompleteSpace E] [hsf : SphericallyCompleteSpace F], SphericallyCompleteSpace (E √ó F)",
  "constCategory": "Theorem"},
 {"references": ["HSMul.hSMul", "AddHom.toFun", "Eq.ndrec", "DFunLike.coe"],
  "name": "LinearMap.mk.congr_simp",
  "constType":
  "‚àÄ {R : Type u_14} {S : Type u_15} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {M : Type u_16}\n  {M‚ÇÇ : Type u_17} [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M]\n  [inst_5 : _root_.Module S M‚ÇÇ] (toAddHom toAddHom_1 : M ‚Üí‚Çô+ M‚ÇÇ) (e_toAddHom : toAddHom = toAddHom_1)\n  (map_smul' : ‚àÄ (m : R) (x : M), toAddHom.toFun (m ‚Ä¢ x) = œÉ m ‚Ä¢ toAddHom.toFun x),\n  { toAddHom := toAddHom, map_smul' := map_smul' } = { toAddHom := toAddHom_1, map_smul' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.add",
   "Nat.le_succ_of_le",
   "_private.Init.Data.Nat.Basic.0.Nat.le_add_right.match_1_1",
   "Nat.below",
   "LE.le",
   "Nat.le_refl",
   "Nat.brecOn",
   "OfNat.ofNat"],
  "name": "Nat.le_add_right",
  "constType": "‚àÄ (n k : ‚Ñï), n ‚â§ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "Metric.isBounded_closedBall",
   "Membership.mem",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_3",
   "Metric.dist_le_diam_of_mem",
   "Or.resolve_right",
   "NNReal.toReal",
   "Metric.diam",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_1",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "Subtype.prop",
   "forall_congr",
   "Dist.dist",
   "Eq.symm",
   "Not",
   "binderNameHint",
   "LT.lt.not_ge",
   "Set",
   "NNReal",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_4",
   "OfNat.ofNat",
   "LT.lt",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "Metric.closedBall",
   "Set.Ioc",
   "NNDist.nndist",
   "Classical.byContradiction",
   "SphericallyCompleteSpace.IsSphericallyDense.spherically_dense",
   "LE.le",
   "id",
   "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_2",
   "Mathlib.Tactic.Push.not_and_eq",
   "Eq.mpr",
   "Metric.diam_le_of_forall_dist_le"],
  "name": "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±],\n  SphericallyCompleteSpace.IsSphericallyDense Œ± ‚Üí\n    ‚àÄ (z : Œ±) ‚¶Ér r' : NNReal‚¶Ñ,\n      r' < r ‚Üí ‚àÉ x y, x ‚àà Metric.closedBall z ‚Üër ‚àß y ‚àà Metric.closedBall z ‚Üër ‚àß nndist x y ‚àà Set.Ioc r' r",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.morth_iff_forall_orth._simp_1_2",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero.mul_inv_cancel", "Ne", "OfNat.ofNat"],
  "name": "mul_inv_cancel‚ÇÄ",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u} [inst : GroupWithZero G‚ÇÄ] {a : G‚ÇÄ}, a ‚â† 0 ‚Üí a * a‚Åª¬π = 1",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "implies_congr",
  "constType":
  "‚àÄ {p‚ÇÅ p‚ÇÇ : Sort u} {q‚ÇÅ q‚ÇÇ : Sort v}, p‚ÇÅ = p‚ÇÇ ‚Üí q‚ÇÅ = q‚ÇÇ ‚Üí (p‚ÇÅ ‚Üí q‚ÇÅ) = (p‚ÇÇ ‚Üí q‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "SetLike.ext"],
  "name": "Submodule.ext",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M}, (‚àÄ (x : M), x ‚àà p ‚Üî x ‚àà q) ‚Üí p = q",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ", "dense_iff_closure_eq", "Set", "Iff.mp", "closure", "Dense"],
  "name": "Dense.closure_eq",
  "constType":
  "‚àÄ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, Dense s ‚Üí closure s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "neg_add_cancel_right",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "congrArg"],
  "name": "sub_add_cancel",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a b : G), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_4",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "one_ne_zero._simp_1",
   "Eq.trans",
   "of_eq_true",
   "ite",
   "Classical.propDecidable",
   "and_false",
   "HPow.hPow",
   "zpow_one",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.zpow'_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : GroupWithZero Œ±] (a : Œ±), Mathlib.Tactic.FieldSimp.zpow' a 1 = a",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.imm_ext_in_sph_comp", "RingHom.id"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp.congr_simp",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (E‚ÇÄ : Type u_3) [inst_4 : NormedAddCommGroup E‚ÇÄ]\n  [inst_5 : NormedSpace ùïú E‚ÇÄ] [inst_6 : IsUltrametricDist E‚ÇÄ] [inst_7 : SphericallyCompleteSpace E‚ÇÄ]\n  (f f_1 : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ),\n  f = f_1 ‚Üí\n    ‚àÄ (a a_1 : Submodule ùïú E‚ÇÄ),\n      a = a_1 ‚Üí\n        SphericallyCompleteSpace.imm_ext_in_sph_comp E E‚ÇÄ f a =\n          SphericallyCompleteSpace.imm_ext_in_sph_comp E E‚ÇÄ f_1 a_1",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "ite", "ite_congr", "congrArg"],
  "name": "ite_cond_eq_true",
  "constType":
  "‚àÄ {Œ± : Sort u} {c : Prop} {x : Decidable c} (a b : Œ±), c = True ‚Üí (if c then a else b) = a",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "forall_apply_eq_imp_iff‚ÇÇ",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  (‚àÄ (b : Œ≤) (a : Œ±), p a ‚Üí f a = b ‚Üí q b) ‚Üî ‚àÄ (a : Œ±), p a ‚Üí q (f a)",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "propext"],
  "name": "Classical.not_not._simp_3",
  "constType": "‚àÄ {a : Prop}, (¬¨¬¨a) = a",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_5",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_15",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± √ó Œ≤ ‚Üí Prop}, (‚àÉ x, p x) = ‚àÉ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "lp.instNormedSpace._proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} {Œ± : Type u_3} {E : Œ± ‚Üí Type u_2} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] [inst_1 : NormedField ùïú]\n  [inst_2 : (i : Œ±) ‚Üí NormedSpace ùïú (E i)] (i : Œ±), IsBoundedSMul ùïú (E i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_2",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["neg_mem_iff", "Neg.neg", "Membership.mem", "neg_sub", "HSub.hSub"],
  "name": "sub_mem_comm_iff",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] {S : Type u_6} {H : S} [inst_1 : SetLike S G] [AddSubgroupClass S G] {a b : G},\n  a - b ‚àà H ‚Üî b - a ‚àà H",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_assoc",
   "congr",
   "HSMul.hSMul",
   "Eq.symm",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.term_add_constg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (n : ‚Ñ§) (x a k a' : Œ±),\n  a + k = a' ‚Üí Mathlib.Tactic.Abel.termg n x a + k = Mathlib.Tactic.Abel.termg n x a'",
  "constCategory": "Theorem"},
 {"references": ["Set.image", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_image",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), y ‚àà f '' s ‚Üî ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs.set", "OfNat.ofNat"],
  "name": "Lean.Omega.LinearCombo.coordinate",
  "constType": "‚Ñï ‚Üí Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, (¬¨a < b) = (b ‚â§ a)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_15",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_11",
   "Submodule.span",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_8",
   "Subtype.val",
   "Subspace",
   "Prod.fst",
   "RingHom.id",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_4",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_12",
   "SphericallyCompleteSpace.MOrth",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_7",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_16",
   "Set",
   "Prod.snd",
   "Exists.choose",
   "HAdd.hAdd",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_13",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_1",
   "Max.max",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_9",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_10",
   "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_2",
   "Eq.mpr"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [inst_3 : IsUltrametricDist E] ‚Üí\n            (x : E) ‚Üí (F : Subspace ùïú E) ‚Üí SphericallyCompleteSpace.MOrth ùïú x F ‚Üí ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F ‚âÉ‚Çó·µ¢[ùïú] ‚Ü•(ùïú ‚àô x + F)",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Subtype.val"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (M : ‚Ü•(D + ùïú ‚àô a)), ‚àÉ y ‚àà D, ‚àÉ z ‚àà ùïú ‚àô a, y + z = ‚ÜëM",
  "constCategory": "Theorem"},
 {"references": ["Set.Ici", "iInf", "Filter.principal"],
  "name": "Filter.atTop",
  "constType": "{Œ± : Type u_3} ‚Üí [Preorder Œ±] ‚Üí Filter Œ±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "HAdd.hAdd"],
  "name": "AddLeftReflectLT",
  "constType": "(M : Type u_1) ‚Üí [Add M] ‚Üí [LT M] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsImmediate._proof_2",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú], RingHomSurjective (RingHom.id ùïú)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "And.left"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_10",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (z : ‚Ü•(ùïú ‚àô x ‚äî F)), ‚ãØ.choose ‚àà ùïú ‚àô x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.ext_iff", "Membership.mem", "Subtype.val", "Iff.symm"],
  "name": "SetLike.coe_eq_coe",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ‚Ü•p}, ‚Üëx = ‚Üëy ‚Üî x = y",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "Antitone",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [Preorder Œ±] ‚Üí [Preorder Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["MulAction.one_smul"],
  "name": "one_smul",
  "constType":
  "‚àÄ (M : Type u_1) {Œ± : Type u_5} [inst : Monoid M] [inst_1 : MulAction M Œ±] (b : Œ±), 1 ‚Ä¢ b = b",
  "constCategory": "Theorem"},
 {"references": ["Set.mem_singleton_iff", "OfNat.ofNat"],
  "name": "Submodule.mem_bot",
  "constType":
  "‚àÄ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  x ‚àà ‚ä• ‚Üî x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_14",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "SphericallyCompleteSpace.MOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.SOrth",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí [IsUltrametricDist E] ‚Üí Subspace ùïú E ‚Üí Subspace ùïú E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["inferInstance"],
  "name": "SphericallyCompleteSpace.instSphericallyCompleteSpaceReal",
  "constType": "SphericallyCompleteSpace ‚Ñù",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.Order.lt_le_trans",
   "max_def'",
   "Lean.Grind.em",
   "Eq.trans",
   "Lean.Grind.alreadyNorm",
   "Eq.mp",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "Lean.Grind.Order.lt_unsat",
   "ite_cond_eq_false",
   "Or.casesOn",
   "Lean.Grind.Order.le_of_eq_2",
   "Lean.Grind.Order.le_lt_trans",
   "Lean.Grind.Order.lt_of_not_le",
   "Max.max",
   "Lean.Grind.nestedDecidable",
   "LinearOrder.toDecidableLE'",
   "eq_false",
   "LE.le",
   "Classical.byContradiction",
   "Eq.symm",
   "id"],
  "name": "max_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b c : Œ±}, a ‚â§ c ‚Üí b ‚â§ c ‚Üí max a b ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "left_distrib",
   "HMul.hMul",
   "congrArg"],
  "name": "CancelDenoms.add_subst",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {n e1 e2 t1 t2 : Œ±}, n * e1 = t1 ‚Üí n * e2 = t2 ‚Üí n * (e1 + e2) = t1 + t2",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_5",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "dist_triangle",
   "dist_comm",
   "Dist.dist",
   "_private.Mathlib.Topology.MetricSpace.Pseudo.Defs.0.dist_nonneg'"],
  "name": "dist_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±}, 0 ‚â§ dist x y",
  "constCategory": "Theorem"},
 {"references": ["HasQuotient.quotient'"],
  "name": "HasQuotient.Quotient",
  "constType":
  "(A : outParam (Type u)) ‚Üí {B : Type v} ‚Üí [HasQuotient A B] ‚Üí B ‚Üí Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["_private.Mathlib.Order.Lattice.0.le_sup_iff._proof_1_1"],
  "name": "le_sup_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, a ‚â§ max b c ‚Üî a ‚â§ b ‚à® a ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "Eq.ndrec",
   "add_mul",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a‚ÇÅ a‚ÇÇ b c‚ÇÅ c‚ÇÇ d : R},\n  a‚ÇÅ * b = c‚ÇÅ ‚Üí a‚ÇÇ * b = c‚ÇÇ ‚Üí c‚ÇÅ + c‚ÇÇ = d ‚Üí (a‚ÇÅ + a‚ÇÇ) * b = d",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_6",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, (dist x y ‚â§ ‚Üëc) = (nndist x y ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.dist_le_diam_of_mem'",
   "Set",
   "Membership.mem",
   "Bornology.IsBounded",
   "Bornology.IsBounded.ediam_ne_top"],
  "name": "Metric.dist_le_diam_of_mem",
  "constType":
  "‚àÄ {Œ± : Type u} {s : Set Œ±} {x y : Œ±} [inst : PseudoMetricSpace Œ±],\n  Bornology.IsBounded s ‚Üí x ‚àà s ‚Üí y ‚àà s ‚Üí dist x y ‚â§ Metric.diam s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.OrthComp._proof_2",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E], IsScalarTower ùïú ùïú E",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "Prod.snd",
   "SProd.sprod",
   "Set.mem_prod",
   "propext",
   "Prod.fst"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {s : Set Œ±} {t : Set Œ≤} {p : Œ± √ó Œ≤}, (p ‚àà s √óÀ¢ t) = (p.1 ‚àà s ‚àß p.2 ‚àà t)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.rangeFactorization_injective",
   "LinearMap.range",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "RingHom.id",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Subtype.val_injective",
   "Set",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "Set.rangeFactorization_surjective",
   "Eq.casesOn",
   "HAdd.hAdd",
   "map_add",
   "Function.RightInverse",
   "Function.rightInverse_invFun",
   "Iff.mpr",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_3",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí‚Çó·µ¢[ùïú] F)\n  (x y : ‚Ü•(LinearMap.range f)),\n  Function.invFun (Set.rangeFactorization ‚áëf) (x + y) =\n    Function.invFun (Set.rangeFactorization ‚áëf) x + Function.invFun (Set.rangeFactorization ‚áëf) y",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "dist_comm",
   "Eq.mp",
   "congr",
   "Dist.dist",
   "HSub.hSub",
   "dist_eq_norm_sub",
   "congrArg"],
  "name": "norm_sub_rev",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), ‚Äña - b‚Äñ = ‚Äñb - a‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "eq_true",
   "ite_cond_eq_true",
   "Subtype.val",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_7",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_1",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_2",
   "iSup",
   "Eq.symm",
   "Eq.ndrec",
   "norm_zero",
   "mem_lowerBounds",
   "rfl",
   "Norm.norm",
   "Exists.choose_spec",
   "Set.Nonempty.some_mem",
   "Set.mem_image",
   "add_neg_cancel",
   "Nat.not_lt",
   "SetLike.coe",
   "eq_false",
   "lowerBounds",
   "Top.top",
   "norm_neg",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "exists_apply_eq_apply._simp_1",
   "setOf",
   "HasQuotient.Quotient",
   "AddSubsemigroup.carrier",
   "InfSet.sInf",
   "propext",
   "lp.norm_eq_ciSup",
   "Set",
   "ite",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_8",
   "mem‚Ñìp_infty_iff",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "ENNReal",
   "norm_nonneg",
   "dite",
   "if_pos",
   "mem_upperBounds",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_2",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_3",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "GT.gt",
   "GE.ge",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_4",
   "quotient_norm_mk_eq",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_1",
   "funext",
   "forall_congr",
   "AddSubmonoid.mk.congr_simp",
   "QuotientAddGroup.mk'",
   "Submodule.mk.congr_simp",
   "csInf_le",
   "Neg.neg",
   "Set.mem_range._simp_1",
   "And.right",
   "Submodule.toAddSubgroup",
   "add_zero",
   "Set.Nonempty.some",
   "BddAbove",
   "ite_cond_eq_false",
   "Exists.casesOn",
   "Set.image",
   "if_neg",
   "upperBounds",
   "Iff.mpr",
   "HSMul.hSMul",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_6",
   "id",
   "mem‚Ñìp_infty",
   "Eq.mp",
   "lp",
   "le_trans",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_4",
   "Subtype.prop",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_5",
   "Mem‚Ñìp",
   "Not",
   "ciSup_le",
   "PreLp",
   "Exists.choose",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_3",
   "AddSubsemigroup.mk.congr_simp"],
  "name": "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_2) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] [‚àÄ (i : ‚Ñï), IsUltrametricDist (E i)] (A : ‚Ü•(lp E ‚ä§)),\n  ‚àÄ C > 0,\n    ‚àÄ (N : ‚Ñï), (‚àÄ n ‚â• N, ‚Äñ‚ÜëA n‚Äñ ‚â§ C) ‚Üí ‚Äñ(QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú E).toAddSubgroup) A‚Äñ ‚â§ C",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.prop",
   "RingHom.id",
   "SetLike.coe_eq_coe",
   "SphericallyCompleteSpace.OrthProj",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.OrthProj_id",
   "DFunLike.coe",
   "Subtype.val"],
  "name": "SphericallyCompleteSpace.orthproj_idempotent",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F]\n  (x : E),\n  (SphericallyCompleteSpace.OrthProj ùïú F) ‚Üë((SphericallyCompleteSpace.OrthProj ùïú F) x) =\n    (SphericallyCompleteSpace.OrthProj ùïú F) x",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_iff_orth_of_nonzero",
   "SphericallyCompleteSpace.orth_symm",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "Ne",
   "SphericallyCompleteSpace.Orth",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "SphericallyCompleteSpace.orth_smul_iff_orth_of_nonzero",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x y : E} {a : ùïú}, a ‚â† 0 ‚Üí ((x ‚üÇ[ùïú] y) ‚Üî x ‚üÇ[ùïú] a ‚Ä¢ y)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype.property",
  "constType": "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (self : Subtype p), p ‚Üëself",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.coe_inj",
   "NNReal",
   "Eq.symm",
   "id",
   "NNReal.toReal",
   "Eq.mpr",
   "Iff.rfl",
   "NNReal.coe_zero",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "NNReal.coe_eq_zero",
  "constType": "‚àÄ {r : NNReal}, ‚Üër = 0 ‚Üî r = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_9",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT"],
  "name": "Lean.MacroM",
  "constType": "Type ‚Üí Type",
  "constCategory": "Definition"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "neg_smul",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "congr",
   "HSMul.hSMul",
   "HSub.hSub",
   "add_smul",
   "congrArg"],
  "name": "sub_smul",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] (r s : R)\n  (y : M), (r - s) ‚Ä¢ y = r ‚Ä¢ y - s ‚Ä¢ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ContinuousLinearMap.toLinearMap",
  "constType":
  "{R : Type u_1} ‚Üí\n  {S : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {M : Type u_3} ‚Üí\n            [inst_2 : TopologicalSpace M] ‚Üí\n              [inst_3 : AddCommMonoid M] ‚Üí\n                {M‚ÇÇ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : _root_.Module R M] ‚Üí [inst_7 : _root_.Module S M‚ÇÇ] ‚Üí (M ‚ÜíSL[œÉ] M‚ÇÇ) ‚Üí M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name.mkStr1",
  "constType": "String ‚Üí Name",
  "constCategory": "Definition"},
 {"references":
  ["SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Singleton.singleton",
   "Membership.mem",
   "HMul.hMul",
   "Submodule.span",
   "Subtype.val",
   "DFunLike.coe",
   "Set.Elem",
   "RingHom.id",
   "HSub.hSub",
   "Not",
   "Set.Nonempty",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Norm.norm",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "Set",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Exists.choose",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "LT.lt",
   "HAdd.hAdd",
   "Max.max",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_1",
   "LE.le",
   "HSMul.hSMul"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [iude : IsUltrametricDist E] ‚Üí\n          [inst_2 : NormedSpace ùïú E] ‚Üí\n            {D : Submodule ùïú E} ‚Üí\n              {a : E} ‚Üí\n                a ‚àâ D ‚Üí\n                  {F : Type u_3} ‚Üí\n                    [inst_3 : SeminormedAddCommGroup F] ‚Üí\n                      [iud : IsUltrametricDist F] ‚Üí\n                        [inst_4 : NormedSpace ùïú F] ‚Üí\n                          [hsc : SphericallyCompleteSpace F] ‚Üí\n                            (S : ‚Ü•D ‚ÜíL[ùïú] F) ‚Üí\n                              {ùí∞ : Set (E ‚ÜíL[ùïú] F)} ‚Üí\n                                ùí∞.Nonempty ‚Üí\n                                  {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù} ‚Üí\n                                    (‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) ‚Üí\n                                      (‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V)) ‚Üí\n                                        (‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ) ‚Üí ‚Ü•(D + ùïú ‚àô a) ‚Üí F",
  "constCategory": "Definition"},
 {"references":
  ["smul_zero",
   "Eq.trans",
   "smul_closedBall'",
   "Eq.mp",
   "HMul.hMul",
   "Filter.Eventually.of_forall",
   "congrArg",
   "IsCompact.smul",
   "False.elim",
   "LE.le.not_gt",
   "norm_pow",
   "congr",
   "Set.smulSet",
   "Filter.Tendsto.atTop_mul_const",
   "Filter.Tendsto",
   "norm_zero",
   "Metric.exists_isCompact_closedBall",
   "ProperSpace.of_seq_closedBall",
   "pow_ne_zero",
   "Norm.norm",
   "Set",
   "zero_le_one",
   "NormedField.exists_one_lt_norm",
   "HPow.hPow",
   "OfNat.ofNat",
   "LT.lt",
   "Exists.casesOn",
   "Metric.closedBall",
   "Filter.atTop",
   "IsCompact",
   "tendsto_pow_atTop_atTop_of_one_lt",
   "eq_false",
   "HSMul.hSMul",
   "Ne",
   "And.casesOn"],
  "name": "ProperSpace.of_locallyCompactSpace",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E] [NormedSpace ùïú E]\n  [LocallyCompactSpace E], ProperSpace E",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "eq_true", "SetLike.coe_mem", "Subtype.val"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_6",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ‚Ü•p), (‚Üëx ‚àà p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Membership.mem.out",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "ENNReal",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "HSMul.hSMul",
   "LE.le",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_4",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : ùïú) (x_1 : E),\n  (SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) (x ‚Ä¢ x_1) ‚àà ‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references": ["RingHom.id"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_3} [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F],\n  SemilinearMapClass (E ‚Üí‚Çó·µ¢[ùïú] F) (RingHom.id ùïú) E F",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Membership.mem.out",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "HAdd.hAdd",
   "ENNReal",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "LE.le",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_2",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  (SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) (x + x_1) ‚àà ‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references": ["Subtype.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) = ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "dist_zero_left",
   "IsUltrametricDist.dist_eq_max_of_dist_ne_dist",
   "congrArg",
   "dist_zero",
   "not_false_eq_true",
   "congrFun",
   "congr",
   "Dist.dist",
   "Eq.symm",
   "HSub.hSub",
   "Not",
   "Norm.norm",
   "Neg.neg",
   "sub_neg_eq_add",
   "dist_zero_right",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "eq_false",
   "id",
   "norm_neg",
   "Eq.mpr",
   "Ne",
   "dist_eq_norm_sub"],
  "name": "IsUltrametricDist.norm_add_eq_max_of_norm_ne_norm",
  "constType":
  "‚àÄ {S : Type u_1} [inst : SeminormedAddGroup S] [IsUltrametricDist S] {x y : S}, ‚Äñx‚Äñ ‚â† ‚Äñy‚Äñ ‚Üí ‚Äñx + y‚Äñ = max ‚Äñx‚Äñ ‚Äñy‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["Subtype.range_coe"],
  "name": "Subtype.range_coe_subtype",
  "constType":
  "‚àÄ {Œ± : Type u_1} {p : Œ± ‚Üí Prop}, Set.range Subtype.val = {x | p x}",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_1",
  "constType":
  "‚àÄ {a0 a1 : ‚Ñ§} {t : List ‚Ñ§}, (Omega.LinearCombo.coordinate 1).eval (Omega.Coeffs.ofList (a0 :: a1 :: t)) = a1",
  "constCategory": "Theorem"},
 {"references": ["setOf"],
  "name": "Set.univ",
  "constType": "{Œ± : Type u} ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["propext", "And.left"],
  "name": "and_self",
  "constType": "‚àÄ (p : Prop), (p ‚àß p) = p",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "sup_le_sup_left"],
  "name": "max_le_max_left",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b : Œ±} (c : Œ±), a ‚â§ b ‚Üí max c a ‚â§ max c b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "propext"],
  "name": "Classical.not_not._simp_1",
  "constType": "‚àÄ {a : Prop}, (¬¨¬¨a) = a",
  "constCategory": "Theorem"},
 {"references": ["dist_nonneg", "Dist.dist", "LE.le", "eq_true", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_16",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±}, (0 ‚â§ dist x y) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_exists", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_9",
  "constType": "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop}, (¬¨‚àÉ x, p x) = ‚àÄ (x : Œ±), ¬¨p x",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddSubsemigroup.mem_mk", "Set", "Membership.mem", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
  "constType":
  "‚àÄ {M : Type u_1} [inst : Add M] {s : Set M} {x : M} (h_add : ‚àÄ {a b : M}, a ‚àà s ‚Üí b ‚àà s ‚Üí a + b ‚àà s),\n  (x ‚àà { carrier := s, add_mem' := h_add }) = (x ‚àà s)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "inferInstance", "OfNat.ofNat"],
  "name": "Mathlib.Meta.NormNum.instAtLeastTwo",
  "constType": "‚àÄ (n : ‚Ñï), (n + 2).AtLeastTwo",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
   "LinearMap.range_eq_top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "LinearIsometry.isometry",
   "Eq.mp",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericalCompletion_minimal",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "LinearIsometryEquiv.symm",
   "RingHom.id",
   "Eq.symm",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Isometry.isometryEquivOnRange",
   "LinearIsometry.comp",
   "Exists.choose",
   "Function.Surjective",
   "Exists.casesOn",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "SphericallyCompleteSpace.IsImmediate",
   "LinearMap.range_comp_le_range",
   "Maximal",
   "LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective",
   "LE.le",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_unique'",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [inst_6 : IsUltrametricDist F] [SphericallyCompleteSpace F] {f : E ‚Üí‚Çó·µ¢[ùïú] F},\n  SphericallyCompleteSpace.IsImmediate f ‚Üí Nonempty (SphericallyCompleteSpace.SphericalCompletion ùïú E ‚âÉ‚Çó·µ¢[ùïú] F)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "dist_comm",
   "Eq.mp",
   "Set",
   "le_trans",
   "NNReal",
   "Inter.inter",
   "Membership.mem",
   "NNReal.toReal",
   "Subtype.val",
   "OfNat.ofNat",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric._simp_1_1",
   "congrArg",
   "Exists.casesOn",
   "Metric.closedBall",
   "Max.max",
   "IsUltrametricDist.dist_triangle_max",
   "Iff.mpr",
   "LE.le",
   "Dist.dist",
   "id",
   "Eq.mpr",
   "sup_le_iff",
   "And.casesOn"],
  "name":
  "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [hiud : IsUltrametricDist Œ±] {z1 z2 : Œ±} {r1 r2 : NNReal},\n  r1 ‚â§ r2 ‚Üí\n    (Metric.closedBall z1 ‚Üër1 ‚à© Metric.closedBall z2 ‚Üër2).Nonempty ‚Üí Metric.closedBall z1 ‚Üër1 ‚äÜ Metric.closedBall z2 ‚Üër2",
  "constCategory": "Theorem"},
 {"references": ["DistribSMul.smul_add"],
  "name": "smul_add",
  "constType":
  "‚àÄ {M : Type u_1} {A : Type u_7} [inst : AddZeroClass A] [inst_1 : DistribSMul M A] (a : M) (b‚ÇÅ b‚ÇÇ : A),\n  a ‚Ä¢ (b‚ÇÅ + b‚ÇÇ) = a ‚Ä¢ b‚ÇÅ + a ‚Ä¢ b‚ÇÇ",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "norm_nonneg'._simp_4",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 ‚â§ ‚Äña‚Äñ) = True",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "Ne",
  "constType": "{Œ± : Sort u} ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["max_def'",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.Order.le_trans",
   "Lean.Grind.Order.le_eq_false_of_lt",
   "eq_true",
   "ite_cond_eq_true",
   "Lean.Grind.Order.lt_trans",
   "Lean.Grind.Order.le_of_eq_2",
   "Lean.Grind.Order.le_lt_trans",
   "Lean.Grind.Order.lt_of_not_le",
   "Lean.Grind.nestedDecidable",
   "LinearOrder.toDecidableLE'",
   "Eq.symm",
   "Lean.Grind.Order.le_of_eq_1",
   "Not",
   "Lean.Grind.Order.lt_le_trans",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "ite",
   "Lean.Grind.Order.lt_unsat",
   "ite_cond_eq_false",
   "Or.casesOn",
   "Max.max",
   "eq_false",
   "LE.le",
   "Classical.byContradiction",
   "id"],
  "name": "max_assoc",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (a b c : Œ±), max (max a b) c = max a (max b c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Injective",
  "constType": "{Œ± : Sort u_1} ‚Üí {Œ≤ : Sort u_2} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_isNNRat.match_1_1",
   "mul_one",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {a : Œ±} {n : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNat a n ‚Üí Mathlib.Meta.NormNum.IsNNRat a n 1",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "AddRightMono", "lt_add_of_nonneg_of_lt", "LE.le", "OfNat.ofNat"],
  "name": "Right.add_pos_of_nonneg_of_pos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±] [AddRightMono Œ±] {a b : Œ±}, 0 ‚â§ a ‚Üí 0 < b ‚Üí 0 < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh.match_1",
   "NNReal.toReal",
   "Subtype.val",
   "DFunLike.coe",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_5",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_4",
   "HSub.hSub",
   "QuotientAddGroup.mk'",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_1",
   "Norm.norm",
   "Set",
   "NNReal",
   "Submodule.quotientRel",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_2",
   "Submodule.toAddSubgroup",
   "Nat.brecOn",
   "Exists.choose",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "StrictAnti",
   "Antitone",
   "Nat.below",
   "QuotientAddGroup.mk",
   "Quotient.out",
   "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._proof_3"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [IsUltrametricDist E] ‚Üí\n            {F : Submodule ùïú E} ‚Üí\n              ‚¶Éc : ‚Ñï ‚Üí E ‚ß∏ F‚¶Ñ ‚Üí\n                ‚¶Ér : ‚Ñï ‚Üí NNReal‚¶Ñ ‚Üí\n                  StrictAnti r ‚Üí (Antitone fun i ‚Ü¶ Metric.closedBall (c i) ‚Üë(r i)) ‚Üí (t : ‚Ñï) ‚Üí { x // ‚Üëx = c t }",
  "constCategory": "Definition"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Submodule.mem_mk",
   "HSMul.hSMul",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_9",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : AddSubmonoid M} {x : M} (h : ‚àÄ (c : R) {x : M}, x ‚àà S.carrier ‚Üí c ‚Ä¢ x ‚àà S.carrier),\n  (x ‚àà { toAddSubmonoid := S, smul_mem' := h }) = (x ‚àà S)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Int.ofNat_le", "Iff.mpr", "LE.le"],
  "name": "Lean.Omega.Int.ofNat_le_of_le",
  "constType": "‚àÄ {x y : ‚Ñï}, x ‚â§ y ‚Üí ‚Üëx ‚â§ ‚Üëy",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.¬´term_‚üÇ‚Çò_¬ª",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "AddLeftMono",
   "Nat.cast",
   "Eq.trans",
   "OfNat.ofNat",
   "congrArg",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LT.lt",
   "of_eq_true",
   "iff_self",
   "congr",
   "Nat.cast_zero",
   "Eq.symm",
   "lt_self_iff_false._simp_1",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0.Nat.cast_pos'._simp_1_1",
   "Eq.ndrec",
   "Nat.zero_lt_succ._simp_1",
   "Nat.casesAuxOn"],
  "name": "Nat.cast_pos'",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] [NeZero 1]\n  {n : ‚Ñï}, 0 < ‚Üën ‚Üî 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.subtype._proof_2",
   "RingHom.id",
   "Membership.mem",
   "Subtype.val",
   "Submodule.subtype._proof_1"],
  "name": "Submodule.subtype",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí {module_M : _root_.Module R M} ‚Üí (p : Submodule R M) ‚Üí ‚Ü•p ‚Üí‚Çó[R] M",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Prod.fst",
   "congrArg",
   "congr",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (n : ‚Ñ§) (e : M) {L l l' : Mathlib.Tactic.FieldSimp.NF M},\n  L.eval * l.eval = l'.eval ‚Üí ((n, e) ::·µ£ L).eval * l.eval = ((n, e) ::·µ£ l').eval",
  "constCategory": "Theorem"},
 {"references": ["Not", "False.elim", "eq_true"],
  "name": "not_false_eq_true",
  "constType": "(¬¨False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NNReal.coe_mk",
   "le_of_not_gt",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "norm_zero",
   "Exists.choose_spec",
   "Norm.norm",
   "NNReal",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_5",
   "Antitone",
   "SMulMemClass.smul_mem",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_2",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "Mathlib.Tactic.Ring.add_mul",
   "Set.mem_of_mem_of_subset",
   "Submodule.mem_span_singleton_self",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "Subtype.dist_eq",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "dist_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "sub_smul",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Ne",
   "norm_nonneg",
   "antitone_nat_of_succ_le",
   "dite",
   "neg_neg_of_pos",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "Submodule.span",
   "HDiv.hDiv",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_3",
   "Submodule.eq_zero_of_bot_submodule",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "Bot.bot",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "norm_pos_iff",
   "Iff.mpr",
   "div_nonneg",
   "HSMul.hSMul",
   "id",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_1",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "le_div_iff‚ÇÄ",
   "Eq.mp",
   "NNReal.toReal",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "mul_le_of_le_div‚ÇÄ",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "NNReal.zero_le_coe",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet._simp_4",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Set.Nonempty",
   "Submodule.span_zero_singleton",
   "Mathlib.Tactic.Ring.cast_pos",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "norm_smul",
   "LT.lt",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.instSubtypeMemSubmoduleSpanSingletonSet",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] [scsk : SphericallyCompleteSpace ùïú] {E : Type u_2}\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] (z : E), SphericallyCompleteSpace ‚Ü•(ùïú ‚àô z)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Set.Nonempty",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "Classical.not_forall._simp_1",
   "Set.iInter",
   "EmptyCollection.emptyCollection",
   "not_exists._simp_1",
   "congrArg",
   "Classical.not_not._simp_1",
   "iff_self",
   "of_eq_true",
   "_private.Mathlib.Data.Set.Lattice.0.Set.nonempty_iInter._simp_1_1",
   "forall_congr",
   "funext",
   "Ne",
   "_private.Mathlib.Data.Set.Lattice.0.Set.nonempty_iInter._simp_1_2"],
  "name": "Set.nonempty_iInter",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty ‚Üî ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["neg_mem_iff", "Neg.neg", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_2",
  "constType":
  "‚àÄ {S : Type u_3} {G : Type u_4} [inst : InvolutiveNeg G] {x : SetLike S G} [NegMemClass S G] {H : S} {x_1 : G},\n  (-x_1 ‚àà H) = (x_1 ‚àà H)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Filter.map"],
  "name": "Filter.Tendsto",
  "constType":
  "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Filter Œ± ‚Üí Filter Œ≤ ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "MonadExcept.throw",
  "constType":
  "{Œµ : outParam (Type u)} ‚Üí {m : Type v ‚Üí Type w} ‚Üí [self : MonadExcept Œµ m] ‚Üí {Œ± : Type v} ‚Üí Œµ ‚Üí m Œ±",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "mul_add",
   "Eq.symm",
   "HMul.hMul",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.subst_add",
  "constType":
  "‚àÄ {M : Type u_1} [inst : Semiring M] {x‚ÇÅ x‚ÇÇ X‚ÇÅ X‚ÇÇ Y y a : M},\n  x‚ÇÅ = a * X‚ÇÅ ‚Üí x‚ÇÇ = a * X‚ÇÇ ‚Üí X‚ÇÅ + X‚ÇÇ = Y ‚Üí a * Y = y ‚Üí x‚ÇÅ + x‚ÇÇ = y",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_7",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (M : Submodule ùïú E‚ÇÄ), LinearMap.range f ‚â§ M ‚Üí ‚àÄ (x x_1 : ‚Ü•(LinearMap.range f)), ‚Üë(x + x_1) ‚àà M",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "binderNameHint",
  "constType": "{Œ± : Sort u} ‚Üí {Œ≤ : Sort v} ‚Üí {Œ≥ : Sort w} ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hDM",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] {D : Submodule ùïú E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ùïú F]\n  [inst_7 : SphericallyCompleteSpace F] {S : ‚Ü•D ‚ÜíL[ùïú] F} {ùí∞ : Set (E ‚ÜíL[ùïú] F)} {hùí∞ : ùí∞.Nonempty} {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù}\n  (self : SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ),\n  D ‚â§ SphericallyCompleteSpace.PartialExtension.M‚úù self",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.mpr", "Membership.mem", "nonempty_subtype"],
  "name": "Set.Nonempty.to_subtype",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, s.Nonempty ‚Üí Nonempty ‚Üës",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Map.0.Submodule.eq_zero_of_bot_submodule.match_1_1",
   "Membership.mem",
   "Submodule.mem_bot",
   "Iff.mp",
   "Subtype.ext",
   "Bot.bot",
   "OfNat.ofNat"],
  "name": "Submodule.eq_zero_of_bot_submodule",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (b : ‚Ü•‚ä•),\n  b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["not_le_of_gt", "LT.lt", "le_of_lt", "le_trans", "LE.le", "lt_of_le_not_ge"],
  "name": "lt_of_le_of_lt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b c : Œ±}, a ‚â§ b ‚Üí b < c ‚Üí a < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And.right",
  "constType": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí b",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "RingHom.id",
   "LE.le",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthComp._proof_2",
   "Exists.choose",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.OrthProj",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [iud : IsUltrametricDist E] ‚Üí\n          [inst_2 : NormedSpace ùïú E] ‚Üí (F : Submodule ùïú E) ‚Üí [SphericallyCompleteSpace ‚Ü•F] ‚Üí E ‚ÜíL[ùïú] ‚Ü•F",
  "constCategory": "Definition"},
 {"references": ["and_imp", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_7",
  "constType": "‚àÄ {a b c : Prop}, (a ‚àß b ‚Üí c) = (a ‚Üí b ‚Üí c)",
  "constCategory": "Theorem"},
 {"references":
  ["iff_self",
   "_private.Init.PropLemmas.0.exists_and_right._simp_1_1",
   "Eq.trans",
   "of_eq_true",
   "exists_and_left._simp_1",
   "congr",
   "funext",
   "congrArg"],
  "name": "exists_and_right",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {b : Prop}, (‚àÉ x, p x ‚àß b) ‚Üî (‚àÉ x, p x) ‚àß b",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_3",
  "constType":
  "‚àÄ {b : Prop} (Œ± : Sort u_1) [i : Nonempty Œ±], (‚àÄ (a : Œ±), b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["add_lt_add_iff_left",
   "HAdd.hAdd",
   "LT.lt",
   "Iff.trans",
   "AddLeftReflectLT",
   "AddLeftStrictMono",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "lt_add_iff_pos_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : LT Œ±] [AddLeftStrictMono Œ±] [AddLeftReflectLT Œ±] (a : Œ±) {b : Œ±},\n  a < a + b ‚Üî 0 < b",
  "constCategory": "Theorem"},
 {"references": ["inv_nonneg", "Inv.inv", "LE.le", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_6",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a : G‚ÇÄ},\n  (0 ‚â§ a‚Åª¬π) = (0 ‚â§ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "ite", "ite_congr", "congrArg"],
  "name": "ite_cond_eq_false",
  "constType":
  "‚àÄ {Œ± : Sort u} {c : Prop} {x : Decidable c} (a b : Œ±), c = False ‚Üí (if c then a else b) = b",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "eq_true", "le_sup_left"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_10",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, (a ‚â§ a ‚äî b) = True",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._simp_4",
  "constType":
  "‚àÄ {b : Prop} (Œ± : Sort u_1) [i : Nonempty Œ±], (‚àÄ (a : Œ±), b) = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["propext", "exists_eq_right"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_12",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÉ a, p a ‚àß a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Subtype.ext_iff", "Membership.mem", "OfNat.ofNat"],
  "name": "Submodule.mk_eq_zero",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ‚àà p), ‚ü®x, h‚ü© = 0 ‚Üî x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "Nat.cast",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "HPow.hPow",
   "add_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "pow_one",
   "eq_self",
   "of_eq_true",
   "congr"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasSubset.Subset",
  "constType": "{Œ± : Type u} ‚Üí [self : HasSubset Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "Codisjoint",
   "Min.min",
   "codisjoint_iff",
   "Disjoint",
   "Iff.mpr",
   "Top.top",
   "disjoint_iff",
   "Bot.bot"],
  "name": "IsCompl.of_eq",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : BoundedOrder Œ±] {x y : Œ±}, x ‚äì y = ‚ä• ‚Üí x ‚äî y = ‚ä§ ‚Üí IsCompl x y",
  "constCategory": "Theorem"},
 {"references": ["Iff.not_right", "Not", "not_finite_iff_infinite", "Iff.symm"],
  "name": "not_infinite_iff_finite",
  "constType": "‚àÄ {Œ± : Sort u_1}, ¬¨Infinite Œ± ‚Üî Finite Œ±",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_6",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), (y ‚àà f '' s) = ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "mul_assoc",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Prod.fst",
   "congrArg",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (n : ‚Ñ§) (e : M) {L l l' : Mathlib.Tactic.FieldSimp.NF M},\n  L.eval * l.eval = l'.eval ‚Üí L.eval * ((n, e) ::·µ£ l).eval = ((n, e) ::·µ£ l').eval",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp", "Set", "RingHom.id"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp.eq_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (E‚ÇÄ : Type u_3) [inst_4 : NormedAddCommGroup E‚ÇÄ]\n  [inst_5 : NormedSpace ùïú E‚ÇÄ] [inst_6 : IsUltrametricDist E‚ÇÄ] [inst_7 : SphericallyCompleteSpace E‚ÇÄ] (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ),\n  SphericallyCompleteSpace.imm_ext_in_sph_comp E E‚ÇÄ f =\n    {M |\n      ‚àÉ (hc : LinearMap.range f ‚â§ M),\n        SphericallyCompleteSpace.IsImmediate\n          { toFun := fun x ‚Ü¶ ‚ü®‚Üëx, ‚ãØ‚ü©, map_add' := ‚ãØ, map_smul' := ‚ãØ, norm_map' := ‚ãØ }}",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "Norm.norm",
   "Mem‚Ñìp",
   "Iff.mpr",
   "Top.top",
   "mem‚Ñìp_infty_iff",
   "Set.range",
   "BddAbove"],
  "name": "mem‚Ñìp_infty",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] {f : (i : Œ±) ‚Üí E i},\n  BddAbove (Set.range fun i ‚Ü¶ ‚Äñf i‚Äñ) ‚Üí Mem‚Ñìp f ‚ä§",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddSubmonoidClass.toAddMonoid._proof_1",
  "constType":
  "‚àÄ {M : Type u_2} [inst : AddMonoid M] {A : Type u_1} [inst_1 : SetLike A M] [AddSubmonoidClass A M], AddMemClass A M",
  "constCategory": "Theorem"},
 {"references": ["SMulZeroClass.smul_zero"],
  "name": "smul_zero",
  "constType":
  "‚àÄ {M : Type u_1} {A : Type u_7} [inst : Zero A] [inst_1 : SMulZeroClass M A] (a : M), a ‚Ä¢ 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_2",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.leftInverse_invFun",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_4",
   "Eq.substr",
   "SphericallyCompleteSpace.hahn_banach'",
   "Eq.trans",
   "LinearIsometry.ext",
   "Set.rangeFactorization_injective",
   "Eq.mp",
   "LinearMap.range",
   "Membership.mem",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_3",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_2",
   "Subtype.val",
   "DFunLike.coe",
   "Set.Elem",
   "Set.range",
   "ContinuousLinearMap.comp",
   "congrArg",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_3",
   "RingHom.id",
   "forall_congr",
   "Eq.ndrec",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_5",
   "forall_prop_domain_congr",
   "rfl",
   "LinearIsometry.toContinuousLinearMap",
   "ContinuousLinearMap.toLinearMap",
   "Norm.norm",
   "Set",
   "LinearMap.mem_range_self",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_1",
   "LinearIsometry.comp",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_2",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.norm_map_of_isImmediate",
   "Exists.casesOn",
   "eq_self",
   "SphericallyCompleteSpace.IsImmediate",
   "of_eq_true",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "Iff.mpr",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.exists_linearIsometry_comp_eq_of_isImmediate",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [inst_6 : IsUltrametricDist F] {H : Type u_4} [inst_7 : NormedAddCommGroup H]\n  [inst_8 : NormedSpace ùïú H] [IsUltrametricDist H] [SphericallyCompleteSpace H] (f : E ‚Üí‚Çó·µ¢[ùïú] F),\n  SphericallyCompleteSpace.IsImmediate f ‚Üí ‚àÄ (g : E ‚Üí‚Çó·µ¢[ùïú] H), ‚àÉ h, h.comp f = g",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.IsImmediate",
   "RingHom.id",
   "DFunLike.coe",
   "Function.Surjective"],
  "name": "SphericallyCompleteSpace.MaximallyComplete",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u) ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [NormedSpace ùïú E] ‚Üí [IsUltrametricDist E] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Metric.closedBall", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Metric.mem_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, y ‚àà Metric.closedBall x Œµ ‚Üî dist y x ‚â§ Œµ",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT", "Unit"],
  "name": "Lean.PrettyPrinter.UnexpandM",
  "constType": "Type ‚Üí Type",
  "constCategory": "Definition"},
 {"references": ["sup_le_sup"],
  "name": "max_le_max",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c d : Œ±}, a ‚â§ c ‚Üí b ‚â§ d ‚Üí max a b ‚â§ max c d",
  "constCategory": "Theorem"},
 {"references":
  ["dist_le_coe",
   "NNDist.nndist",
   "Dist.dist",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, (dist x y ‚â§ ‚Üëc) = (nndist x y ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_20",
  "constType": "‚àÄ {b a : Prop}, (‚àÉ (_ : a), b) = (a ‚àß b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_9",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort u_1} {f : Œπ ‚Üí Œ±} {x : Œ±}, (x ‚àà Set.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "IsChain",
   "Or.elim",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed._simp_1_4",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed.match_1_1",
   "Subtype.val",
   "refl",
   "exists_prop_congr",
   "congrArg",
   "Order.Preimage",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed._simp_1_3",
   "Iff.of_eq",
   "funext",
   "id",
   "by_cases",
   "Eq.mpr",
   "propext",
   "_private.Mathlib.Order.Preorder.Chain.0.IsChain.directed._simp_1_5"],
  "name": "IsChain.directed",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} [IsRefl Œ± r] {f : Œ≤ ‚Üí Œ±} {c : Set Œ≤},\n  IsChain (f ‚Åª¬π'o r) c ‚Üí Directed r fun x ‚Ü¶ f ‚Üëx",
  "constCategory": "Theorem"},
 {"references": ["sub_eq_zero", "HSub.hSub", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_7",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Prod.fst",
   "Submodule.add_mem_sup",
   "HAdd.hAdd",
   "Subtype.prop",
   "SMulMemClass.smul_mem",
   "id"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_6",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (m : ùïú) (a : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F), m ‚Ä¢ (‚Üëa.1 + ‚Üëa.2) ‚àà ùïú ‚àô x + F",
  "constCategory": "Theorem"},
 {"references": ["Set", "Iff.rfl", "BddAbove"],
  "name": "bddAbove_def",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±}, BddAbove s ‚Üî ‚àÉ x, ‚àÄ y ‚àà s, y ‚â§ x",
  "constCategory": "Theorem"},
 {"references": ["SetLike.coe", "Set", "Membership.mem", "Iff.rfl"],
  "name": "SetLike.mem_coe",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ‚àà ‚Üëp ‚Üî x ‚àà p",
  "constCategory": "Theorem"},
 {"references": ["exists_exists_eq_and", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_14",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {f : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Prop}, (‚àÉ b, (‚àÉ a, f a = b) ‚àß p b) = ‚àÉ a, p (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_4",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["Set.sInter", "HasSubset.Subset", "Set", "setOf"],
  "name": "closure",
  "constType": "{X : Type u} ‚Üí [TopologicalSpace X] ‚Üí Set X ‚Üí Set X",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "of_eq_false",
   "Eq.trans",
   "of_eq_true",
   "Eq.mpr_not",
   "dite",
   "not_false",
   "dite_congr",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_cond_eq_false",
  "constType":
  "‚àÄ {Œ± : Sort u} {c : Prop} {x : Decidable c} {t : c ‚Üí Œ±} {e : ¬¨c ‚Üí Œ±} (h : c = False), dite c t e = e ‚ãØ",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "EMetric.infEdist",
   "congrArg",
   "EDist.edist",
   "LE.le",
   "Dist.dist",
   "dist_edist",
   "ENNReal.toReal",
   "id",
   "EMetric.infEdist_le_edist_of_mem",
   "Metric.infDist",
   "Eq.mpr",
   "Metric.infDist.eq_1",
   "ENNReal.toReal_mono",
   "edist_ne_top"],
  "name": "Metric.infDist_le_dist_of_mem",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x y : Œ±}, y ‚àà s ‚Üí Metric.infDist x s ‚â§ dist x y",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_iff_continuousAt",
   "Iff.mpr",
   "Filter.EventuallyEq.continuousAt",
   "ContinuousAt",
   "Filter.Eventually.of_forall",
   "nhds"],
  "name": "continuous_of_const",
  "constType":
  "‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X ‚Üí Y},\n  (‚àÄ (x y : X), f x = f y) ‚Üí Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "_private.Init.Prelude.0.of_decide_eq_true.match_1_1",
   "decide_eq_false",
   "Decidable.decide",
   "ne_true_of_eq_false"],
  "name": "of_decide_eq_true",
  "constType": "‚àÄ {p : Prop} [inst : Decidable p], decide p = true ‚Üí p",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "le_refl._simp_1",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "LT.lt", "lt_iff_not_ge", "LE.le", "Iff.symm"],
  "name": "not_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, ¬¨a ‚â§ b ‚Üî b < a",
  "constCategory": "Theorem"},
 {"references": ["PseudoMetricSpace.dist_self"],
  "name": "dist_self",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±), dist x x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "HasSSubset.SSubset",
   "HasSubset.Subset",
   "Set",
   "And.right",
   "Set.not_subset",
   "Membership.mem",
   "Iff.mp"],
  "name": "Set.exists_of_ssubset",
  "constType": "‚àÄ {Œ± : Type u} {s t : Set Œ±}, s ‚äÇ t ‚Üí ‚àÉ x ‚àà t, x ‚àâ s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inv.inv",
  "constType": "{Œ± : Type u} ‚Üí [self : Inv Œ±] ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Norm.norm",
   "Set",
   "lowerBounds",
   "Membership.mem",
   "LE.le",
   "And.right",
   "HMul.hMul",
   "ContinuousLinearMap.isLeast_opNorm",
   "DFunLike.coe",
   "OfNat.ofNat",
   "setOf",
   "And.left"],
  "name": "ContinuousLinearMap.le_opNorm",
  "constType":
  "‚àÄ {ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ùïú] [inst_3 : NontriviallyNormedField ùïú‚ÇÇ]\n  [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} [RingHomIsometric œÉ‚ÇÅ‚ÇÇ] (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F)\n  (x : E), ‚Äñf x‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "mul_one",
   "Prod.snd",
   "add_neg_cancel",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval‚ÇÇ",
   "Prod.fst",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Mathlib.Tactic.FieldSimp.zpow'_zero_of_ne_zero",
   "of_eq_true",
   "id",
   "Ne",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (n : ‚Ñ§) {e : M},\n  e ‚â† 0 ‚Üí\n    ‚àÄ {L l l' : Mathlib.Tactic.FieldSimp.NF M},\n      L.eval * l.eval = l'.eval ‚Üí ((n, e) ::·µ£ L).eval * ((-n, e) ::·µ£ l).eval = l'.eval",
  "constCategory": "Theorem"},
 {"references": ["Subtype.prop", "Set", "Membership.mem"],
  "name": "Subtype.coe_prop",
  "constType": "‚àÄ {Œ± : Type u_1} {S : Set Œ±} (a : { a // a ‚àà S }), ‚Üëa ‚àà S",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "rfl"],
  "name": "Submodule.add_eq_sup",
  "constType":
  "‚àÄ {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p q : Submodule R M), p + q = p ‚äî q",
  "constCategory": "Theorem"},
 {"references": ["Array.mkArray1", "Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.node1",
  "constType": "SourceInfo ‚Üí SyntaxNodeKind ‚Üí Syntax ‚Üí Syntax",
  "constCategory": "Definition"},
 {"references":
  ["smul_zero",
   "Submodule.ext",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0.Submodule.span_zero_singleton._simp_1_1",
   "Submodule.mem_bot._simp_1",
   "Eq.trans",
   "Set",
   "Singleton.singleton",
   "exists_const._simp_1",
   "Membership.mem",
   "Submodule.span",
   "Bot.bot",
   "OfNat.ofNat",
   "congrArg",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0.Submodule.span_zero_singleton._simp_1_2",
   "iff_self",
   "of_eq_true",
   "congr",
   "funext",
   "HSMul.hSMul"],
  "name": "Submodule.span_zero_singleton",
  "constType":
  "‚àÄ (R : Type u_1) {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M], R ‚àô 0 = ‚ä•",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.¬´term_‚üÇ[_]_¬ª",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{Œ± : Sort u} ‚Üí {Œ≤ : Sort v} ‚Üí {Œ¥ : Sort w} ‚Üí (Œ≤ ‚Üí Œ¥) ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Œ± ‚Üí Œ¥",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' ‚Üí b = b' ‚Üí a' + b' = c ‚Üí a + b = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT.lt",
  "constType": "{Œ± : Type u} ‚Üí [self : LT Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.pi", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_pi",
  "constType":
  "‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} {s : Set Œπ} {t : (i : Œπ) ‚Üí Set (Œ± i)} {f : (i : Œπ) ‚Üí Œ± i},\n  f ‚àà s.pi t ‚Üî ‚àÄ i ‚àà s, f i ‚àà t i",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "neg_add_rev",
   "Eq.ndrec",
   "add_comm",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "‚àÄ {R : Type u_2} [inst : CommRing R] {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : R}, -a‚ÇÅ = b‚ÇÅ ‚Üí -a‚ÇÇ = b‚ÇÇ ‚Üí -(a‚ÇÅ + a‚ÇÇ) = b‚ÇÅ + b‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "‚àÄ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "PreLp",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.c‚ÇÄ"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ.eq_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_2) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)],\n  SphericallyCompleteSpace.c‚ÇÄ ùïú E =\n    { carrier := {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ}, add_mem' := ‚ãØ, zero_mem' := ‚ãØ, smul_mem' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Prod.snd",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "HSMul.hSMul",
   "id",
   "Eq.ndrec"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_5",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (m : ùïú) (a : ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F), m ‚Ä¢ ‚Üëa.1 + m ‚Ä¢ ‚Üëa.2 ‚àà ùïú ‚àô x ‚äî F",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty", "Set", "RingHom.id", "Membership.mem", "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.hU",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] {D : Submodule ùïú E} {F : Type u_3}\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ùïú F]\n  [inst_7 : SphericallyCompleteSpace F] {S : ‚Ü•D ‚ÜíL[ùïú] F} {ùí∞ : Set (E ‚ÜíL[ùïú] F)} {hùí∞ : ùí∞.Nonempty} {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù}\n  (self : SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ) (U : ‚Üëùí∞)\n  (x : ‚Ü•(SphericallyCompleteSpace.PartialExtension.M‚úù self)),\n  ‚Äñ(SphericallyCompleteSpace.PartialExtension.T‚úù self) x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "norm_eq_zero",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "RingHom.id",
   "funext",
   "forall_congr",
   "Eq.symm",
   "Subtype.coe_eta",
   "AddHom.toFun",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "Eq.ndrec",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "forall_prop_domain_congr",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_4",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Norm.norm",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.IsImmediate",
   "SetLike.coe",
   "Iff.of_eq",
   "SphericallyCompleteSpace.IsImmediate._proof_2",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_2",
   "setOf",
   "Eq.substr",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_3",
   "LinearMap.range",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_8",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_6",
   "DFunLike.coe",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "Subspace",
   "congrArg",
   "LinearMap.range.congr_simp",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_7",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "Metric.infDist",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_9",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "propext",
   "LinearIsometry.mk.congr_simp",
   "SphericallyCompleteSpace.IsImmediate._proof_1",
   "Set",
   "Metric.infDist_zero_of_mem",
   "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_5",
   "AddHom.mk.congr_simp",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "exists_prop_congr",
   "HAdd.hAdd",
   "of_eq_true",
   "LE.le",
   "LinearMap.mk.congr_simp"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (E‚ÇÄ : Type u_3) [inst_4 : NormedAddCommGroup E‚ÇÄ]\n  [inst_5 : NormedSpace ùïú E‚ÇÄ] [inst_6 : IsUltrametricDist E‚ÇÄ] [inst_7 : SphericallyCompleteSpace E‚ÇÄ] (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ),\n  (SphericallyCompleteSpace.imm_ext_in_sph_comp E E‚ÇÄ f).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Membership.mem.out",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "ENNReal",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.IsImmediate",
   "Maximal",
   "LE.le",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : E),\n  (SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) x ‚àà ‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mp",
   "id",
   "eq_true",
   "Classical.not_imp._simp_1",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg"],
  "name": "Lean.Grind.eq_true_of_imp_eq_false",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üí b) = False ‚Üí a = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_3",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references":
  ["mul_comm", "Eq.symm", "id", "HMul.hMul", "mul_assoc", "Eq.mpr", "congrArg"],
  "name": "CancelDenoms.mul_subst",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : CommRing Œ±] {n1 n2 k e1 e2 t1 t2 : Œ±},\n  n1 * e1 = t1 ‚Üí n2 * e2 = t2 ‚Üí n1 * n2 = k ‚Üí k * (e1 * e2) = t1 * t2",
  "constCategory": "Theorem"},
 {"references": ["IsLinearMap.map_smul", "RingHom.id", "IsLinearMap.map_add"],
  "name": "IsLinearMap.mk'",
  "constType":
  "{R : Type u_1} ‚Üí\n  {M : Type u_8} ‚Üí\n    {M‚ÇÇ : Type u_10} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí\n          [inst_2 : AddCommMonoid M‚ÇÇ] ‚Üí\n            [inst_3 : _root_.Module R M] ‚Üí [inst_4 : _root_.Module R M‚ÇÇ] ‚Üí (f : M ‚Üí M‚ÇÇ) ‚Üí IsLinearMap R f ‚Üí M ‚Üí‚Çó[R] M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["RingHom.id", "continuous_id", "LinearMap.id"],
  "name": "ContinuousLinearMap.id",
  "constType":
  "(R‚ÇÅ : Type u_1) ‚Üí\n  [inst : Semiring R‚ÇÅ] ‚Üí\n    (M‚ÇÅ : Type u_4) ‚Üí\n      [inst_1 : TopologicalSpace M‚ÇÅ] ‚Üí [inst_2 : AddCommMonoid M‚ÇÅ] ‚Üí [inst_3 : _root_.Module R‚ÇÅ M‚ÇÅ] ‚Üí M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd", "Function.Injective.eq_iff", "add_left_injective"],
  "name": "add_left_inj",
  "constType":
  "‚àÄ {G : Type u_1} [inst : Add G] [IsRightCancelAdd G] (a : G) {b c : G}, b + a = c + a ‚Üî b = c",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton.singleton",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≤ : Type v} ‚Üí [self : Singleton Œ± Œ≤] ‚Üí Œ± ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_14",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Encodable.encodek", "Denumerable.ofNat_of_decode", "Encodable.encode"],
  "name": "Denumerable.ofNat_encode",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Denumerable Œ±] (a : Œ±), Denumerable.ofNat Œ± (Encodable.encode a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "norm_sub_le_norm_sub_add_norm_sub",
   "Norm.norm",
   "Eq.mp",
   "congr",
   "LE.le",
   "HSub.hSub",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_le_norm_sub_add",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), ‚Äña‚Äñ ‚â§ ‚Äña - b‚Äñ + ‚Äñb‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "one_div",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range._simp_1_6",
   "HMul.hMul",
   "or_true",
   "GT.gt",
   "Prod.fst",
   "congrArg",
   "HDiv.hDiv",
   "not_false_eq_true",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
   "congr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range._simp_1_5",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range._simp_1_2",
   "Not",
   "Inv.inv",
   "div_self",
   "Exists.choose_spec",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range._simp_1_1",
   "NNReal",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "zero_add",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range._simp_1_3",
   "mul_lt_mul_iff_right‚ÇÄ",
   "of_eq_true",
   "CharP.cast_eq_zero",
   "Iff.mpr",
   "NNDist.nndist",
   "id",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range._simp_1_4",
   "add_self_div_two",
   "Eq.mpr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "mul_div_assoc"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_range",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] [nemp : Nonempty Œ±]\n  (n : ‚Ñï), SphericallyCompleteSpace.fuck_radius‚úù Œ± n > SphericallyCompleteSpace.fuck_radius‚úù¬π Œ± 0 / 2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype.val",
  "constType": "{Œ± : Sort u} ‚Üí {p : Œ± ‚Üí Prop} ‚Üí Subtype p ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["sub_neg_of_lt", "LE.le"],
  "name": "Mathlib.Tactic.Linarith.sub_neg_of_lt",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Ring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] {a b : Œ±}, a < b ‚Üí a - b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Logic.Denumerable.0.nonempty_denumerable_iff.match_1_1",
   "nonempty_denumerable",
   "inferInstance",
   "_private.Mathlib.Logic.Denumerable.0.nonempty_denumerable_iff.match_1_3"],
  "name": "nonempty_denumerable_iff",
  "constType":
  "‚àÄ {Œ± : Type u_3}, Nonempty (Denumerable Œ±) ‚Üî Countable Œ± ‚àß Infinite Œ±",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "ConditionallyCompleteLattice.le_csSup",
   "BddAbove"],
  "name": "le_csSup",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, BddAbove s ‚Üí a ‚àà s ‚Üí a ‚â§ sSup s",
  "constCategory": "Theorem"},
 {"references": ["ciSup_le", "OrderDual", "LE.le"],
  "name": "le_ciInf",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} [inst : ConditionallyCompleteLattice Œ±] [Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\n  (‚àÄ (x : Œπ), c ‚â§ f x) ‚Üí c ‚â§ iInf f",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "not_lt._simp_1",
   "dist_eq_norm",
   "Submodule.nonempty",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "sub_zero",
   "Metric.le_infDist",
   "Subspace",
   "congrArg",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "forall_congr",
   "Dist.dist",
   "HSub.hSub",
   "Eq.symm",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "SphericallyCompleteSpace.MOrth",
   "Not",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÉ",
   "binderNameHint",
   "Norm.norm",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÇ",
   "Set",
   "OfNat.ofNat",
   "LT.lt",
   "ZeroMemClass.zero_mem._simp_1",
   "SetLike.coe",
   "of_eq_true",
   "SetLike.mem_coe._simp_1",
   "Iff.mpr",
   "LE.le",
   "id",
   "Mathlib.Tactic.Push.not_and_eq",
   "Eq.mpr",
   "eq_of_le_of_ge"],
  "name": "SphericallyCompleteSpace.not_morth_iff_exists_dist_lt_norm",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ùïú E},\n  ¬¨SphericallyCompleteSpace.MOrth ùïú x F ‚Üî ‚àÉ y ‚àà F, dist x y < ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "one_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.one_mul",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] (a : R), Nat.rawCast 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "norm_pos_iff", "Norm.norm", "Ne", "OfNat.ofNat", "propext"],
  "name": "norm_pos_iff'._simp_4",
  "constType":
  "‚àÄ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, (0 < ‚Äña‚Äñ) = (a ‚â† 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_6",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), (y ‚àà f '' s) = ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "StrictAnti",
   "antitone_iff_forall_lt",
   "Antitone",
   "Iff.mpr",
   "LE.le",
   "LT.lt.le"],
  "name": "StrictAnti.antitone",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PartialOrder Œ±] [inst_1 : Preorder Œ≤] {f : Œ± ‚Üí Œ≤}, StrictAnti f ‚Üí Antitone f",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_4",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.sat'.eq_1",
   "Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs.combo",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
   "Lean.Omega.Constraint.combo",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Omega.Constraint.combo_sat",
   "Lean.Omega.IntList",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.combo_sat'",
  "constType":
  "‚àÄ (s t : Omega.Constraint) (a : ‚Ñ§) (x : Omega.Coeffs) (b : ‚Ñ§) (y v : Omega.Coeffs),\n  s.sat' x v = true ‚Üí t.sat' y v = true ‚Üí (Omega.Constraint.combo a s b t).sat' (Omega.Coeffs.combo a x b y) v = true",
  "constCategory": "Theorem"},
 {"references": ["id", "HMul.hMul", "Eq.mpr", "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
  "constType":
  "‚àÄ {M : Type u_1} [inst : Mul M] {a b c D e f : M}, a = b ‚Üí b = c ‚Üí c = D * e ‚Üí e = f ‚Üí a = D * f",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.mp",
   "forall_congr",
   "Membership.mem",
   "id",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.sorth_of_sorth._simp_1_2",
   "Eq.mpr",
   "SphericallyCompleteSpace.SOrth",
   "SphericallyCompleteSpace.Orth",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth",
   "SphericallyCompleteSpace.MOrth",
   "Subspace"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.sorth_of_sorth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F1 F2 : Subspace ùïú E},\n  SphericallyCompleteSpace.SOrth ùïú F1 F2 ‚Üí SphericallyCompleteSpace.SOrth ùïú F2 F1",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references": ["NeZero.ne", "OfNat.ofNat"],
  "name": "one_ne_zero",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Zero Œ±] [inst_1 : One Œ±] [NeZero 1], 1 ‚â† 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroClass.mul_zero",
  "constType": "‚àÄ {M‚ÇÄ : Type u} [self : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod.snd",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí Œ± √ó Œ≤ ‚Üí Œ≤",
  "constCategory": "Definition"},
 {"references":
  ["neg_add_cancel",
   "HAdd.hAdd",
   "Neg.neg",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "OfNat.ofNat",
   "congrArg"],
  "name": "add_neg_cancel",
  "constType": "‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "AddLeftMono",
   "Nat.cast",
   "eq_true",
   "OfNat.ofNat",
   "Nat.cast_add_one_pos"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] [NeZero 1]\n  (n : ‚Ñï), (0 < ‚Üën + 1) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsUltrametricDist.dist_triangle_max",
  "constType":
  "‚àÄ {X : Type u_2} {inst : Dist X} [self : IsUltrametricDist X] (x y z : X), dist x z ‚â§ max (dist x y) (dist y z)",
  "constCategory": "Theorem"},
 {"references": ["Max.max"],
  "name": "Nat.max",
  "constType": "‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references": ["not_congr"],
  "name": "Iff.not",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí (¬¨a ‚Üî ¬¨b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "LE.le",
   "AddLeftReflectLE",
   "propext",
   "add_le_add_iff_left"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_9",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : LE Œ±] [AddLeftMono Œ±] [AddLeftReflectLE Œ±] (a : Œ±) {b c : Œ±},\n  (a + b ‚â§ a + c) = (b ‚â§ c)",
  "constCategory": "Theorem"},
 {"references": ["SMulWithZero.zero_smul"],
  "name": "zero_smul",
  "constType":
  "‚àÄ (M‚ÇÄ : Type u_2) {A : Type u_7} [inst : Zero M‚ÇÄ] [inst_1 : Zero A] [inst_2 : SMulWithZero M‚ÇÄ A] (m : A), 0 ‚Ä¢ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["norm_sub_rev",
   "Norm.norm",
   "Neg.neg",
   "Eq.mp",
   "zero_sub",
   "congr",
   "HSub.hSub",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_neg",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), ‚Äñ-a‚Äñ = ‚Äña‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "PreLp",
   "HasQuotient.Quotient",
   "lp",
   "RingHom.id",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.c‚ÇÄ"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension.eq_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E],\n  SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E =\n    {\n      toFun := fun x ‚Ü¶\n        have this := ‚ãØ;\n        (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup) ‚ü®fun x_1 ‚Ü¶ x, this‚ü©,\n      map_add' := ‚ãØ, map_smul' := ‚ãØ, norm_map' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_3",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, (x ‚â• y) = (y ‚â§ x)",
  "constCategory": "Theorem"},
 {"references":
  ["isClosed_le",
   "Dist.dist",
   "id",
   "continuous_const",
   "continuous_id",
   "Continuous.dist"],
  "name": "Metric.isClosed_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, IsClosed (Metric.closedBall x Œµ)",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_6",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "id",
   "neg_add_cancel_left",
   "Eq.mpr",
   "add_comm",
   "congrArg"],
  "name": "add_neg_cancel_comm",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddCommGroup G] (a b : G), a + b + -a = b",
  "constCategory": "Theorem"},
 {"references": ["trivial", "propext", "And.left"],
  "name": "and_true",
  "constType": "‚àÄ (p : Prop), (p ‚àß True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "Iff.rfl",
   "OfNat.ofNat"],
  "name": "AddSubmonoid.mem_mk",
  "constType":
  "‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubsemigroup M} {x : M} (h_zero : 0 ‚àà s.carrier),\n  x ‚àà { toAddSubsemigroup := s, zero_mem' := h_zero } ‚Üî x ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax.isNodeOf", "Lean.nullKind"],
  "name": "Lean.Syntax.matchesNull",
  "constType": "Syntax ‚Üí ‚Ñï ‚Üí Bool",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "LE.le", "Iff.rfl", "OfNat.ofNat"],
  "name": "Int.add_one_le_iff",
  "constType": "‚àÄ {a b : ‚Ñ§}, a + 1 ‚â§ b ‚Üî a < b",
  "constCategory": "Theorem"},
 {"references": ["trivial"],
  "name": "Submodule.mem_top",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  x ‚àà ‚ä§",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Dist.dist"],
  "name": "Subtype.dist_eq",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] {p : Œ± ‚Üí Prop} (x y : Subtype p), dist x y = dist ‚Üëx ‚Üëy",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat_ne_zero", "eq_false", "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_9",
  "constType":
  "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] (n : ‚Ñï) [inst_2 : n.AtLeastTwo], (OfNat.ofNat n = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "Submodule.span",
   "Submodule.span_induction",
   "Union.union",
   "congrArg",
   "Submodule.span_eq",
   "le_sup_right",
   "congr",
   "Eq.symm",
   "Eq.ndrec",
   "add_comm",
   "Set",
   "Submodule.smul_mem",
   "le_sup_left",
   "add_zero",
   "OfNat.ofNat",
   "Or.casesOn",
   "HAdd.hAdd",
   "Exists.casesOn",
   "eq_self",
   "ZeroMemClass.zero_mem._simp_1",
   "Max.max",
   "zero_add",
   "and_self",
   "SetLike.coe",
   "of_eq_true",
   "add_assoc",
   "HSMul.hSMul",
   "id",
   "smul_add",
   "Submodule.span_union",
   "AddMemClass.add_mem",
   "Eq.mpr",
   "And.casesOn"],
  "name": "Submodule.mem_sup",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M}\n  {p p' : Submodule R M}, x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "iSup",
   "isLUB_ciSup",
   "upperBounds",
   "Set",
   "isLUB_le_iff",
   "Membership.mem",
   "LE.le",
   "Set.forall_mem_range",
   "Set.range",
   "BddAbove"],
  "name": "ciSup_le_iff",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} [inst : ConditionallyCompleteLattice Œ±] [Nonempty Œπ] {f : Œπ ‚Üí Œ±} {a : Œ±},\n  BddAbove (Set.range f) ‚Üí (iSup f ‚â§ a ‚Üî ‚àÄ (i : Œπ), f i ‚â§ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max",
   "le_sup_right",
   "le_trans",
   "LE.le",
   "sup_le",
   "_private.Mathlib.Order.Lattice.0.sup_le_iff.match_1_1",
   "le_sup_left"],
  "name": "sup_le_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b c : Œ±}, a ‚äî b ‚â§ c ‚Üî a ‚â§ c ‚àß b ‚â§ c",
  "constCategory": "Theorem"},
 {"references": ["exists_eq", "eq_true"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_9",
  "constType": "‚àÄ {Œ± : Sort u_1} {a' : Œ±}, (‚àÉ a, a = a') = True",
  "constCategory": "Theorem"},
 {"references": ["le_of_not_ge", "Not", "LE.le", "lt_of_le_not_ge"],
  "name": "lt_of_not_ge",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, ¬¨b ‚â§ a ‚Üí a < b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "ENNReal", "PreLp", "Norm.norm", "lp", "Membership.mem", "Top.top"],
  "name": "lp.norm_eq_ciSup",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] (f : ‚Ü•(lp E ‚ä§)), ‚Äñf‚Äñ = ‚®Ü i, ‚Äñ‚Üëf i‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.Data.Prod.0.Prod.forall.match_1_1"],
  "name": "Prod.forall",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± √ó Œ≤ ‚Üí Prop}, (‚àÄ (x : Œ± √ó Œ≤), p x) ‚Üî ‚àÄ (a : Œ±) (b : Œ≤), p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["AlgebraicClosure", "Padic", "Nat.Prime"],
  "name": "PadicAlgCl",
  "constType": "(p : ‚Ñï) ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí Type",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.ext_iff",
   "Membership.mem",
   "Subtype.val",
   "Iff.symm",
   "OfNat.ofNat"],
  "name": "ZeroMemClass.coe_eq_zero",
  "constType":
  "‚àÄ {A : Type u_3} {M‚ÇÅ : Type u_4} [inst : SetLike A M‚ÇÅ] [inst_1 : Zero M‚ÇÅ] [hA : ZeroMemClass A M‚ÇÅ] {S' : A} {x : ‚Ü•S'},\n  ‚Üëx = 0 ‚Üî x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_7",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "Eq.ndrec", "DFunLike.coe"],
  "name": "LinearIsometry.mk.congr_simp",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {E : Type u_11}\n  {E‚ÇÇ : Type u_12} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup E‚ÇÇ] [inst_4 : _root_.Module R E]\n  [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] (toLinearMap toLinearMap_1 : E ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ)\n  (e_toLinearMap : toLinearMap = toLinearMap_1) (norm_map' : ‚àÄ (x : E), ‚ÄñtoLinearMap x‚Äñ = ‚Äñx‚Äñ),\n  { toLinearMap := toLinearMap, norm_map' := norm_map' } = { toLinearMap := toLinearMap_1, norm_map' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["Trans.trans",
   "sub_eq_zero",
   "Iff.mpr",
   "HSMul.hSMul",
   "Or.resolve_right",
   "HSub.hSub",
   "Iff.mp",
   "Ne",
   "sub_smul",
   "smul_eq_zero",
   "OfNat.ofNat"],
  "name": "smul_left_injective",
  "constType":
  "‚àÄ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  [NoZeroSMulDivisors R M] {x : M}, x ‚â† 0 ‚Üí Function.Injective fun c ‚Ü¶ c ‚Ä¢ x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "LT.lt.not_ge",
   "Set",
   "Membership.mem",
   "Dist.dist",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem"],
  "name": "Metric.notMem_of_dist_lt_infDist",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x y : Œ±}, dist x y < Metric.infDist x s ‚Üí y ‚àâ s",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references": ["NNReal", "OfNat.ofNat", "ENNReal.top_ne_coe"],
  "name": "ENNReal.top_ne_zero",
  "constType": "‚ä§ ‚â† 0",
  "constCategory": "Theorem"},
 {"references": ["LinearMap.toAddHom", "AddHom.toFun", "Eq.ndrec"],
  "name": "ContinuousLinearMap.mk.congr_simp",
  "constType":
  "‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {M : Type u_3}\n  [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M] {M‚ÇÇ : Type u_4} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : _root_.Module R M] [inst_7 : _root_.Module S M‚ÇÇ]\n  (toLinearMap toLinearMap_1 : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) (e_toLinearMap : toLinearMap = toLinearMap_1)\n  (cont : Continuous toLinearMap.toFun),\n  { toLinearMap := toLinearMap, cont := cont } = { toLinearMap := toLinearMap_1, cont := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_4",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.atTop",
   "Filter.tendsto_atTop_mono",
   "id",
   "Filter.tendsto_id",
   "StrictMono.id_le",
   "StrictMono"],
  "name": "StrictMono.tendsto_atTop",
  "constType":
  "‚àÄ {œÜ : ‚Ñï ‚Üí ‚Ñï}, StrictMono œÜ ‚Üí Filter.Tendsto œÜ Filter.atTop Filter.atTop",
  "constCategory": "Theorem"},
 {"references": ["Set", "ENNReal.toReal_nonneg", "EMetric.infEdist"],
  "name": "Metric.infDist_nonneg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±}, 0 ‚â§ Metric.infDist x s",
  "constCategory": "Theorem"},
 {"references": ["NNReal", "WithTop"],
  "name": "ENNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "_private.Mathlib.Topology.MetricSpace.HausdorffDistance.0.Metric.infDist_lt_iff._simp_1_1",
   "Set.Nonempty",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "Classical.not_forall._simp_1",
   "Metric.le_infDist",
   "congrArg",
   "LT.lt",
   "iff_self",
   "of_eq_true",
   "congr",
   "funext",
   "Dist.dist",
   "LE.le",
   "Metric.infDist",
   "Classical.not_imp._simp_1",
   "propext"],
  "name": "Metric.infDist_lt_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {r : ‚Ñù},\n  s.Nonempty ‚Üí (Metric.infDist x s < r ‚Üî ‚àÉ y ‚àà s, dist x y < r)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Inter.inter", "Membership.mem", "And.left"],
  "name": "Set.mem_of_mem_inter_left",
  "constType": "‚àÄ {Œ± : Type u} {x : Œ±} {a b : Set Œ±}, x ‚àà a ‚à© b ‚Üí x ‚àà a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "OrderDual", "LE.le", "monotone_nat_of_le_succ", "OfNat.ofNat"],
  "name": "antitone_nat_of_succ_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {f : ‚Ñï ‚Üí Œ±}, (‚àÄ (n : ‚Ñï), f (n + 1) ‚â§ f n) ‚Üí Antitone f",
  "constCategory": "Theorem"},
 {"references":
  ["OrderBot.bot_le", "Set", "lowerBounds", "Membership.mem", "Bot.bot"],
  "name": "OrderBot.bddBelow",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [OrderBot Œ±] (s : Set Œ±), BddBelow s",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMul.hMul",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HMul Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv.hDiv",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HDiv Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_2) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] (i : ‚Ñï), IsBoundedSMul ùïú (E i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Set.Finite", "Set.Elem", "propext", "Set.finite_coe_iff"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_13",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Finite ‚Üës = s.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.fromRef", "Bind.bind", "Lean.MonadRef.getRef", "Pure.pure"],
  "name": "Lean.MonadRef.mkInfoFromRefPos",
  "constType": "{m : Type ‚Üí Type} ‚Üí [Monad m] ‚Üí [MonadRef m] ‚Üí m SourceInfo",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_2",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x y : Œ±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": ["NegZeroClass.neg_zero"],
  "name": "neg_zero",
  "constType": "‚àÄ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Function.leftInverse_invFun",
   "Function.invFun.congr_simp",
   "Eq.substr",
   "Eq.trans",
   "Set.rangeFactorization_injective",
   "LinearMap.range",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_3",
   "Membership.mem",
   "LinearIsometry.norm_map",
   "Subtype.mk.congr_simp",
   "map_smul",
   "DFunLike.coe",
   "Subtype.val",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "RingHom.id",
   "congr",
   "forall_congr",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "forall_prop_domain_congr",
   "Subtype.val_injective",
   "Norm.norm",
   "Set",
   "LinearIsometry.injective",
   "Set.rangeFactorization",
   "Set.rangeFactorization_surjective",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_2",
   "Eq.casesOn",
   "HAdd.hAdd",
   "map_add",
   "eq_self",
   "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._simp_1",
   "Function.RightInverse",
   "of_eq_true",
   "Function.rightInverse_invFun",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Function.invFun",
   "Eq.mpr",
   "Function.Injective"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Immediate.0.SphericallyCompleteSpace.LinearIsometry.weakInv._proof_5",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí‚Çó·µ¢[ùïú] F)\n  (x : ‚Ü•(LinearMap.range f)),\n  ‚Äñ{ toFun := Function.invFun (Set.rangeFactorization ‚áëf), map_add' := ‚ãØ, map_smul' := ‚ãØ } x‚Äñ = ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["zero_lt_one"],
  "name": "Mathlib.Tactic.Linarith.zero_lt_one",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsStrictOrderedRing Œ±], 0 < 1",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma.add_comm"],
  "name": "add_comm",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "AddMonoidHom.mk'",
   "QuotientAddGroup.mk",
   "QuotientAddGroup.mk'._proof_1"],
  "name": "QuotientAddGroup.mk'",
  "constType":
  "{G : Type u_1} ‚Üí [inst : AddGroup G] ‚Üí (N : AddSubgroup G) ‚Üí [nN : N.Normal] ‚Üí G ‚Üí+ G ‚ß∏ N",
  "constCategory": "Definition"},
 {"references": ["LE.le", "bot_le", "eq_true", "Bot.bot"],
  "name": "SphericallyCompleteSpace.sphericalCompletion_minimal._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LE Œ±] [inst_1 : OrderBot Œ±] {a : Œ±}, (‚ä• ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["nndist_eq_zero", "NNDist.nndist", "NNReal", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_21",
  "constType":
  "‚àÄ {Œ≥ : Type w} [inst : MetricSpace Œ≥] {x y : Œ≥}, (nndist x y = 0) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "le_sup_iff", "LE.le", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_10",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, (a ‚â§ max b c) = (a ‚â§ b ‚à® a ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "LinearMap.range",
   "Membership.mem",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "SphericallyCompleteSpace.IsImmediate",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "LE.le",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "setOf"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u_2) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [IsUltrametricDist E] ‚Üí\n            (E‚ÇÄ : Type u_3) ‚Üí\n              [inst_4 : NormedAddCommGroup E‚ÇÄ] ‚Üí\n                [inst_5 : NormedSpace ùïú E‚ÇÄ] ‚Üí\n                  [IsUltrametricDist E‚ÇÄ] ‚Üí [SphericallyCompleteSpace E‚ÇÄ] ‚Üí (E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) ‚Üí Set (Submodule ùïú E‚ÇÄ)",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_9",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "PreLp",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.c‚ÇÄ"],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_3",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [IsUltrametricDist E],\n  IsUltrametricDist (‚Ü•(lp (fun x ‚Ü¶ E) ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E)",
  "constCategory": "Theorem"},
 {"references":
  ["Monotone.map_max",
   "LE.le",
   "monotone_mul_right_of_nonneg",
   "HMul.hMul",
   "OfNat.ofNat"],
  "name": "max_mul_of_nonneg",
  "constType":
  "‚àÄ {R : Type u} [inst : Semiring R] [inst_1 : LinearOrder R] {c : R} [MulPosMono R] (a b : R),\n  0 ‚â§ c ‚Üí max a b * c = max (a * c) (b * c)",
  "constCategory": "Theorem"},
 {"references": ["Submodule.neg_mem", "Submodule.toAddSubmonoid"],
  "name": "Submodule.toAddSubgroup",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Ring R] ‚Üí [inst_1 : AddCommGroup M] ‚Üí {module_M : _root_.Module R M} ‚Üí Submodule R M ‚Üí AddSubgroup M",
  "constCategory": "Definition"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "Maximal",
   "Set",
   "RingHom.id",
   "Membership.mem",
   "inferInstance",
   "Exists.choose"],
  "name": "SphericallyCompleteSpace.instIsUltrametricDistSphericalCompletion",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (E‚ÇÄ : Type u_3) [inst_4 : NormedAddCommGroup E‚ÇÄ]\n  [inst_5 : NormedSpace ùïú E‚ÇÄ] [inst_6 : IsUltrametricDist E‚ÇÄ] [inst_7 : SphericallyCompleteSpace E‚ÇÄ] (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ),\n  IsUltrametricDist ‚Ü•‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "mul_neg",
   "congr",
   "HSub.hSub",
   "left_distrib",
   "HMul.hMul",
   "congrArg"],
  "name": "CancelDenoms.sub_subst",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {n e1 e2 t1 t2 : Œ±}, n * e1 = t1 ‚Üí n * e2 = t2 ‚Üí n * (e1 - e2) = t1 - t2",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.image",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Set Œ± ‚Üí Set Œ≤",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üí b) ‚Üí ¬¨b ‚Üí ¬¨a",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Exists.choose",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "Maximal",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletion",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u) ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [NormedSpace ùïú E] ‚Üí [IsUltrametricDist E] ‚Üí Type u",
  "constCategory": "Definition"},
 {"references": ["Set", "LE.le", "Membership.mem", "setOf"],
  "name": "upperBounds",
  "constType": "{Œ± : Type u_1} ‚Üí [LE Œ±] ‚Üí Set Œ± ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["Subtype.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_12",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÉ x, q x) = ‚àÉ a, ‚àÉ (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Not", "Nat.lt_or_ge", "LE.le", "Or.resolve_right", "GE.ge"],
  "name": "Nat.lt_of_not_le",
  "constType": "‚àÄ {a b : ‚Ñï}, ¬¨a ‚â§ b ‚Üí b < a",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "inv_nonneg",
   "PosMulReflectLT.toPosMulStrictMono",
   "mul_nonneg",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "HDiv.hDiv",
   "Iff.mpr",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "div_nonneg",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a b : G‚ÇÄ},\n  0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí 0 ‚â§ a / b",
  "constCategory": "Theorem"},
 {"references": ["Subtype.property", "Membership.mem"],
  "name": "SetLike.coe_mem",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ‚Ü•p), ‚Üëx ‚àà p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.eq_false_of_imp_eq_false",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "NNReal.toReal",
   "eq_true",
   "DFunLike.coe",
   "Lean.Grind.of_forall_eq_false",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "Not",
   "Set.preimage",
   "Set",
   "NNReal",
   "Set.subset_def",
   "Exists.casesOn",
   "Metric.closedBall",
   "HasSubset.Subset",
   "of_eq_true",
   "Lean.Grind.iff_eq",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.eq_true_of_imp_eq_false",
   "Set.mem_preimage"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._proof_1_1",
  "constType":
  "‚àÄ {E : Type u_1} {F : Type u_2} [inst : PseudoMetricSpace E] [inst_1 : PseudoMetricSpace F] (f : E ‚âÉ·µ¢ F) ‚¶Éci : ‚Ñï ‚Üí F‚¶Ñ\n  ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ ‚¶Ém n : ‚Ñï‚¶Ñ,\n  Metric.closedBall (ci n) ‚Üë(ri n) ‚äÜ Metric.closedBall (ci m) ‚Üë(ri m) ‚Üí\n    ‚áëf ‚Åª¬π' Metric.closedBall (ci n) ‚Üë(ri n) ‚äÜ ‚áëf ‚Åª¬π' Metric.closedBall (ci m) ‚Üë(ri m)",
  "constCategory": "Theorem"},
 {"references": ["Codisjoint.eq_top", "IsCompl.codisjoint"],
  "name": "IsCompl.sup_eq_top",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : BoundedOrder Œ±] {x y : Œ±}, IsCompl x y ‚Üí x ‚äî y = ‚ä§",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.substr",
  "constType": "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {a b : Œ±}, b = a ‚Üí p a ‚Üí p b",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "Eq.symm",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (dist y x ‚â§ Œµ) = (y ‚àà Metric.closedBall x Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "HDiv.hDiv",
   "eq_self",
   "Inv.inv",
   "Eq.trans",
   "of_eq_true",
   "inv_one",
   "HMul.hMul",
   "mul_one",
   "OfNat.ofNat",
   "congrArg"],
  "name": "div_one",
  "constType": "‚àÄ {G : Type u_3} [inst : DivInvOneMonoid G] (a : G), a / 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Set",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "EMetric.infEdist",
   "congrArg",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "EDist.edist",
   "dist_edist",
   "funext",
   "Dist.dist",
   "EMetric.infEdist.eq_1",
   "ENNReal.toReal",
   "id",
   "Metric.infDist",
   "iInf",
   "Eq.mpr",
   "Metric.infDist.eq_1",
   "iInf_subtype'",
   "edist_ne_top",
   "ENNReal.toReal_iInf"],
  "name": "Metric.infDist_eq_iInf",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±}, Metric.infDist x s = ‚®Ö y, dist x ‚Üëy",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "FiniteDimensional",
  "constType":
  "(K : Type u_1) ‚Üí (V : Type u_2) ‚Üí [inst : DivisionRing K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [_root_.Module K V] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "mul_neg",
   "HMul.hMul",
   "HPow.hPow",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "‚àÄ {R : Type u_2} [inst : CommRing R] (a‚ÇÅ : R) (a‚ÇÇ : ‚Ñï) {a‚ÇÉ b : R}, -a‚ÇÉ = b ‚Üí -(a‚ÇÅ ^ a‚ÇÇ * a‚ÇÉ) = a‚ÇÅ ^ a‚ÇÇ * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Encodable.encode",
  "constType": "{Œ± : Type u_1} ‚Üí [self : Encodable Œ±] ‚Üí Œ± ‚Üí ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "GT.gt",
   "Subtype.val",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball._proof_3",
   "Set.Elem",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius",
   "funext",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius_strictanti",
   "Eq.symm",
   "Eq.ndrec",
   "And.left",
   "Nat.casesAuxOn",
   "Exists.choose_spec",
   "NNReal",
   "Prod.snd",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball",
   "Unit",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "zero_add",
   "HasSubset.Subset",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball.eq_def",
   "NNDist.nndist",
   "id",
   "Eq.mpr",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball.match_1",
   "Exists.choose.congr_simp",
   "Eq.mp",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_radius.congr_simp",
   "NNReal.toReal",
   "Set.Countable",
   "Dense",
   "Prod.fst",
   "congrArg",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball_decreasing._simp_1_4",
   "congr",
   "Dist.dist",
   "Denumerable.ofNat",
   "Not",
   "Set",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball._proof_1",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "lt_add_one",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_sub_closedball_not_belong",
   "LE.le",
   "antitone_nat_of_succ_le",
   "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.exists_pos_dist",
   "TopologicalSpace.SeparableSpace.exists_countable_dense"],
  "name":
  "_private.SphericalCompleteness.Dense.0.SphericallyCompleteSpace.fuck_chain_of_ball_decreasing",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [hiud : IsUltrametricDist Œ±]\n  [hŒ± : SphericallyCompleteSpace.IsSphericallyDense Œ±] [nemp : Nonempty Œ±] [hsep : TopologicalSpace.SeparableSpace Œ±]\n  (hŒ±' : Denumerable ‚Üë‚ãØ.choose),\n  Antitone fun n ‚Ü¶\n    Metric.closedBall (SphericallyCompleteSpace.fuck_chain_of_ball‚úù hŒ±' n).1\n      ‚Üë(SphericallyCompleteSpace.fuck_chain_of_ball‚úù¬π hŒ±' n).2",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congrArg",
  "constType":
  "‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ a‚ÇÇ : Œ±} (f : Œ± ‚Üí Œ≤), a‚ÇÅ = a‚ÇÇ ‚Üí f a‚ÇÅ = f a‚ÇÇ",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "binderNameHint", "Mathlib.Tactic.Push.not_exists", "propext"],
  "name": "Mathlib.Tactic.Push.not_exists._simp_1",
  "constType":
  "‚àÄ {Œ± : Sort u_1} (s : Œ± ‚Üí Prop), (¬¨Exists s) = ‚àÄ (x : Œ±), binderNameHint x s ¬¨s x",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Iff.rfl", "setOf"],
  "name": "Set.mem_setOf",
  "constType": "‚àÄ {Œ± : Type u} {a : Œ±} {p : Œ± ‚Üí Prop}, a ‚àà {x | p x} ‚Üî p a",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_2",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Classical.propDecidable",
   "Iff.mp",
   "HMul.hMul",
   "GT.gt",
   "GE.ge",
   "Subtype.val",
   "HDiv.hDiv",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_2",
   "not_false_eq_true",
   "forall_congr",
   "funext",
   "norm_zero",
   "le_mul_inv_iff‚ÇÄ'",
   "Norm.norm",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_3",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_4",
   "Exists.casesOn",
   "norm_pos_iff",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_6",
   "eq_false",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Top.top",
   "zero_smul",
   "Eq.mpr",
   "setOf",
   "lp",
   "Eq.mp",
   "congrArg",
   "congr",
   "Not",
   "PreLp",
   "Inv.inv",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_5",
   "Set",
   "OfNat.ofNat",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
   "LT.lt",
   "norm_smul",
   "ENNReal",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Ne",
   "dite"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._proof_4",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_1) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] (c : ùïú) {x : ‚Ü•(lp E ‚ä§)},\n  x ‚àà {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ} ‚Üí c ‚Ä¢ x ‚àà {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ}",
  "constCategory": "Theorem"},
 {"references": ["Subtype.property"],
  "name": "Subtype.prop",
  "constType": "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (x : Subtype p), p ‚Üëx",
  "constCategory": "Theorem"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ‚Ñï",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Topology.MetricSpace.Defs.0.nndist_eq_zero._simp_1_1",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "NNDist.nndist",
   "NNReal",
   "NNReal.toReal",
   "OfNat.ofNat",
   "dist_eq_zero._simp_1",
   "congrArg"],
  "name": "nndist_eq_zero",
  "constType":
  "‚àÄ {Œ≥ : Type w} [inst : MetricSpace Œ≥] {x y : Œ≥}, nndist x y = 0 ‚Üî x = y",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "RingHom.id",
   "LinearMap.range",
   "Subtype.property",
   "Membership.mem",
   "LE.le",
   "Subtype.val",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] (E : Type u_3) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_1) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ]\n  (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (M : Submodule ùïú E‚ÇÄ) (hc : LinearMap.range f ‚â§ M) (x x_1 : ‚Ü•(LinearMap.range f)),\n  ‚ü®‚Üë(x + x_1), ‚ãØ‚ü© = ‚ü®‚Üë(x + x_1), ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["IsLinearMap.mk'",
   "Eq.trans",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
   "Mathlib.Tactic.Contrapose.contrapose‚ÇÑ",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "LinearMap.toAddHom",
   "HMul.hMul",
   "eq_true",
   "Submodule.span",
   "heq_of_eq",
   "Submodule.mem_sup_left",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_1",
   "RingHom.id",
   "eq_of_heq",
   "Submodule.mem_span_singleton",
   "forall_congr",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "AddHom.toFun",
   "Eq.ndrec",
   "And.left",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_4",
   "Exists.choose_spec",
   "Norm.norm",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "And.right",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop",
   "add_zero",
   "IsBoundedLinearMap.toContinuousLinearMap._proof_1",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_2",
   "map_add",
   "HSMul.hSMul",
   "id",
   "zero_smul",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_1",
   "Eq.mp",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_boundedlinear",
   "IsBoundedLinearMap.toLinearMap._proof_1",
   "DFunLike.coe",
   "Submodule.zero_mem",
   "congrArg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1._simp_2",
   "Subtype.prop",
   "Submodule.mem_sup",
   "congr",
   "eq_and_eq_of_add_eq_add_of_not_mem_submodule_span_singleton",
   "IsLinearMap.map_add",
   "propext",
   "Not",
   "Set.Nonempty",
   "Set",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
   "Submodule.add_eq_sup",
   "ContinuousLinearMap.mk.congr_simp",
   "Exists.choose",
   "AddHom.mk.congr_simp",
   "OfNat.ofNat",
   "IsBoundedLinearMap.toLinearMap",
   "HAdd.hAdd",
   "LT.lt",
   "Max.max",
   "and_self",
   "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
   "IsLinearMap.map_smul",
   "of_eq_true",
   "LE.le",
   "LinearMap.mk.congr_simp",
   "smul_eq_zero_iff_left"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_codim_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (D : Submodule ùïú E),\n  ‚àÄ a ‚àâ D,\n    ‚àÄ (F : Type u_3) [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ùïú F]\n      [hsc : SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) (ùí∞ : Set (E ‚ÜíL[ùïú] F)),\n      ùí∞.Nonempty ‚Üí\n        ‚àÄ (Œµ : ‚Üëùí∞ ‚Üí ‚Ñù),\n          (‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) ‚Üí\n            (‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V)) ‚Üí\n              (‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ) ‚Üí\n                ‚àÉ T,\n                  (‚àÄ (x : ‚Ü•D), T ‚ü®‚Üëx, ‚ãØ‚ü© = S x) ‚àß\n                    ‚àÄ (U : ‚Üëùí∞) (x : E) (hx : x ‚àà D + ùïú ‚àô a), ‚ÄñT ‚ü®x, hx‚ü© - ‚ÜëU x‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ProperSpace.isCompact_closedBall",
  "constType":
  "‚àÄ {Œ± : Type u} {inst : PseudoMetricSpace Œ±} [self : ProperSpace Œ±] (x : Œ±) (r : ‚Ñù), IsCompact (Metric.closedBall x r)",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "‚àÄ {Œ± : Sort u_2} {a b c : Œ±}, a = c ‚Üí b = c ‚Üí a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Set.not_nonempty_iff_eq_empty",
   "Set.Nonempty",
   "Set",
   "EmptyCollection.emptyCollection",
   "propext"],
  "name": "Set.not_nonempty_iff_eq_empty._simp_1",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, (¬¨s.Nonempty) = (s = ‚àÖ)",
  "constCategory": "Theorem"},
 {"references": ["not_le_of_gt"],
  "name": "LT.lt.not_ge",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a < b ‚Üí ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "FunLike", "DFunLike.coe"],
  "name": "LinearMap.mem_range_self",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] (f : F) (x : M), f x ‚àà LinearMap.range f",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "mul_pos_iff_of_pos_right",
   "Inv.inv",
   "Eq.trans",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "iff_self",
   "of_eq_true",
   "Iff.mpr",
   "inv_pos",
   "propext"],
  "name": "div_pos_iff_of_pos_right",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Semifield Œ±] [inst_1 : LinearOrder Œ±] [IsStrictOrderedRing Œ±] {a b : Œ±},\n  0 < b ‚Üí (0 < a / b ‚Üî 0 < a)",
  "constCategory": "Theorem"},
 {"references": ["HDiv.hDiv", "id", "Eq.mpr", "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.eq_div_of_subst",
  "constType":
  "‚àÄ {M : Type u_1} [inst : Div M] {l l_n l_d n d : M}, l = l_n / l_d ‚Üí l_n = n ‚Üí l_d = d ‚Üí l = n / d",
  "constCategory": "Theorem"},
 {"references":
  ["mul_div_left_comm",
   "HDiv.hDiv",
   "mul_comm",
   "Eq.symm",
   "id",
   "HMul.hMul",
   "mul_assoc",
   "Eq.mpr",
   "one_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "CancelDenoms.div_subst",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Field Œ±] {n1 n2 k e1 e2 t1 : Œ±}, n1 * e1 = t1 ‚Üí n2 / e2 = 1 ‚Üí n1 * n2 = k ‚Üí k * (e1 / e2) = t1",
  "constCategory": "Theorem"},
 {"references": ["forall_exists_index", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {q : (‚àÉ x, p x) ‚Üí Prop}, (‚àÄ (h : ‚àÉ x, p x), q h) = ‚àÄ (x : Œ±) (h : p x), q ‚ãØ",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset", "Set", "Set.setOf_subset_setOf", "propext", "setOf"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} {p q : Œ± ‚Üí Prop}, ({a | p a} ‚äÜ {a | q a}) = ‚àÄ (a : Œ±), p a ‚Üí q a",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.isBoundedLinearMap",
   "IsBoundedLinearMap.toContinuousLinearMap",
   "RingHom.id",
   "ContinuousLinearMap.comp"],
  "name": "IsBoundedLinearMap.comp",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ùïú F]\n  {G : Type u_4} [inst_5 : SeminormedAddCommGroup G] [inst_6 : NormedSpace ùïú G] {f : E ‚Üí F} {g : F ‚Üí G},\n  IsBoundedLinearMap ùïú g ‚Üí IsBoundedLinearMap ùïú f ‚Üí IsBoundedLinearMap ùïú (g ‚àò f)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Set",
   "_private.Mathlib.Order.SetNotation.0.Set.mem_iUnion.match_1_1",
   "Membership.mem",
   "Eq.symm",
   "_private.Mathlib.Order.SetNotation.0.Set.mem_iUnion.match_1_3",
   "Set.iUnion",
   "Set.range"],
  "name": "Set.mem_iUnion",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, x ‚àà ‚ãÉ i, s i ‚Üî ‚àÉ i, x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "AddLeftReflectLT",
   "AddLeftStrictMono",
   "lt_add_iff_pos_right",
   "OfNat.ofNat",
   "propext"],
  "name": "lt_mul_iff_one_lt_right'._simp_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : LT Œ±] [AddLeftStrictMono Œ±] [AddLeftReflectLT Œ±] (a : Œ±) {b : Œ±},\n  (a < a + b) = (0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Subtype.val",
   "Subspace"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_9",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (z : ‚Ü•(ùïú ‚àô x ‚äî F)), ‚àÉ y ‚àà ùïú ‚àô x, ‚àÉ z_1 ‚àà F, y + z_1 = ‚Üëz",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE.le",
  "constType": "{Œ± : Type u} ‚Üí [self : LE Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["isometry_iff_dist_eq", "Dist.dist", "Iff.mp", "Isometry"],
  "name": "Isometry.dist_eq",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  Isometry f ‚Üí ‚àÄ (x y : Œ±), dist (f x) (f y) = dist x y",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "PreLp",
   "lp",
   "Membership.mem",
   "Top.top",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Submodule.toAddSubgroup"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_3",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E], (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup.Normal",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Array.getD",
   "_private.Init.Prelude.0.Lean.Syntax.setKind.match_1"],
  "name": "Lean.Syntax.getArg",
  "constType": "Syntax ‚Üí ‚Ñï ‚Üí Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_5",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ‚àà p), (‚ü®x, h‚ü© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "Set.mem_singleton_iff._simp_1",
  "constType": "‚àÄ {Œ± : Type u} {a b : Œ±}, (a ‚àà {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.OrthComp",
   "Eq.trans",
   "zero_sub",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "RingHom.id",
   "Eq.symm",
   "HSub.hSub",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_4",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.MOrth",
   "And.left",
   "LinearMap.ker",
   "Exists.choose_spec",
   "Norm.norm",
   "Neg.neg",
   "And.right",
   "Mathlib.Tactic.Abel.term_add_constg",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "zero_add",
   "sup_of_le_left",
   "SetLike.coe",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Int.negOfNat",
   "id",
   "norm_neg",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_3",
   "Eq.mpr",
   "SphericallyCompleteSpace.SOrth",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "one_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "dist_eq_norm",
   "IsUltrametricDist.norm_add_le_max",
   "Submodule.nonempty",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "le_trans",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "SphericallyCompleteSpace.OrthComp._proof_2",
   "Mathlib.Meta.NormNum.isInt_neg",
   "DFunLike.coe",
   "Subspace",
   "Metric.le_infDist",
   "map_sub",
   "congrArg",
   "dist_zero",
   "ZeroMemClass.zero_mem",
   "congr",
   "Dist.dist",
   "Metric.infDist",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_1",
   "Metric.infDist_le_dist_of_mem",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "SphericallyCompleteSpace.sorth_orthcomp._simp_1_2",
   "dist_comm",
   "Set",
   "SphericallyCompleteSpace.sorth_symm",
   "zero_le_one",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "Exists.choose",
   "Mathlib.Tactic.Abel.term_neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Max.max",
   "of_eq_true",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_iff",
   "eq_of_le_of_ge"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [inst_3 : SphericallyCompleteSpace ‚Ü•F],\n  SphericallyCompleteSpace.SOrth ùïú F (SphericallyCompleteSpace.OrthComp ùïú F)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Eq.trans",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Metric.isBounded_closedBall",
   "Metric.diam",
   "eq_true",
   "HMul.hMul",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "Metric.diam_nonneg",
   "DenselyNormedField.lt_norm_lt",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Ring.sub_pf",
   "Norm.norm",
   "NNReal",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
   "Exists.casesOn",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast_zero",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "diam_le_radius_of_ultrametric",
   "Eq.mp",
   "NNReal.toReal",
   "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_3",
   "Metric.dist_le_diam_of_mem",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "dist_self_add_left",
   "congrArg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "dist_self",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Metric.closedBall",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "le_of_lt",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "eq_of_le_of_ge",
   "And.casesOn"],
  "name": "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField",
  "constType":
  "‚àÄ (Œ± : Type u_1) [dnf : DenselyNormedField Œ±] [hiud : IsUltrametricDist Œ±],\n  SphericallyCompleteSpace.IsSphericallyDense Œ±",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name": "not_lt._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, (¬¨a < b) = (b ‚â§ a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Submodule.toAddSubmonoid",
  "constType":
  "{R : Type u} ‚Üí\n  {M : Type v} ‚Üí\n    [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : _root_.Module R M] ‚Üí Submodule R M ‚Üí AddSubmonoid M",
  "constCategory": "Definition"},
 {"references": ["trivial", "propext"],
  "name": "eq_true",
  "constType": "‚àÄ {p : Prop}, p ‚Üí p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "csInf_le_csInf",
   "HasSubset.Subset",
   "Set",
   "OrderBot.bddBelow"],
  "name": "csInf_le_csInf'",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Œ±] {s t : Set Œ±}, t.Nonempty ‚Üí t ‚äÜ s ‚Üí sInf s ‚â§ sInf t",
  "constCategory": "Theorem"},
 {"references": ["Set", "Inter.inter", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_inter_iff",
  "constType":
  "‚àÄ {Œ± : Type u} (x : Œ±) (a b : Set Œ±), x ‚àà a ‚à© b ‚Üî x ‚àà a ‚àß x ‚àà b",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0_prop._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "neg_zero",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "sub_zero",
  "constType":
  "‚àÄ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.nonempty_closedBall",
   "Metric.closedBall",
   "Set.Nonempty",
   "LE.le",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_8",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, (Metric.closedBall x Œµ).Nonempty = (0 ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort u_1} {f : Œπ ‚Üí Œ±} {x : Œ±}, (x ‚àà Set.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["Dist.dist", "LE.le", "NNReal", "NNReal.toReal", "Iff.rfl"],
  "name": "dist_le_coe",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {c : NNReal}, dist x y ‚â§ ‚Üëc ‚Üî nndist x y ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "zero_add", "LE.le.trans_eq", "le_self_add", "OfNat.ofNat"],
  "name": "zero_le",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddZeroClass Œ±] [inst_1 : LE Œ±] [CanonicallyOrderedAdd Œ±] (a : Œ±), 0 ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Subtype.ext", "Subtype.val"],
  "name": "Subtype.coe_eta",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (a : { a // p a }) (h : p ‚Üëa), ‚ü®‚Üëa, h‚ü© = a",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_4",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), (a ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty", "Set", "Iff.mpr", "Set.nonempty_coe_sort", "Set.Elem"],
  "name": "Set.Nonempty.coe_sort",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, s.Nonempty ‚Üí Nonempty ‚Üës",
  "constCategory": "Theorem"},
 {"references":
  ["dist_self",
   "Norm.norm",
   "Dist.dist",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dist_zero_right",
   "OfNat.ofNat",
   "congrArg"],
  "name": "norm_zero",
  "constType": "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E], ‚Äñ0‚Äñ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["true_or",
   "Eq.trans",
   "Norm.norm",
   "Eq.mp",
   "Neg.neg",
   "norm_eq_of_norm_sub_lt_left._simp_1_1",
   "eq_true",
   "congrArg",
   "sub_eq_add_neg",
   "LT.lt",
   "HAdd.hAdd",
   "Max.max",
   "of_eq_true",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "norm_neg",
   "Eq.mpr",
   "IsUltrametricDist.norm_eq_of_add_norm_lt_max"],
  "name": "norm_eq_of_norm_sub_lt_left",
  "constType":
  "‚àÄ {S : Type u_1} [inst : SeminormedAddGroup S] [IsUltrametricDist S] {x y : S}, ‚Äñx - y‚Äñ < ‚Äñx‚Äñ ‚Üí ‚Äñx‚Äñ = ‚Äñy‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["Function.Injective.eq_iff", "Neg.neg", "neg_injective"],
  "name": "neg_inj",
  "constType":
  "‚àÄ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = -b ‚Üî a = b",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "Neg.neg",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.zpow'_neg",
   "OfNat.ofNat",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "mul_inv",
   "Prod.fst",
   "congrArg",
   "HDiv.hDiv",
   "congr",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div'",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (n : ‚Ñ§) (e : M) {t t_n t_d : Mathlib.Tactic.FieldSimp.NF M},\n  t.eval = t_n.eval / t_d.eval ‚Üí ((-n, e) ::·µ£ t).eval = t_n.eval / ((n, e) ::·µ£ t_d).eval",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Iff.mpr", "LE.le", "sup_eq_right"],
  "name": "sup_of_le_right",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, a ‚â§ b ‚Üí a ‚äî b = b",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.toReal_smul",
   "Norm.norm",
   "Set",
   "NNReal",
   "NNReal.toReal",
   "HMul.hMul",
   "OfNat.ofNat",
   "EMetric.infEdist",
   "congrArg",
   "NNNorm.nnnorm",
   "eq_self",
   "ENNReal",
   "of_eq_true",
   "HSMul.hSMul",
   "id",
   "Set.smulSet",
   "ENNReal.toReal",
   "Metric.infDist",
   "Ne",
   "Eq.mpr",
   "infEdist_smul‚ÇÄ"],
  "name": "infDist_smul‚ÇÄ",
  "constType":
  "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedDivisionRing ùïú] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : _root_.Module ùïú E] [NormSMulClass ùïú E] {c : ùïú},\n  c ‚â† 0 ‚Üí ‚àÄ (s : Set E) (x : E), Metric.infDist (c ‚Ä¢ x) (c ‚Ä¢ s) = ‚Äñc‚Äñ * Metric.infDist x s",
  "constCategory": "Theorem"},
 {"references":
  ["Inv.inv",
   "HMul.hMul",
   "Iff.rfl",
   "OfNat.ofNat",
   "le_mul_inv_iff‚ÇÄ",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "mul_comm",
   "Eq.mpr",
   "PosMulReflectLT.toMulPosReflectLT",
   "propext"],
  "name": "le_mul_inv_iff‚ÇÄ'",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : CommGroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a b c : G‚ÇÄ},\n  0 < c ‚Üí (a ‚â§ b * c‚Åª¬π ‚Üî c * a ‚â§ b)",
  "constCategory": "Theorem"},
 {"references": ["Metric.closedBall", "NNReal", "NNReal.toReal", "Metric.diam"],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.mk._flat_ctor",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±],\n  (‚àÄ (c : Œ±) (r : NNReal), Metric.diam (Metric.closedBall c ‚Üër) = ‚Üër) ‚Üí SphericallyCompleteSpace.IsSphericallyDense Œ±",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú], RingHomSurjective (RingHom.id ùïú)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id",
   "IsBoundedLinearMap.toContinuousLinearMap._proof_1",
   "IsBoundedLinearMap.toLinearMap"],
  "name": "IsBoundedLinearMap.toContinuousLinearMap",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : SeminormedAddCommGroup F] ‚Üí\n              [inst_4 : NormedSpace ùïú F] ‚Üí {f : E ‚Üí F} ‚Üí IsBoundedLinearMap ùïú f ‚Üí E ‚ÜíL[ùïú] F",
  "constCategory": "Definition"},
 {"references":
  ["Classical.choose_spec", "Set.Nonempty", "Set", "Membership.mem"],
  "name": "Set.Nonempty.some_mem",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±} (h : s.Nonempty), h.some ‚àà s",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "_private.Mathlib.Data.Set.Disjoint.0.Set.disjoint_iff_forall_ne._proof_1_1"],
  "name": "Set.disjoint_iff_forall_ne",
  "constType":
  "‚àÄ {Œ± : Type u} {s t : Set Œ±}, Disjoint s t ‚Üî ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà s ‚Üí ‚àÄ ‚¶Éb : Œ±‚¶Ñ, b ‚àà t ‚Üí a ‚â† b",
  "constCategory": "Theorem"},
 {"references":
  ["HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "NNReal.toReal",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.exists_norm_sub_lt",
   "DFunLike.coe",
   "Subtype.val",
   "Subtype.prop",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
   "HSub.hSub",
   "QuotientAddGroup.mk'",
   "PreLp",
   "Exists.choose_spec",
   "Norm.norm",
   "Set",
   "And.right",
   "NNReal",
   "Submodule.toAddSubgroup",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Metric.closedBall",
   "StrictAnti",
   "ENNReal",
   "Antitone",
   "Top.top",
   "id"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.mk_eq_and_norm_sub_lt",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_2) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] [inst_3 : ‚àÄ (i : ‚Ñï), IsUltrametricDist (E i)]\n  {c : ‚Ñï ‚Üí ‚Ü•(lp E ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú E} {r : ‚Ñï ‚Üí NNReal} (hsr : StrictAnti r)\n  (hanti : Antitone fun i ‚Ü¶ Metric.closedBall (c i) ‚Üë(r i)) (i : ‚Ñï),\n  (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú E).toAddSubgroup)\n        ‚Üë(SphericallyCompleteSpace.quotient_mk_section‚úù E hsr hanti i) =\n      c i ‚àß\n    ‚Äñ‚Üë(SphericallyCompleteSpace.quotient_mk_section‚úù¬π E hsr hanti (i + 2)) -\n          ‚Üë(SphericallyCompleteSpace.quotient_mk_section‚úù¬≤ E hsr hanti (i + 1))‚Äñ <\n      ‚Üë(r i)",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Set.singleton_subset_iff",
   "propext"],
  "name": "Set.singleton_subset_iff._simp_1",
  "constType": "‚àÄ {Œ± : Type u} {a : Œ±} {s : Set Œ±}, ({a} ‚äÜ s) = (a ‚àà s)",
  "constCategory": "Theorem"},
 {"references": ["RingHom.id"],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_3} [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (E‚ÇÄ : Type u_2) [inst_3 : NormedAddCommGroup E‚ÇÄ] [inst_4 : NormedSpace ùïú E‚ÇÄ],\n  SemilinearMapClass (E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) (RingHom.id ùïú) E E‚ÇÄ",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Submodule.span_singleton_le_iff_mem._simp_1",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "le_iSup_iff",
   "Submodule.span_singleton_le_iff_mem",
   "Submodule.span",
   "congrArg",
   "iSup",
   "iff_self",
   "of_eq_true",
   "forall_congr",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "Submodule.mem_iSup",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {Œπ : Sort u_9} (p : Œπ ‚Üí Submodule R M) {m : M}, m ‚àà ‚®Ü i, p i ‚Üî ‚àÄ (N : Submodule R M), (‚àÄ (i : Œπ), p i ‚â§ N) ‚Üí m ‚àà N",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} ‚Üí {B : outParam (Type u_2)} ‚Üí [self : SetLike A B] ‚Üí A ‚Üí Set B",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearIsometry.toLinearMap",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n          {E : Type u_11} ‚Üí\n            {E‚ÇÇ : Type u_12} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : _root_.Module R E] ‚Üí [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["not_le_of_gt", "Not", "LT.lt", "LE.le", "lt_of_not_ge"],
  "name": "lt_iff_not_ge",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, a < b ‚Üî ¬¨b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_2",
   "Set.pi",
   "Membership.mem",
   "Iff.mp",
   "Classical.propDecidable",
   "NNReal.toReal",
   "Set.iInter",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_4",
   "congrArg",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Subtype.prop",
   "eq_of_heq",
   "Dist.dist",
   "forall_congr",
   "Eq.symm",
   "Set.mem_iInter",
   "closedBall_pi",
   "dite_cond_eq_false",
   "Eq.ndrec",
   "Not",
   "dist_self",
   "Exists.choose_spec",
   "Set",
   "NNReal",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_3",
   "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_3",
   "Exists.choose",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_1",
   "Eq.casesOn",
   "OfNat.ofNat",
   "Set.univ",
   "Metric.closedBall",
   "eq_self",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_2",
   "HasSubset.Subset",
   "of_eq_true",
   "dite_cond_eq_true",
   "eq_false",
   "Antitone",
   "NNDist.nndist",
   "LE.le",
   "id",
   "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_4",
   "Eq.mpr",
   "dite"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace",
  "constType":
  "‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ] {E : Œπ ‚Üí Type u_2} [inst_1 : (i : Œπ) ‚Üí PseudoMetricSpace (E i)]\n  [hh : ‚àÄ (i : Œπ), SphericallyCompleteSpace (E i)], SphericallyCompleteSpace ((i : Œπ) ‚Üí E i)",
  "constCategory": "Theorem"},
 {"references":
  ["IsOpen.isClosed_compl",
   "Disjoint.subset_compl_right",
   "Disjoint.mono_left",
   "IsOpen",
   "HasCompl.compl",
   "Set",
   "Disjoint",
   "disjoint_compl_left",
   "closure_minimal",
   "closure"],
  "name": "Disjoint.closure_left",
  "constType":
  "‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, Disjoint s t ‚Üí IsOpen t ‚Üí Disjoint (closure s) t",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Nat.cast_lt",
   "Nat.cast",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "Iff.mpr",
   "_private.Mathlib.Tactic.NormNum.Ineq.0.Mathlib.Meta.NormNum.isNat_lt_true.match_1_1",
   "Iff.mp",
   "Nat.ble"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedRing Œ±] [CharZero Œ±] {a b : Œ±} {a' b' : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNat a a' ‚Üí Mathlib.Meta.NormNum.IsNat b b' ‚Üí b'.ble a' = false ‚Üí a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Lean.Omega.Int.add_le_zero_iff_le_neg'",
   "Eq.trans",
   "Eq.mp",
   "Lean.Omega.Coeffs",
   "Decidable.decide",
   "congrArg",
   "Int.eq_iff_le_and_ge",
   "Lean.Omega.Int.add_nonneg_iff_neg_le'",
   "Decidable.decide.congr_simp",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "propext",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "and_comm",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addEquality_sat",
  "constType":
  "‚àÄ {c : ‚Ñ§} {x y : Omega.Coeffs}, c + x.dot y = 0 ‚Üí { lowerBound := some (-c), upperBound := some (-c) }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["Monotone.map_max",
   "monotone_mul_left_of_nonneg",
   "LE.le",
   "HMul.hMul",
   "OfNat.ofNat"],
  "name": "mul_max_of_nonneg",
  "constType":
  "‚àÄ {R : Type u} [inst : Semiring R] [inst_1 : LinearOrder R] {a : R} [PosMulMono R] (b c : R),\n  0 ‚â§ a ‚Üí a * max b c = max (a * b) (a * c)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "ContinuousLinearMap.le_of_opNorm_le",
   "Subtype.val",
   "RingHom.id",
   "funext",
   "forall_congr",
   "eq_of_heq",
   "Eq.symm",
   "SphericallyCompleteSpace.hahn_banach._simp_1_3",
   "Eq.ndrec",
   "HEq.casesOn",
   "And.left",
   "Norm.norm",
   "outParam",
   "And.right",
   "SphericallyCompleteSpace.OrthProj",
   "ContinuousLinearMap.norm_def",
   "true_and",
   "SphericallyCompleteSpace.norm_OrthProj_le_one",
   "Iff.mpr",
   "SetLike.coe_eq_coe",
   "lowerBounds",
   "id",
   "Eq.mpr",
   "one_mul",
   "setOf",
   "Eq.mp",
   "le_trans",
   "SphericallyCompleteSpace.hahn_banach._simp_1_4",
   "DFunLike.coe",
   "ContinuousLinearMap.opNorm_nonneg",
   "ContinuousLinearMap.comp",
   "congrArg",
   "csInf_le_csInf",
   "Subtype.prop",
   "Subtype.property",
   "InfSet.sInf",
   "SphericallyCompleteSpace.OrthProj_id",
   "PosMulMono.mul_le_mul_of_nonneg_left",
   "ContinuousLinearMap.le_opNorm",
   "ContinuousLinearMap.comp_apply",
   "Set",
   "SphericallyCompleteSpace.hahn_banach._simp_1_2",
   "Eq.casesOn",
   "OfNat.ofNat",
   "LE.le",
   "ContinuousLinearMap.opNorm_le_iff",
   "eq_of_le_of_ge"],
  "name": "SphericallyCompleteSpace.hahn_banach",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [IsUltrametricDist E] (D : Submodule ùïú E) {F : Type u_3} [inst_4 : NormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [IsUltrametricDist F] [hd : SphericallyCompleteSpace ‚Ü•D] (f : ‚Ü•D ‚ÜíL[ùïú] F),\n  ‚àÉ f', (‚àÄ (v : E) (hv : v ‚àà D), f' v = f ‚ü®v, hv‚ü©) ‚àß ‚Äñf'‚Äñ = ‚Äñf‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Set.iInter",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "le_of_not_gt",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NNReal",
   "Filter.atTop",
   "Antitone",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "StrictMono",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "lt_of_not_ge",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_1",
   "Mathlib.Tactic.Ring.neg_zero",
   "dist_comm",
   "Set",
   "StrictMono.tendsto_atTop",
   "HPow.hPow",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "Nat.cast_add",
   "Metric.closedBall",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius",
   "antitone_nat_of_succ_le",
   "dite",
   "neg_neg_of_pos",
   "And.casesOn",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Int.rawCast",
   "HMul.hMul",
   "GE.ge",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Filter.Tendsto",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_4",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_5",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Mathlib.Tactic.Ring.atom_pf",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_2",
   "Iff.mpr",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Eq.mp",
   "Metric.mem_closedBall",
   "NNReal.toReal",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "eventually_stable_or_exists_strictanti_of_antitone",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Function.comp",
   "StrictMono.monotone",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "Or.casesOn",
   "StrictAnti",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "Filter.tendsto_atTop_atTop_iff_of_monotone",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius._simp_1_3"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [iud : IsUltrametricDist Œ±],\n  SphericallyCompleteSpace Œ± ‚Üî\n    ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n      StrictAnti ri ‚Üí\n        (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["exists_apply_eq_apply", "eq_true"],
  "name": "exists_apply_eq_apply._simp_1",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} (f : Œ± ‚Üí Œ≤) (a' : Œ±), (‚àÉ a, f a = f a') = True",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Exists.choose"],
  "name": "Exists.choose.congr_simp",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p p_1 : Œ± ‚Üí Prop} (e_p : p = p_1) (P : ‚àÉ a, p a), P.choose = ‚ãØ.choose",
  "constCategory": "Theorem"},
 {"references": ["norm_eq_zero", "Norm.norm", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_16",
  "constType":
  "‚àÄ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, (‚Äña‚Äñ = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["dist_comm",
   "Eq.mp",
   "Set",
   "NNReal",
   "Membership.mem",
   "NNReal.toReal",
   "diam_le_radius_of_ultrametric._proof_1_1",
   "OfNat.ofNat",
   "congrArg",
   "Metric.closedBall",
   "Max.max",
   "Subtype.prop",
   "IsUltrametricDist.dist_triangle_max",
   "LE.le",
   "Dist.dist",
   "Metric.diam_le_of_forall_dist_le"],
  "name": "diam_le_radius_of_ultrametric",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [hiud : IsUltrametricDist Œ±] (z : Œ±) (r : NNReal),\n  Metric.diam (Metric.closedBall z ‚Üër) ‚â§ ‚Üër",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "Submodule.span",
   "Subtype.val",
   "Subspace",
   "congrArg",
   "Prod.fst",
   "Submodule.add_mem_sup",
   "Subtype.prop",
   "Submodule.mem_sup",
   "Subtype.coe_eta",
   "Eq.ndrec",
   "And.left",
   "Exists.choose_spec",
   "Set",
   "Submodule.add_eq_sup",
   "And.right",
   "Prod.snd",
   "Exists.choose",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "of_eq_true",
   "id",
   "Eq.mpr"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_15",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (t : ‚Ü•(ùïú ‚àô x + F)),\n  ‚ü®‚Üë(‚ãØ.mpr (fun z ‚Ü¶ (‚ü®‚ãØ.choose, ‚ãØ‚ü©, ‚ü®‚ãØ.choose, ‚ãØ‚ü©)) t).1 + ‚Üë(‚ãØ.mpr (fun z ‚Ü¶ (‚ü®‚ãØ.choose, ‚ãØ‚ü©, ‚ü®‚ãØ.choose, ‚ãØ‚ü©)) t).2, ‚ãØ‚ü© = t",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "bot_le", "eq_true", "Bot.bot"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LE Œ±] [inst_1 : OrderBot Œ±] {a : Œ±}, (‚ä• ‚â§ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_iInter", "Set.iInter", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_of_isometryEquiv._simp_1_2",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort v} {x : Œ±} {s : Œπ ‚Üí Set Œ±}, (x ‚àà ‚ãÇ i, s i) = ‚àÄ (i : Œπ), x ‚àà s i",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_2",
  "constType":
  "‚àÄ {a0 a1 a2 : ‚Ñ§} {t : List ‚Ñ§}, (Omega.LinearCombo.coordinate 2).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: t)) = a2",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le", "Nat.add_comm", "Nat.le_add_right"],
  "name": "Nat.le_add_left",
  "constType": "‚àÄ (n m : ‚Ñï), n ‚â§ m + n",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.imm_ext_nonempty._simp_1_8",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Syntax.getKind", "BEq.beq"],
  "name": "Lean.Syntax.isOfKind",
  "constType": "Syntax ‚Üí SyntaxNodeKind ‚Üí Bool",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval.match_1",
   "List.map",
   "Mathlib.Tactic.FieldSimp.NF",
   "List.prod",
   "Mathlib.Tactic.FieldSimp.zpow'"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval",
  "constType":
  "{M : Type u_1} ‚Üí [GroupWithZero M] ‚Üí Mathlib.Tactic.FieldSimp.NF M ‚Üí M",
  "constCategory": "Definition"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.hahn_banach._simp_1_4",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 ‚â§ ‚Äña‚Äñ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "PreLp",
   "Eq.trans",
   "Norm.norm",
   "HasQuotient.Quotient",
   "lp",
   "Membership.mem",
   "LinearIsometry.norm_map",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "DFunLike.coe",
   "congrArg",
   "eq_self",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "ENNReal",
   "of_eq_true",
   "RingHom.id",
   "Top.top"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_6",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E), ‚Äñ(SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) x‚Äñ = ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["map_add"],
  "name": "ContinuousLinearMap.map_add",
  "constType":
  "‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : _root_.Module R‚ÇÅ M‚ÇÅ] [inst_7 : _root_.Module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)\n  (x y : M‚ÇÅ), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "Membership.mem",
   "SphericallyCompleteSpace.Orth",
   "SphericallyCompleteSpace.MOrth",
   "Subspace",
   "SphericallyCompleteSpace.sorth_iff_forall_orth._simp_1_2",
   "congrArg"],
  "name": "SphericallyCompleteSpace.sorth_iff_forall_orth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (F1 F2 : Subspace ùïú E),\n  SphericallyCompleteSpace.SOrth ùïú F1 F2 ‚Üî ‚àÄ x ‚àà F1, ‚àÄ y ‚àà F2, x ‚üÇ[ùïú] y",
  "constCategory": "Theorem"},
 {"references": ["WithTop.untopD", "NNReal", "OfNat.ofNat"],
  "name": "ENNReal.toNNReal",
  "constType": "ENNReal ‚Üí NNReal",
  "constCategory": "Definition"},
 {"references": ["Metric.closedBall", "NNReal", "NNReal.toReal", "Metric.diam"],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.recOn",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    {motive : SphericallyCompleteSpace.IsSphericallyDense Œ± ‚Üí Sort u} ‚Üí\n      (t : SphericallyCompleteSpace.IsSphericallyDense Œ±) ‚Üí\n        ((spherically_dense : ‚àÄ (c : Œ±) (r : NNReal), Metric.diam (Metric.closedBall c ‚Üër) = ‚Üër) ‚Üí motive ‚ãØ) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "HMul.hMul",
   "Int.rawCast",
   "Int.cast",
   "OfNat.ofNat",
   "Int.cast_neg",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Int.cast_one",
   "neg_mul",
   "Int.negOfNat",
   "Eq.ndrec",
   "one_mul"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "‚àÄ {R : Type u_2} [inst : CommRing R] {a b : R}, (Int.negOfNat 1).rawCast * a = b ‚Üí -a = b",
  "constCategory": "Theorem"},
 {"references": ["Nat.lt_add_one"],
  "name": "Nat.lt_succ_self",
  "constType": "‚àÄ (n : ‚Ñï), n < n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "mul_inv_cancel‚ÇÄ",
   "Inv.inv",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "inv_inv",
   "LT.lt.ne'",
   "not_false_eq_true",
   "of_eq_true",
   "eq_false",
   "congr",
   "id",
   "Eq.mpr",
   "LT.lt.le",
   "lt_of_mul_lt_mul_left"],
  "name": "inv_pos",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a : G‚ÇÄ}, 0 < a‚Åª¬π ‚Üî 0 < a",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "HSMul.hSMul"],
  "name": "Mathlib.Tactic.Abel.termg",
  "constType": "{Œ± : Type u_1} ‚Üí [AddCommGroup Œ±] ‚Üí ‚Ñ§ ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Metric.exists_ball_subset_ball",
   "IsOpen",
   "HasSubset.Subset",
   "Set",
   "Iff.mpr",
   "Membership.mem",
   "Metric.ball",
   "GT.gt",
   "Metric.isOpen_iff",
   "OfNat.ofNat"],
  "name": "Metric.isOpen_ball",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, IsOpen (Metric.ball x Œµ)",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.SimpLemmas.0.and_imp.match_1_1"],
  "name": "and_imp",
  "constType": "‚àÄ {a b c : Prop}, a ‚àß b ‚Üí c ‚Üî a ‚Üí b ‚Üí c",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "exists_bijective_subseq_of_finite_duplication._proof_1_7",
   "_private.SphericalCompleteness.External.Sequence.0.ebsofd._proof_2",
   "GT.gt",
   "congrArg",
   "strictMono_nat_of_lt_succ",
   "funext",
   "forall_congr",
   "exists_bijective_subseq_of_finite_duplication._simp_1_4",
   "injective_of_lt_imp_ne",
   "Eq.ndrec",
   "Not",
   "Exists.choose_spec",
   "exists_bijective_subseq_of_finite_duplication._proof_1_8",
   "Function.comp",
   "StrictMono.monotone",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Max.max",
   "id",
   "Eq.mpr",
   "_private.SphericalCompleteness.External.Sequence.0.ebsofd",
   "Ne",
   "Exists.choose.congr_simp",
   "Function.Injective",
   "StrictMono"],
  "name": "exists_bijective_subseq_of_finite_duplication",
  "constType":
  "‚àÄ {Œ± : Type u_1} (seq : ‚Ñï ‚Üí Œ±),\n  (‚àÄ (n : ‚Ñï), ‚àÉ N, ‚àÄ i > N, seq n ‚â† seq i) ‚Üí ‚àÉ œÜ, StrictMono œÜ ‚àß Function.Injective (seq ‚àò œÜ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u ‚Üí Type u",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "zero_add",
   "zero_nsmul",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "succ_nsmul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "one_nsmul",
  "constType": "‚àÄ {M : Type u_2} [inst : AddMonoid M] (a : M), 1 ‚Ä¢ a = a",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Array.mkArray3"],
  "name": "Lean.Syntax.node3",
  "constType":
  "SourceInfo ‚Üí SyntaxNodeKind ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow.hPow",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HPow Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "_private.Mathlib.Logic.Basic.0.exists_exists_eq_and.match_1_1",
   "_private.Mathlib.Logic.Basic.0.exists_exists_eq_and.match_1_3",
   "Eq.symm"],
  "name": "exists_exists_eq_and",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {f : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Prop}, (‚àÉ b, (‚àÉ a, f a = b) ‚àß p b) ‚Üî ‚àÉ a, p (f a)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "le_trans", "LE.le", "le_sup_left"],
  "name": "le_sup_of_le_left",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b c : Œ±}, c ‚â§ a ‚Üí c ‚â§ a ‚äî b",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "HMul.hMul", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' ‚Üí b = b' ‚Üí a' * b' = c ‚Üí a * b = c",
  "constCategory": "Theorem"},
 {"references": ["IsLinearMap.mk'", "IsBoundedLinearMap.toLinearMap._proof_1"],
  "name": "IsBoundedLinearMap.toLinearMap",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : SeminormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : SeminormedAddCommGroup F] ‚Üí\n              [inst_4 : NormedSpace ùïú F] ‚Üí (f : E ‚Üí F) ‚Üí IsBoundedLinearMap ùïú f ‚Üí E ‚Üí‚Çó[ùïú] F",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Nat.recAux",
   "add_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "add_assoc",
   "Nat.cast_zero",
   "Nat.add_succ",
   "id",
   "Eq.mpr",
   "Nat.cast_succ"],
  "name": "Nat.cast_add",
  "constType":
  "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ‚Ñï), ‚Üë(m + n) = ‚Üëm + ‚Üën",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst",
   "not_lt._simp_1",
   "Mathlib.Tactic.FieldSimp.zpow'_one",
   "Metric.diam",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "eq_true",
   "sub_zero",
   "UniformSpace.complete_of_cauchySeq_tendsto",
   "_private.SphericalCompleteness.External.Complete.0.dcidx",
   "le_of_not_gt",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_4",
   "Eq.symm",
   "mul_comm",
   "abs",
   "Nat.ble",
   "Nat.ofNat_pos._simp_1",
   "Mathlib.Tactic.FieldSimp.NF.one_eq_eval",
   "congr_arg",
   "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._proof_1_17",
   "ne_of_gt",
   "ENNReal.inv_zpow'",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval‚ÇÇ",
   "ENNReal.coe_eq_zero._simp_1",
   "Filter.atTop",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_15",
   "eq_false",
   "Antitone",
   "ENNReal.coe_ne_top",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Eq.mpr",
   "Mathlib.Tactic.Ring.add_mul",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_8",
   "Not.intro",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_eval‚ÇÉ",
   "Mathlib.Meta.NormNum.isNat_le_true",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_13",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "le_mul_inv_iff‚ÇÄ",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Prod.fst",
   "inv_div",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Metric.tendsto_atTop'",
   "_private.SphericalCompleteness.External.Complete.0.dcidx_controlled_converge",
   "mul_one",
   "WithTop.coe_lt_coe",
   "HPow.hPow",
   "lt_of_lt_of_le",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "eq_self",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_3",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "Ne",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
   "Filter.Eventually",
   "false_and",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div",
   "Membership.mem",
   "Subtype.mk.congr_simp",
   "GT.gt",
   "GE.ge",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval",
   "Real.toNNReal_eq_zero._simp_1",
   "not_false_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_5",
   "forall_congr",
   "Mathlib.Tactic.Linarith.add_neg",
   "ENNReal.toReal",
   "Mathlib.Tactic.Ring.single_pow",
   "Filter.Tendsto",
   "Mathlib.Tactic.FieldSimp.subst_add",
   "Nat.mul",
   "Metric.diam_closedBall",
   "Mathlib.Meta.NormNum.isNat_eq_false",
   "lt_of_le_of_lt",
   "Mathlib.Tactic.Ring.mul_zero",
   "ENNReal.toReal_eq_toReal_iff'",
   "Mathlib.Tactic.FieldSimp.lt_eq_cancel_lt",
   "CauchySeq",
   "zpow_eq_pow",
   "Exists.casesOn",
   "Mathlib.Tactic.Linarith.mul_neg",
   "div_pos_iff_of_pos_left._simp_1",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons",
   "Mathlib.Tactic.Linarith.mul_nonpos",
   "zpow_natCast_sub_one‚ÇÄ",
   "not_false",
   "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
   "Mathlib.Tactic.Ring.mul_one",
   "Nat.cast",
   "Eq.mp",
   "ENNReal.ofNNReal",
   "Metric.mem_closedBall",
   "le_trans",
   "Or.resolve_right",
   "NNReal.toReal",
   "WithTop.some",
   "mul_div_assoc'",
   "LT.lt.ne_top",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "le_of_eq",
   "DivInvMonoid.zpow",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_9",
   "Mathlib.Meta.NormNum.isNNRat_inv_pos",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Inv.inv",
   "inv_pow",
   "ENNReal.toReal_inv",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg",
   "Mathlib.Tactic.Ring.cast_pos",
   "zero_lt_one",
   "add_sub_cancel_right",
   "Mathlib.Tactic.Ring.add_congr",
   "Metric.nonempty_iInter_of_nonempty_biInter",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "ENNReal.toReal_ofNat",
   "Eq.trans",
   "inv_pos_of_pos",
   "WithTop",
   "Set.iInter",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.FieldSimp.NF.eval_cons",
   "Mathlib.Meta.NormNum.isNNRat_div",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "sub_eq_zero_of_eq",
   "Mathlib.Tactic.Ring.one_mul",
   "Metric.diam_nonneg",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_2",
   "four_pos",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "nhds",
   "rfl",
   "Mathlib.Tactic.Ring.pow_prod_atom",
   "Exists.choose_spec",
   "Norm.norm",
   "abs_inv",
   "NNReal",
   "Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul",
   "Prod.snd",
   "zpow_le_zpow_iff_right‚ÇÄ",
   "_private.SphericalCompleteness.External.Complete.0.dcidx_strict_mono",
   "NNDist.nndist",
   "Nat.rawCast",
   "Metric.isClosed_closedBall",
   "one_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Ne.symm",
   "add_lt_add_of_le_of_lt",
   "pow_pos",
   "sup_eq_left._simp_3",
   "one_div",
   "lt_div_iff‚ÇÄ",
   "not_le._simp_1",
   "div_pos",
   "Int.add_one_le_iff",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "LT.lt.ne'",
   "mul_le_mul_of_nonneg_right",
   "add_le_add",
   "Mathlib.Tactic.Ring.pow_congr",
   "congr",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_10",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "lt_of_not_ge",
   "Mathlib.Tactic.Ring.pow_zero",
   "Mathlib.Tactic.FieldSimp.NF.mul_eq_eval‚ÇÉ",
   "pow_eq_zero_iff'._simp_1",
   "dist_comm",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_12",
   "dist_zero_right",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Metric.closedBall",
   "Max.max",
   "ENNReal",
   "Mathlib.Tactic.FieldSimp.NF.atom_eq_eval",
   "congr_arg‚ÇÇ",
   "inferInstance",
   "antitone_nat_of_succ_le",
   "neg_neg_of_pos",
   "Mathlib.Meta.NormNum.isNNRat_mul",
   "Real.toNNReal._proof_1",
   "lt_trans",
   "Mathlib.Tactic.Ring.zero_mul",
   "Nat.cast_one",
   "ENNReal.coe_inv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Linarith.lt_of_lt_of_eq",
   "Metric.isBounded_closedBall",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "Mathlib.Tactic.FieldSimp.NF.cons_pos",
   "one_lt_two",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_16",
   "HDiv.hDiv",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_7",
   "abs_eq_self",
   "Mathlib.Meta.NormNum.isNat_add",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Mathlib.Tactic.FieldSimp.NF.inv_eq_eval",
   "Real.toNNReal",
   "Neg.neg",
   "ENNReal.exists_inv_two_pow_lt",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_1",
   "CancelDenoms.sub_subst",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "div_one",
   "mul_div_cancel_right‚ÇÄ",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "NeZero.ne'",
   "congrArg",
   "Subtype.prop",
   "ENNReal.toReal_pow",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "dist_triangle",
   "Mathlib.Tactic.FieldSimp.NF.one_div_eq_eval",
   "zpow_pos",
   "pow_nonneg._simp_1",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_14",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "zpow_natCast",
   "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter._simp_1_11",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "ENNReal.zpow_neg",
   "Mathlib.Tactic.Ring.pow_add",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "mul_div",
   "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
   "CancelDenoms.div_subst",
   "Exists.choose",
   "NNReal.abs_eq",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "DivInvMonoid.zpow_succ'",
   "lt_mul_iff_one_lt_right'._simp_4",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name":
  "completeSpace_iff_nested_ball_with_radius_tendsto_zero_has_nonempty_inter",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±],\n  CompleteSpace Œ± ‚Üî\n    ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n      (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí\n        Filter.Tendsto ri Filter.atTop (nhds 0) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mpr_not",
   "dite",
   "dite_congr",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_cond_eq_true",
  "constType":
  "‚àÄ {Œ± : Sort u} {c : Prop} {x : Decidable c} {t : c ‚Üí Œ±} {e : ¬¨c ‚Üí Œ±} (h : c = True), dite c t e = t ‚ãØ",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "GT.gt",
   "Decidable.decide",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Nat.lt_of_not_le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._proof_10",
  "constType": "‚àÄ (n k : ‚Ñï), k + 1 ‚â• n + 1 ‚Üí ¬¨k = n ‚Üí ¬¨k ‚â• n + 1 ‚Üí False",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "add_assoc",
   "congr",
   "HSub.hSub",
   "neg_add_rev",
   "add_comm",
   "congrArg"],
  "name": "sub_sub",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionCommMonoid Œ±] (a b c : Œ±), a - b - c = a - (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["HSMul.hSMul", "Eq.symm", "HMul.hMul", "SemigroupAction.mul_smul"],
  "name": "smul_smul",
  "constType":
  "‚àÄ {M : Type u_1} {Œ± : Type u_5} [inst : Monoid M] [inst_1 : MulAction M Œ±] (a‚ÇÅ a‚ÇÇ : M) (b : Œ±),\n  a‚ÇÅ ‚Ä¢ a‚ÇÇ ‚Ä¢ b = (a‚ÇÅ * a‚ÇÇ) ‚Ä¢ b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat.cast",
   "Eq.mp",
   "Nat.ble_eq",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Iff.mpr",
   "Nat.cast_pos",
   "LE.le",
   "id",
   "Eq.mpr",
   "Nat.ble"],
  "name": "Mathlib.Meta.Positivity.pos_of_isNat",
  "constType":
  "‚àÄ {A : Type u_1} {e : A} {n : ‚Ñï} [inst : Semiring A] [inst_1 : PartialOrder A] [IsOrderedRing A] [Nontrivial A],\n  Mathlib.Meta.NormNum.IsNat e n ‚Üí Nat.ble 1 n = true ‚Üí 0 < e",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Iff.rfl", "Set.range"],
  "name": "Set.mem_range",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort u_1} {f : Œπ ‚Üí Œ±} {x : Œ±}, x ‚àà Set.range f ‚Üî ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_19",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, (¬¨a < b) = (b ‚â§ a)",
  "constCategory": "Theorem"},
 {"references": ["upperBounds", "Set", "Membership.mem", "Iff.rfl"],
  "name": "mem_upperBounds",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} {a : Œ±}, a ‚àà upperBounds s ‚Üî ‚àÄ x ‚àà s, x ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Eq.trans",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "Mathlib.Meta.NormNum.isNNRat_div",
   "Mathlib.Tactic.Linarith.add_lt_of_le_of_neg",
   "Mathlib.Tactic.Ring.one_mul",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "rfl",
   "Norm.norm",
   "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
   "norm_add_le",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Top.top",
   "Eq.mpr",
   "Nat.rawCast",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Int.add_one_le_iff",
   "Mathlib.Tactic.Linarith.add_nonpos",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_add",
   "lt_of_not_ge",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Mathlib.Tactic.Zify.natCast_lt._simp_1",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HAdd.hAdd",
   "ENNReal",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "inferInstance",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
   "neg_neg_of_pos",
   "Mathlib.Meta.NormNum.isNNRat_mul",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Int.rawCast",
   "HMul.hMul",
   "GT.gt",
   "GE.ge",
   "HDiv.hDiv",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Linarith.zero_lt_one",
   "Nat.mul",
   "Neg.neg",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Linarith.natCast_nonneg",
   "Mathlib.Tactic.Linarith.mul_neg",
   "Exists.casesOn",
   "CancelDenoms.sub_subst",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.mpr",
   "Nat.cast_zero",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "id",
   "Mathlib.Tactic.Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Ring.mul_one",
   "Nat.cast",
   "lp",
   "Eq.mp",
   "le_trans",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Meta.NormNum.isNNRat_inv_pos",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Mathlib.Tactic.Ring.of_eq",
   "PreLp",
   "Inv.inv",
   "Mathlib.Tactic.Zify.natCast_le._simp_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "CancelDenoms.div_subst",
   "Mathlib.Tactic.Ring.add_congr",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
   "LT.lt",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "Mathlib.Tactic.Ring.add_pf_add_gt"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._proof_2",
  "constType":
  "‚àÄ (E : ‚Ñï ‚Üí Type u_1) [inst : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)] {a b : ‚Ü•(lp E ‚ä§)},\n  a ‚àà {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ} ‚Üí\n    b ‚àà {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ} ‚Üí a + b ‚àà {f | ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, ‚Äñ‚Üëf n‚Äñ ‚â§ Œµ}",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntax.raw",
  "constType": "{ks : SyntaxNodeKinds} ‚Üí TSyntax ks ‚Üí Syntax",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership.mem",
  "constType":
  "{Œ± : outParam (Type u)} ‚Üí {Œ≥ : Type v} ‚Üí [self : Membership Œ± Œ≥] ‚Üí Œ≥ ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["div_eq_mul_inv",
   "Inv.inv",
   "Eq.trans",
   "mul_pos_iff_of_pos_left",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HDiv.hDiv",
   "of_eq_true",
   "iff_self",
   "propext",
   "_private.Mathlib.Algebra.Order.Field.Basic.0.div_pos_iff_of_pos_left._simp_1_1"],
  "name": "div_pos_iff_of_pos_left",
  "constType":
  "‚àÄ {Œ± : Type u_2} [inst : Semifield Œ±] [inst_1 : LinearOrder Œ±] [IsStrictOrderedRing Œ±] {a b : Œ±},\n  0 < a ‚Üí (0 < a / b ‚Üî 0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "LE.le",
   "Membership.mem",
   "ConditionallyCompleteLattice.le_csInf"],
  "name": "le_csInf",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, s.Nonempty ‚Üí (‚àÄ b ‚àà s, a ‚â§ b) ‚Üí a ‚â§ sInf s",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "GE.ge",
  "constType": "{Œ± : Type u} ‚Üí [LE Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.Elem"],
  "name": "Set.toFinite",
  "constType": "‚àÄ {Œ± : Type u} (s : Set Œ±) [Finite ‚Üës], s.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "LE.le",
   "Metric.ball",
   "Metric.ball_eq_empty",
   "EmptyCollection.emptyCollection",
   "OfNat.ofNat",
   "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_11",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, (Metric.ball x Œµ = ‚àÖ) = (Œµ ‚â§ 0)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "cast"],
  "name": "eq_of_heq",
  "constType": "‚àÄ {Œ± : Sort u} {a a' : Œ±}, a ‚âç a' ‚Üí a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Inter.inter",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_1",
   "Classical.propDecidable",
   "Set.iInter",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_8",
   "Set.inter_eq_self_of_subset_right",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_6",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_9",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_5",
   "funext",
   "forall_congr",
   "Eq.symm",
   "Set.iInter_congr_Prop",
   "csInf_le",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
   "binderNameHint",
   "Set.Nonempty.to_subtype",
   "NNReal",
   "Set.iInter_coe_set",
   "Prod.snd",
   "BddBelow",
   "Exists.casesOn",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Iff.mpr",
   "Antitone",
   "id",
   "Mathlib.Tactic.Push.not_and_eq",
   "Eq.mpr",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_3",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.antitone_of_countable_chain_of_ball",
   "Set.inter_eq_self_of_subset_left",
   "setOf",
   "Ne.symm",
   "Eq.mp",
   "NNReal.toReal",
   "lt_of_le_of_ne",
   "congrArg",
   "Prod.fst",
   "Mathlib.Tactic.Push.not_exists._simp_1",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_4",
   "SphericallyCompleteSpace.isSphericallyComplete",
   "Subtype.prop",
   "congr",
   "InfSet.sInf",
   "Dist.dist",
   "Set.mem_iInter",
   "lt_of_not_ge",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "Set",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.cofinal_of_countable_chain_of_ball",
   "OfNat.ofNat",
   "LT.lt",
   "Metric.closedBall",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "closedBall_subset_closedBall_of_le_radius_of_nonempty_intersection_of_ultrametric",
   "Ne",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_2",
   "dite",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [iud : IsUltrametricDist Œ±],\n  SphericallyCompleteSpace Œ± ‚Üî\n    ‚àÄ (S : Set (Œ± √ó NNReal)),\n      S.Nonempty ‚Üí\n        (‚àÄ (w1 w2 : ‚ÜëS), (Metric.closedBall (‚Üëw1).1 ‚Üë(‚Üëw1).2 ‚à© Metric.closedBall (‚Üëw2).1 ‚Üë(‚Üëw2).2).Nonempty) ‚Üí\n          (‚ãÇ w, Metric.closedBall (‚Üëw).1 ‚Üë(‚Üëw).2).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.MOrth", "Subspace"],
  "name": "SphericallyCompleteSpace.MOrth.congr_simp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x x_1 : E),\n  x = x_1 ‚Üí\n    ‚àÄ (F F_1 : Subspace ùïú E), F = F_1 ‚Üí SphericallyCompleteSpace.MOrth ùïú x F = SphericallyCompleteSpace.MOrth ùïú x_1 F_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkStr4",
  "constType": "String ‚Üí String ‚Üí String ‚Üí String ‚Üí Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["Imp.swap", "Iff.mp"],
  "name": "Mathlib.Tactic.Contrapose.contrapose‚ÇÉ",
  "constType": "‚àÄ {p q : Prop}, (q ‚Üí ¬¨p) ‚Üí p ‚Üí ¬¨q",
  "constCategory": "Theorem"},
 {"references": ["Ne.isUnit", "IsUnit.div_self", "Ne", "OfNat.ofNat"],
  "name": "div_self",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] {a : G‚ÇÄ}, a ‚â† 0 ‚Üí a / a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Mathlib.Tactic.Linarith.add_lt_of_neg_of_le",
   "Submodule.toAddSubmonoid",
   "Eq.trans",
   "NormedAddCommGroup.tendsto_atTop",
   "norm_le_norm_sub_add",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "Mathlib.Meta.NormNum.isNNRat_div",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_2",
   "iSup",
   "Mathlib.Tactic.Ring.one_mul",
   "IsSeqClosed",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "nhds",
   "rfl",
   "Norm.norm",
   "Mathlib.Meta.NormNum.IsNNRat.to_isNat",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_4",
   "Filter.atTop",
   "SetLike.coe",
   "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ._simp_2",
   "Nat.max",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "Nat.rawCast",
   "add_halves",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "AddSubsemigroup.carrier",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "norm_sub_rev",
   "add_le_add",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "ciSup_le_iff",
   "Mathlib.Tactic.Ring.mul_add",
   "propext",
   "lt_of_not_ge",
   "lp.norm_eq_ciSup",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_8",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "ENNReal.top_ne_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "Mathlib.Meta.NormNum.instAtLeastTwo",
   "inferInstance",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne'",
   "Mathlib.Meta.NormNum.isNNRat_mul",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsNat.to_isNNRat",
   "le_refl",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_2",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Iff.mp",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_3",
   "Int.rawCast",
   "HMul.hMul",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "GT.gt",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_9",
   "GE.ge",
   "HDiv.hDiv",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_1",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "AddSubmonoid.mk.congr_simp",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "add_comm",
   "Filter.Tendsto",
   "Submodule.mk.congr_simp",
   "Nat.mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Exists.casesOn",
   "CancelDenoms.sub_subst",
   "Mathlib.Tactic.Ring.atom_pf",
   "lp.norm_apply_le_norm",
   "upperBounds",
   "Nat.cast_zero",
   "HSMul.hSMul",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "id",
   "Mathlib.Tactic.Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_6",
   "Eq.mp",
   "lp",
   "le_trans",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "Set.range",
   "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ._simp_3",
   "congrArg",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_4",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Meta.NormNum.isNNRat_inv_pos",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "PreLp",
   "Inv.inv",
   "Mathlib.Tactic.Ring.cast_pos",
   "CancelDenoms.div_subst",
   "Mathlib.Tactic.Ring.add_congr",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
   "LT.lt",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_7",
   "LE.le",
   "IsSeqClosed.isClosed",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "AddSubsemigroup.mk.congr_simp"],
  "name":
  "SphericallyCompleteSpace.instNormedAddCommGroupQuotientSubtypePreLpNatMemAddSubgroupLpTopENNRealSubmoduleC‚ÇÄ._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E], IsClosed (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).carrier",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "HAdd.hAdd"],
  "name": "AddLeftStrictMono",
  "constType": "(M : Type u_1) ‚Üí [Add M] ‚Üí [LT M] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Lean.Omega.Coeffs",
   "and_true",
   "Decidable.decide",
   "GE.ge",
   "congrArg",
   "Decidable.decide.congr_simp",
   "congr",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Int.zero_sub",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Int.sub_left_le_of_le_add",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addInequality_sat",
  "constType":
  "‚àÄ {c : ‚Ñ§} {x y : Omega.Coeffs}, c + x.dot y ‚â• 0 ‚Üí { lowerBound := some (-c), upperBound := none }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["ProperSpace.of_nontriviallyNormedField_of_weaklyLocallyCompactSpace",
   "inferInstance"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceOfWeaklyLocallyCompactNormedField",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : NontriviallyNormedField Œ±] [WeaklyLocallyCompactSpace Œ±], SphericallyCompleteSpace Œ±",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "smul_neg",
   "Neg.neg",
   "HSMul.hSMul",
   "id",
   "HSub.hSub",
   "smul_add",
   "Eq.mpr",
   "congrArg"],
  "name": "smul_sub",
  "constType":
  "‚àÄ {M : Type u_1} {A : Type u_7} [inst : AddGroup A] [inst_1 : DistribSMul M A] (r : M) (x y : A),\n  r ‚Ä¢ (x - y) = r ‚Ä¢ x - r ‚Ä¢ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bot.bot",
  "constType": "{Œ± : Type u_1} ‚Üí [self : Bot Œ±] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Eq.symm",
   "Iff.eq",
   "mul_lt_mul_iff_of_pos_left",
   "HMul.hMul",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.lt_eq_cancel_lt",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CancelMonoidWithZero M] [inst_1 : PartialOrder M] [PosMulStrictMono M] [PosMulReflectLT M]\n  {e‚ÇÅ e‚ÇÇ f‚ÇÅ f‚ÇÇ L : M}, e‚ÇÅ = L * f‚ÇÅ ‚Üí e‚ÇÇ = L * f‚ÇÇ ‚Üí 0 < L ‚Üí (e‚ÇÅ < e‚ÇÇ) = (f‚ÇÅ < f‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "Eq.mp",
   "HMul.hMul",
   "GT.gt",
   "neg_of_neg_pos",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "neg_mul",
   "gt_iff_lt._simp_1",
   "LE.le",
   "id",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "neg_neg_of_pos",
   "Left.one_lt_inv_iff._simp_4"],
  "name": "Mathlib.Tactic.Linarith.mul_neg",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : Ring Œ±] [inst_1 : PartialOrder Œ±] [IsStrictOrderedRing Œ±] {a b : Œ±}, a < 0 ‚Üí 0 < b ‚Üí b * a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mk_eq_zero", "Membership.mem", "OfNat.ofNat", "propext"],
  "name": "Submodule.mk_eq_zero._simp_1",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ‚àà p), (‚ü®x, h‚ü© = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_14",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (y : Œ≤), (y ‚àà f '' s) = ‚àÉ x ‚àà s, f x = y",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl"],
  "name": "Iff.of_eq",
  "constType": "‚àÄ {a b : Prop}, a = b ‚Üí (a ‚Üî b)",
  "constCategory": "Theorem"},
 {"references":
  ["le_hasSum",
   "lp",
   "SummationFilter.unconditional",
   "Membership.mem",
   "ENNReal.toReal_pos",
   "lp.hasSum_norm",
   "eq_or_ne",
   "Subtype.val",
   "Set.range",
   "congrArg",
   "Eq.symm",
   "ENNReal.toReal",
   "Eq.ndrec",
   "lp.isLUB_norm",
   "propext",
   "And.left",
   "rfl",
   "PreLp",
   "lp.norm_nonneg'",
   "Norm.norm",
   "Set",
   "Real.rpow_nonneg",
   "HPow.hPow",
   "OfNat.ofNat",
   "Or.casesOn",
   "LT.lt",
   "ENNReal",
   "Real.rpow_le_rpow_iff",
   "upperBounds",
   "LE.le",
   "lowerBounds",
   "id",
   "Top.top",
   "Eq.mpr",
   "norm_nonneg",
   "Ne"],
  "name": "lp.norm_apply_le_norm",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} {p : ENNReal} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)],\n  p ‚â† 0 ‚Üí ‚àÄ (f : ‚Ü•(lp E p)) (i : Œ±), ‚Äñ‚Üëf i‚Äñ ‚â§ ‚Äñf‚Äñ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Module.rank",
  "constType":
  "(R : Type u_1) ‚Üí\n  (M : Type u_2) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [_root_.Module R M] ‚Üí Cardinal.{u_2}",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "max_def'",
   "Eq.trans",
   "Eq.mp",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "Max.max",
   "Lean.Grind.nestedDecidable",
   "LinearOrder.toDecidableLE'",
   "Lean.Grind.Order.le_eq_true",
   "eq_false",
   "Classical.byContradiction",
   "LE.le",
   "id",
   "Eq.symm"],
  "name": "max_self",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (a : Œ±), max a a = a",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.Quotient.sphericallyCompleteSpace._simp_1_10",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_7",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x y : Œ±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.smul_orth_of_orth._simp_1_1",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ‚àà ‚Üëp) = (x ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_and_or", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_2",
  "constType": "‚àÄ {a b : Prop}, (¬¨(a ‚àß b)) = (¬¨a ‚à® ¬¨b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Module.finrank_eq_of_rank_eq",
   "Bot.bot",
   "OfNat.ofNat",
   "rank_bot"],
  "name": "finrank_bot",
  "constType":
  "‚àÄ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] [Nontrivial R],\n  Module.finrank R ‚Ü•‚ä• = 0",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "mul_le_mul_iff_right‚ÇÄ",
   "LE.le",
   "Eq.symm",
   "Iff.eq",
   "HMul.hMul",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "Mathlib.Tactic.FieldSimp.le_eq_cancel_le",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CancelMonoidWithZero M] [inst_1 : PartialOrder M] [PosMulMono M] [PosMulReflectLE M]\n  {e‚ÇÅ e‚ÇÇ f‚ÇÅ f‚ÇÇ L : M}, e‚ÇÅ = L * f‚ÇÅ ‚Üí e‚ÇÇ = L * f‚ÇÇ ‚Üí 0 < L ‚Üí (e‚ÇÅ ‚â§ e‚ÇÇ) = (f‚ÇÅ ‚â§ f‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.mul_one",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] (a : R), a * Nat.rawCast 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Neg.neg",
   "Set",
   "Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Iff.rfl"],
  "name": "AddSubgroup.mem_mk",
  "constType":
  "‚àÄ {G : Type u_1} [inst : AddGroup G] {s : AddSubmonoid G} {x : G} (h_neg : ‚àÄ {x : G}, x ‚àà s.carrier ‚Üí -x ‚àà s.carrier),\n  x ‚àà { toAddSubmonoid := s, neg_mem' := h_neg } ‚Üî x ‚àà s",
  "constCategory": "Theorem"},
 {"references":
  ["PreLp",
   "ENNReal",
   "Mem‚Ñìp.add",
   "Mem‚Ñìp",
   "zero_mem‚Ñìp",
   "Mem‚Ñìp.neg",
   "setOf"],
  "name": "lp",
  "constType":
  "{Œ± : Type u_3} ‚Üí (E : Œ± ‚Üí Type u_5) ‚Üí [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] ‚Üí ENNReal ‚Üí AddSubgroup (PreLp E)",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "LinearMap.range._proof_1",
   "Submodule.copy",
   "Submodule.map",
   "Top.top",
   "DFunLike.coe",
   "Set.range"],
  "name": "LinearMap.range",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {M : Type u_5} ‚Üí\n      {M‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                [inst_4 : _root_.Module R M] ‚Üí\n                  [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ] ‚Üí\n                    {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n                      {F : Type u_10} ‚Üí\n                        [inst_6 : FunLike F M M‚ÇÇ] ‚Üí\n                          [SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] ‚Üí [RingHomSurjective œÑ‚ÇÅ‚ÇÇ] ‚Üí F ‚Üí Submodule R‚ÇÇ M‚ÇÇ",
  "constCategory": "Definition"},
 {"references": ["sup_le_iff"],
  "name": "max_le_iff",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, max a b ‚â§ c ‚Üî a ‚â§ c ‚àß b ‚â§ c",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "‚àÄ {a b : Prop}, a ‚à® b ‚Üí ¬¨b ‚Üí a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.combine",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "Eq.mpr",
   "Lean.Omega.Constraint.combine_sat",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.combine_sat'",
  "constType":
  "‚àÄ {s t : Omega.Constraint} {x y : Omega.Coeffs}, s.sat' x y = true ‚Üí t.sat' x y = true ‚Üí (s.combine t).sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Eq.trans",
   "Lean.Omega.Coeffs.ofList",
   "of_eq_true",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_0",
  "constType":
  "‚àÄ {a0 : ‚Ñ§} {t : List ‚Ñ§}, (Omega.LinearCombo.coordinate 0).eval (Omega.Coeffs.ofList (a0 :: t)) = a0",
  "constCategory": "Theorem"},
 {"references": ["mt", "LE.le", "Ne", "le_antisymm", "lt_of_le_not_ge"],
  "name": "lt_of_le_of_ne",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí a ‚â† b ‚Üí a < b",
  "constCategory": "Theorem"},
 {"references": ["IsBoundedLinearMap.toIsLinearMap"],
  "name": "IsBoundedLinearMap.toLinearMap._proof_1",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (f : E ‚Üí F),\n  IsBoundedLinearMap ùïú f ‚Üí IsLinearMap ùïú f",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} ‚Üí {Œ± : outParam (Sort u_2)} ‚Üí {Œ≤ : outParam (Œ± ‚Üí Sort u_3)} ‚Üí [self : DFunLike F Œ± Œ≤] ‚Üí F ‚Üí (a : Œ±) ‚Üí Œ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "_private.Mathlib.Topology.MetricSpace.HausdorffDistance.0.Metric.le_infDist._simp_1_2",
   "_private.Mathlib.Topology.MetricSpace.HausdorffDistance.0.Metric.le_infDist._simp_1_3",
   "congrArg",
   "Metric.infEdist_ne_top",
   "iff_self",
   "EDist.edist",
   "Dist.dist",
   "forall_congr",
   "ENNReal.toReal",
   "Eq.symm",
   "ENNReal.ofReal_le_iff_le_toReal",
   "Metric.infDist",
   "propext",
   "Set.Nonempty",
   "Set",
   "EMetric.infEdist",
   "ENNReal.ofReal",
   "ENNReal",
   "of_eq_true",
   "LE.le",
   "id",
   "Eq.mpr",
   "edist_ne_top"],
  "name": "Metric.le_infDist",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {r : ‚Ñù},\n  s.Nonempty ‚Üí (r ‚â§ Metric.infDist x s ‚Üî ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚Üí r ‚â§ dist x y)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "False.elim",
   "sub_eq_zero_of_eq",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "rfl",
   "Norm.norm",
   "SphericallyCompleteSpace.Orth",
   "Mathlib.Tactic.Abel.term_add_constg",
   "SetLike.coe",
   "Int.negOfNat",
   "zero_smul",
   "norm_neg",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "dist_eq_norm",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "norm_sub_rev",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "neg_sub",
   "dist_zero_right",
   "IsUltrametricDist.norm_add_eq_max_of_norm_ne_norm",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Max.max",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth._simp_1_1",
   "Metric.infDist_lt_iff",
   "Ne",
   "dite",
   "And.casesOn",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "Submodule.span",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "inv_smul_eq_iff‚ÇÄ",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "Neg.neg",
   "lt_of_le_of_lt",
   "smul_sub",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth._simp_1_3",
   "Exists.casesOn",
   "zero_add",
   "Mathlib.Tactic.Ring.atom_pf",
   "norm_pos_iff",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Linarith.lt_of_eq_of_lt",
   "congrArg",
   "neg_eq_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Dist.dist",
   "Metric.infDist",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Metric.infDist_le_dist_of_mem",
   "Mathlib.Meta.NormNum.isInt_mul",
   "LT.lt.le",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Inv.inv",
   "eq_of_le_of_not_lt",
   "Mathlib.Tactic.Abel.term_neg",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "norm_smul",
   "ZeroMemClass.zero_mem._simp_1",
   "of_eq_true",
   "SetLike.mem_coe._simp_1",
   "ne_of_lt",
   "mul_lt_mul_iff_right‚ÇÄ",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.neg_congr",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth._simp_1_2",
   "LE.le",
   "max_eq_right"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [iud : IsUltrametricDist E] {x y : E}, (x ‚üÇ[ùïú] y) ‚Üí y ‚üÇ[ùïú] x",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "add_assoc",
   "congr",
   "HSub.hSub",
   "congrArg"],
  "name": "add_sub",
  "constType":
  "‚àÄ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + (b - c) = a + b - c",
  "constCategory": "Theorem"},
 {"references": ["FunLike", "LinearMap.range", "Eq.ndrec"],
  "name": "LinearMap.range.congr_simp",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ œÑ‚ÇÅ‚ÇÇ_1 : R ‚Üí+* R‚ÇÇ} (e_œÑ‚ÇÅ‚ÇÇ : œÑ‚ÇÅ‚ÇÇ = œÑ‚ÇÅ‚ÇÇ_1) {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ]\n  [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] (f f_1 : F),\n  f = f_1 ‚Üí LinearMap.range f = LinearMap.range f_1",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Subtype.property", "NNReal", "OfNat.ofNat"],
  "name": "NNReal.zero_le_coe",
  "constType": "‚àÄ {q : NNReal}, 0 ‚â§ ‚Üëq",
  "constCategory": "Theorem"},
 {"references": ["Set", "ENNReal.toReal", "EMetric.infEdist"],
  "name": "Metric.infDist",
  "constType": "{Œ± : Type u} ‚Üí [PseudoMetricSpace Œ±] ‚Üí Œ± ‚Üí Set Œ± ‚Üí ‚Ñù",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView.imported",
   "Lean.MacroScopesView.review",
   "Lean.MacroScopesView.ctx",
   "cond.match_1",
   "Lean.MacroScope",
   "Lean.Name.mkStr",
   "Unit",
   "Lean.MacroScopesView.name",
   "Lean.Name.hasMacroScopes",
   "Lean.extractMacroScopes",
   "Lean.Name.appendCore",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.scopes",
   "List.foldl",
   "BEq.beq"],
  "name": "Lean.addMacroScope",
  "constType": "Name ‚Üí Name ‚Üí MacroScope ‚Üí Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PosMulMono.mul_le_mul_of_nonneg_left",
  "constType":
  "‚àÄ {Œ± : Type u_1} {inst : Mul Œ±} {inst_1 : Zero Œ±} {inst_2 : Preorder Œ±} [self : PosMulMono Œ±] ‚¶Éa : Œ±‚¶Ñ,\n  0 ‚â§ a ‚Üí ‚àÄ ‚¶Éb c : Œ±‚¶Ñ, b ‚â§ c ‚Üí a * b ‚â§ a * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E‚ÇÄ : Type u_2) [inst_1 : NormedAddCommGroup E‚ÇÄ]\n  [inst_2 : NormedSpace ùïú E‚ÇÄ], IsScalarTower ùïú ùïú E‚ÇÄ",
  "constCategory": "Theorem"},
 {"references": ["Iff.trans", "exists_eq_left", "exists_congr", "And.comm"],
  "name": "exists_eq_right",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {a' : Œ±}, (‚àÉ a, p a ‚àß a = a') ‚Üî p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range_nonempty",
   "Set",
   "csSup_le",
   "Membership.mem",
   "LE.le",
   "Set.forall_mem_range",
   "id",
   "Eq.mpr",
   "propext",
   "Set.range",
   "congrArg"],
  "name": "ciSup_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} [inst : ConditionallyCompleteLattice Œ±] [Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\n  (‚àÄ (x : Œπ), f x ‚â§ c) ‚Üí iSup f ‚â§ c",
  "constCategory": "Theorem"},
 {"references": ["SphericallyCompleteSpace.IsImmediate", "RingHom.id"],
  "name": "SphericallyCompleteSpace.IsImmediate.congr_simp",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {F : Type v} [inst_4 : SeminormedAddCommGroup F]\n  [inst_5 : NormedSpace ùïú F] [inst_6 : IsUltrametricDist F] (f f_1 : E ‚Üí‚Çó·µ¢[ùïú] F),\n  f = f_1 ‚Üí SphericallyCompleteSpace.IsImmediate f = SphericallyCompleteSpace.IsImmediate f_1",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_imp", "propext"],
  "name": "Classical.not_imp._simp_2",
  "constType": "‚àÄ {a b : Prop}, (¬¨(a ‚Üí b)) = (a ‚àß ¬¨b)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Nonempty",
  "constType": "{Œ± : Type u} ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.preimage",
  "constType": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Set Œ≤ ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "norm_pos_iff", "Norm.norm", "Ne", "OfNat.ofNat", "propext"],
  "name": "SphericallyCompleteSpace.c‚ÇÄ._simp_5",
  "constType":
  "‚àÄ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, (0 < ‚Äña‚Äñ) = (a ‚â† 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "And.right",
   "Membership.mem",
   "Submodule.add_eq_sup",
   "Iff.mp",
   "Submodule.span",
   "Prod.snd",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "Submodule.add_mem_sup",
   "Prod.fst",
   "congrArg",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "id",
   "Eq.mpr",
   "And.left"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_14",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (t : ‚Ü•(ùïú ‚àô x + F)),\n  ‚Üë(‚ãØ.mpr (fun z ‚Ü¶ (‚ü®‚ãØ.choose, ‚ãØ‚ü©, ‚ü®‚ãØ.choose, ‚ãØ‚ü©)) t).1 + ‚Üë(‚ãØ.mpr (fun z ‚Ü¶ (‚ü®‚ãØ.choose, ‚ãØ‚ü©, ‚ü®‚ãØ.choose, ‚ãØ‚ü©)) t).2 ‚àà\n    ùïú ‚àô x + F",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "Set.mem_range_self", "Set.range"],
  "name": "Set.rangeFactorization",
  "constType":
  "{Œ± : Type u} ‚Üí {Œπ : Sort u_1} ‚Üí (f : Œπ ‚Üí Œ±) ‚Üí Œπ ‚Üí ‚Üë(Set.range f)",
  "constCategory": "Definition"},
 {"references": ["LE.le.lt_of_ne", "zero_le_one", "NeZero.ne'", "OfNat.ofNat"],
  "name": "zero_lt_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [ZeroLEOneClass Œ±] [NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_3",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references": ["Set.mem_pi", "Set", "Set.pi", "Membership.mem", "propext"],
  "name": "SphericallyCompleteSpace.Pi.sphericallyCompleteSpace._simp_1",
  "constType":
  "‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} {s : Set Œπ} {t : (i : Œπ) ‚Üí Set (Œ± i)} {f : (i : Œπ) ‚Üí Œ± i},\n  (f ‚àà s.pi t) = ‚àÄ i ‚àà s, f i ‚àà t i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "SphericallyCompleteSpace.¬´_aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___macroRules_SphericallyCompleteSpace_term_‚üÇ[_]__1¬ª",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "neg_zsmul",
   "Neg.neg",
   "neg_add_rev",
   "congrArg",
   "HAdd.hAdd",
   "congr",
   "HSMul.hSMul",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Mathlib.Tactic.Abel.termg",
   "add_comm"],
  "name": "Mathlib.Tactic.Abel.term_neg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (n : ‚Ñ§) (x a : Œ±) (n' : ‚Ñ§) (a' : Œ±),\n  -n = n' ‚Üí -a = a' ‚Üí -Mathlib.Tactic.Abel.termg n x a = Mathlib.Tactic.Abel.termg n' x a'",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice"],
  "name": "Nonempty.some",
  "constType": "{Œ± : Sort u_3} ‚Üí Nonempty Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Singleton.singleton",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "le_of_eq_of_le",
   "Mathlib.Tactic.Linarith.sub_neg_of_lt",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_2",
   "iSup",
   "Mathlib.Tactic.Linarith.add_lt_of_le_of_neg",
   "RingHom.id",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_6",
   "le_of_not_gt",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Set.range_const",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "mem_lowerBounds",
   "rfl",
   "Norm.norm",
   "Exists.choose_spec",
   "sub_neg_eq_add",
   "Set.mem_image",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_4",
   "SetLike.coe",
   "lowerBounds",
   "Int.negOfNat",
   "Top.top",
   "norm_neg",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "setOf",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_5",
   "le_of_forall_pos_sub_le",
   "HasQuotient.Quotient",
   "Mathlib.Tactic.Linarith.lt_irrefl",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "AddSubgroup.toAddCommGroup._proof_1",
   "AddSubsemigroup.carrier",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "ZeroMemClass.zero_mem",
   "norm_sub_norm_le",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "InfSet.sInf",
   "propext",
   "lp.norm_eq_ciSup",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "ENNReal.top_ne_zero",
   "Mem‚Ñìp.neg",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "ENNReal",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "eq_of_le_of_ge",
   "norm_nonneg",
   "And.casesOn",
   "le_refl",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_2",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_3",
   "Int.rawCast",
   "HMul.hMul",
   "Subtype.mk.congr_simp",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "le_csInf",
   "GT.gt",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_9",
   "GE.ge",
   "quotient_norm_mk_eq",
   "zero_mem‚Ñìp",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_1",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddSubmonoid.mk.congr_simp",
   "QuotientAddGroup.mk'",
   "Submodule.mk.congr_simp",
   "csInf_le",
   "Mem‚Ñìp.add",
   "Neg.neg",
   "And.right",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "AddSubgroupClass.toAddGroup._proof_1",
   "Submodule.toAddSubgroup",
   "add_zero",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_7",
   "Exists.casesOn",
   "Set.image",
   "Mathlib.Tactic.Ring.atom_pf",
   "lp.norm_apply_le_norm",
   "Iff.of_eq",
   "upperBounds",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "AddMemClass.add_mem",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "mem‚Ñìp_infty",
   "AddSubmonoidClass.toAddMonoid._proof_1",
   "lp",
   "Eq.mp",
   "le_trans",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "DFunLike.coe",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "SphericallyCompleteSpace.c‚ÇÄ._proof_4",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mem‚Ñìp",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "PreLp",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "exists_prop_congr",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_1",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "Mathlib.Tactic.Linarith.sub_nonpos_of_le",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "AddSubsemigroup.mk.congr_simp",
   "ciSup_const"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_8",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E),\n  ‚Äñ{\n          toFun := fun x ‚Ü¶\n            have this := ‚ãØ;\n            (QuotientAddGroup.mk' (SphericallyCompleteSpace.c‚ÇÄ ùïú fun x ‚Ü¶ E).toAddSubgroup) ‚ü®fun x_1 ‚Ü¶ x, this‚ü©,\n          map_add' := ‚ãØ, map_smul' := ‚ãØ }\n        x‚Äñ =\n    ‚Äñx‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "Lean.Syntax.node1",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "SphericallyCompleteSpace.¬´_aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___macroRules_SphericallyCompleteSpace_term_‚üÇ‚Çò__1¬ª",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "ZeroMemClass.zero_mem._simp_1",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T_linear._simp_2",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "le_refl",
   "Filter.atTop",
   "Monotone",
   "le_trans",
   "LE.le",
   "Filter.tendsto_atTop_atTop",
   "IsDirectedOrder",
   "exists_congr",
   "forall_congr'",
   "Filter.Tendsto"],
  "name": "Filter.tendsto_atTop_atTop_iff_of_monotone",
  "constType":
  "‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} [Nonempty Œ±] [inst : Preorder Œ±] [IsDirectedOrder Œ±] {f : Œ± ‚Üí Œ≤} [inst_2 : Preorder Œ≤],\n  Monotone f ‚Üí (Filter.Tendsto f Filter.atTop Filter.atTop ‚Üî ‚àÄ (b : Œ≤), ‚àÉ a, b ‚â§ f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set.singleton_nonempty",
   "Set",
   "Singleton.singleton",
   "eq_true"],
  "name": "Set.singleton_nonempty._simp_1",
  "constType": "‚àÄ {Œ± : Type u} (a : Œ±), {a}.Nonempty = True",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_preimage",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚Üí Œ≤} {s : Set Œ≤} {a : Œ±}, a ‚àà f ‚Åª¬π' s ‚Üî f a ‚àà s",
  "constCategory": "Theorem"},
 {"references":
  ["not_le",
   "Iff.trans",
   "LT.lt",
   "Not",
   "AddLeftMono",
   "Nat.cast_le_one",
   "Nat.cast",
   "Iff.not",
   "Iff.mpr",
   "LE.le",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.one_lt"],
  "name": "Nat.not_ofNat_le_one",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] [CharZero Œ±]\n  {n : ‚Ñï} [inst_5 : n.AtLeastTwo], ¬¨OfNat.ofNat n ‚â§ 1",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "sub_add_eq_sub_sub_swap",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "add_sub_cancel_right",
   "congrArg"],
  "name": "add_sub_add_right_eq_sub",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddGroup G] (a b c : G), a + c - (b + c) = a - b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense.mk",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±],\n  (‚àÄ (c : Œ±) (r : NNReal), Metric.diam (Metric.closedBall c ‚Üër) = ‚Üër) ‚Üí SphericallyCompleteSpace.IsSphericallyDense Œ±",
  "constCategory": "Other"},
 {"references":
  ["SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "Maximal",
   "Set",
   "RingHom.id",
   "Membership.mem",
   "inferInstance",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3"],
  "name": "SphericallyCompleteSpace.instNormedSpaceSphericalCompletion",
  "constType":
  "{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u_2) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [inst_3 : IsUltrametricDist E] ‚Üí\n            (E‚ÇÄ : Type u_3) ‚Üí\n              [inst_4 : NormedAddCommGroup E‚ÇÄ] ‚Üí\n                [inst_5 : NormedSpace ùïú E‚ÇÄ] ‚Üí\n                  [inst_6 : IsUltrametricDist E‚ÇÄ] ‚Üí\n                    [inst_7 : SphericallyCompleteSpace E‚ÇÄ] ‚Üí (f : E ‚Üí‚Çó·µ¢[ùïú] E‚ÇÄ) ‚Üí NormedSpace ùïú ‚Ü•‚ãØ.choose",
  "constCategory": "Definition"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_4",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLeftMono",
  "constType": "(M : Type u_1) ‚Üí [Add M] ‚Üí [LE M] ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "ENNReal",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "ENNReal.toReal",
   "EMetric.diam",
   "EMetric.diam_subsingleton",
   "Set.Subsingleton",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Metric.diam_subsingleton",
  "constType":
  "‚àÄ {Œ± : Type u} {s : Set Œ±} [inst : PseudoMetricSpace Œ±], s.Subsingleton ‚Üí Metric.diam s = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Eq.symm",
   "Eq.ndrec",
   "Subtype.mk.noConfusion",
   "Eq.casesOn"],
  "name": "Subtype.mk.injEq",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} (val : Œ±) (property : p val) (val_1 : Œ±) (property_1 : p val_1),\n  (‚ü®val, property‚ü© = ‚ü®val_1, property_1‚ü©) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.ker",
   "Norm.norm",
   "RingHom.id",
   "LE.le",
   "Membership.mem",
   "SphericallyCompleteSpace.OrthComp._proof_2",
   "Exists.choose",
   "SphericallyCompleteSpace.OrthComp._proof_1",
   "DFunLike.coe",
   "Subtype.val",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.OrthComp",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [iud : IsUltrametricDist E] ‚Üí\n          [inst_2 : NormedSpace ùïú E] ‚Üí (F : Submodule ùïú E) ‚Üí [SphericallyCompleteSpace ‚Ü•F] ‚Üí Submodule ùïú E",
  "constCategory": "Definition"},
 {"references": ["Neg.neg", "Membership.mem", "neg_neg", "NegMemClass.neg_mem"],
  "name": "neg_mem_iff",
  "constType":
  "‚àÄ {S : Type u_3} {G : Type u_4} [inst : InvolutiveNeg G] {x : SetLike S G} [NegMemClass S G] {H : S} {x_1 : G},\n  -x_1 ‚àà H ‚Üî x_1 ‚àà H",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.ge_iff_eq'",
   "Iff.trans",
   "norm_le_zero_iff",
   "Norm.norm",
   "LE.le",
   "norm_nonneg",
   "Iff.symm",
   "OfNat.ofNat"],
  "name": "norm_eq_zero",
  "constType":
  "‚àÄ {E : Type u_5} [inst : NormedAddGroup E] {a : E}, ‚Äña‚Äñ = 0 ‚Üî a = 0",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± √ó Œ≤ ‚Üí Prop}, (‚àÉ x, p x) = ‚àÉ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MonadQuotation.getCurrMacroScope",
  "constType": "{m : Type ‚Üí Type} ‚Üí [self : MonadQuotation m] ‚Üí m MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Set.Ioc",
   "Set",
   "Set.mem_Ioc",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.exists_dist_lt_diam_of_isSphericallyDense._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b x : Œ±}, (x ‚àà Set.Ioc a b) = (a < x ‚àß x ‚â§ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MacroScope",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Max.max",
   "Set",
   "Singleton.singleton",
   "Submodule.add_eq_sup",
   "Membership.mem",
   "id",
   "Submodule.span",
   "Subspace",
   "congrArg"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_8",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E), (‚Ü•(ùïú ‚àô x + F) ‚Üí ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F) = (‚Ü•(ùïú ‚àô x ‚äî F) ‚Üí ‚Ü•(ùïú ‚àô x) √ó ‚Ü•F)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.FieldSimp.NF.eval.match_1",
   "Eq.trans",
   "Mathlib.Tactic.FieldSimp.NF.cons",
   "HMul.hMul",
   "List.map",
   "Prod.snd",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "List.prod",
   "Mathlib.Tactic.FieldSimp.zpow'",
   "congrArg",
   "Prod.fst",
   "eq_self",
   "of_eq_true",
   "mul_comm",
   "id",
   "Mathlib.Tactic.FieldSimp.NF"],
  "name": "Mathlib.Tactic.FieldSimp.NF.eval_cons",
  "constType":
  "‚àÄ {M : Type u_1} [inst : CommGroupWithZero M] (p : ‚Ñ§ √ó M) (l : Mathlib.Tactic.FieldSimp.NF M),\n  (p ::·µ£ l).eval = l.eval * Mathlib.Tactic.FieldSimp.zpow' p.2 p.1",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.Orth",
   "_private.SphericalCompleteness.NormedVectorSpace.Orthogonal.Basic.0.SphericallyCompleteSpace.orth_of_orth"],
  "name": "SphericallyCompleteSpace.orth_symm",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [iud : IsUltrametricDist E] {x y : E}, (x ‚üÇ[ùïú] y) ‚Üî y ‚üÇ[ùïú] x",
  "constCategory": "Theorem"},
 {"references":
  ["div_eq_mul_inv",
   "HDiv.hDiv",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isNNRat_div.match_1_1",
   "Inv.inv",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "congrArg"],
  "name": "Mathlib.Meta.NormNum.isNNRat_div",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : DivisionSemiring Œ±] {a b : Œ±} {cn cd : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNNRat (a * b‚Åª¬π) cn cd ‚Üí Mathlib.Meta.NormNum.IsNNRat (a / b) cn cd",
  "constCategory": "Theorem"},
 {"references": ["SupSet.sSup", "Set.range"],
  "name": "iSup",
  "constType": "{Œ± : Type u} ‚Üí {Œπ : Sort v} ‚Üí [SupSet Œ±] ‚Üí (Œπ ‚Üí Œ±) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "StrictAnti", "StrictMono"],
  "name": "StrictAnti.comp_strictMono",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : Preorder Œ≥] {g : Œ≤ ‚Üí Œ≥}\n  {f : Œ± ‚Üí Œ≤}, StrictAnti g ‚Üí StrictMono f ‚Üí StrictAnti (g ‚àò f)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.IsSphericallyDense",
  "constType": "(Œ± : Type u_1) ‚Üí [PseudoMetricSpace Œ±] ‚Üí Prop",
  "constCategory": "Other"},
 {"references":
  ["Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "And.right",
   "Membership.mem",
   "Iff.mp",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "Subspace",
   "HAdd.hAdd",
   "Max.max",
   "Subtype.prop",
   "Submodule.mem_sup",
   "And.left"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._proof_12",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (x : E) (F : Subspace ùïú E) (z : ‚Ü•(ùïú ‚àô x ‚äî F)), ‚ãØ.choose ‚àà F",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach._simp_1_3",
  "constType": "‚àÄ {a b c : Prop}, (a ‚àß b ‚Üí c) = (a ‚Üí b ‚Üí c)",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "‚àÄ {R : Type u_2} [inst : CommRing R] {a b c d : R}, -b = c ‚Üí a + c = d ‚Üí a - b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.ndrec",
  "constType":
  "{Œ± : Sort u2} ‚Üí {a : Œ±} ‚Üí {motive : Œ± ‚Üí Sort u1} ‚Üí motive a ‚Üí {b : Œ±} ‚Üí a = b ‚Üí motive b",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Set.Nonempty",
   "Set",
   "Metric.nonempty_ball",
   "Metric.ball",
   "Iff.rfl",
   "EmptyCollection.emptyCollection",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "not_lt",
   "Set.not_nonempty_iff_eq_empty",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "Metric.ball_eq_empty",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, Metric.ball x Œµ = ‚àÖ ‚Üî Œµ ‚â§ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "nhds",
  "constType": "{X : Type u_3} ‚Üí [TopologicalSpace X] ‚Üí X ‚Üí Filter X",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "Membership.mem", "Iff.rfl"],
  "name": "mem_lowerBounds",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} {a : Œ±}, a ‚àà lowerBounds s ‚Üî ‚àÄ x ‚àà s, a ‚â§ x",
  "constCategory": "Theorem"},
 {"references": ["le_top", "LE.le", "Top.top", "eq_true"],
  "name": "le_top._simp_3",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LE Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, (a ‚â§ ‚ä§) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.rec",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [inst : PseudoMetricSpace Œ±] ‚Üí\n    {motive : SphericallyCompleteSpace Œ± ‚Üí Sort u} ‚Üí\n      ((isSphericallyComplete :\n            ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n              (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty) ‚Üí\n          motive ‚ãØ) ‚Üí\n        (t : SphericallyCompleteSpace Œ±) ‚Üí motive t",
  "constCategory": "Other"},
 {"references":
  ["Set.Nonempty",
   "Subtype.prop",
   "Set",
   "RingHom.id",
   "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.PartialExtension.M",
   "LE.le",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.ContinuousLinearMap.SupportingResults.0.SphericallyCompleteSpace.instPartialOrderPartialExtension._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : IsUltrametricDist E] [inst_3 : NormedSpace ùïú E] {D : Submodule ùïú E} (F : Type u_3)\n  [inst_4 : SeminormedAddCommGroup F] [inst_5 : IsUltrametricDist F] [inst_6 : NormedSpace ùïú F]\n  [inst_7 : SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) (ùí∞ : Set (E ‚ÜíL[ùïú] F)) (hùí∞ : ùí∞.Nonempty) (Œµ : ‚Üëùí∞ ‚Üí ‚Ñù)\n  (a b : SphericallyCompleteSpace.PartialExtension‚úù ùïú E F S ùí∞ hùí∞ Œµ),\n  SphericallyCompleteSpace.PartialExtension.M‚úù a ‚â§ SphericallyCompleteSpace.PartialExtension.M‚úù¬π b ‚Üí\n    ‚àÄ (x : ‚Ü•(SphericallyCompleteSpace.PartialExtension.M‚úù¬≤ a)), ‚Üëx ‚àà SphericallyCompleteSpace.PartialExtension.M‚úù¬≥ b",
  "constCategory": "Theorem"},
 {"references": ["Classical.choose_spec"],
  "name": "Exists.choose_spec",
  "constType": "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} (P : ‚àÉ a, p a), p P.choose",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "neg_neg",
   "congrArg"],
  "name": "sub_neg_eq_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : SubtractionMonoid Œ±] (a b : Œ±), a - -b = a + b",
  "constCategory": "Theorem"},
 {"references": ["Submodule.smul_mem'", "Membership.mem"],
  "name": "Submodule.smul_mem",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (r : R), x ‚àà p ‚Üí r ‚Ä¢ x ‚àà p",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "lt_self_iff_false", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyComplete_iff_maximallyComplete._simp_1_4",
  "constType": "‚àÄ {Œ± : Type u_2} [inst : Preorder Œ±] (x : Œ±), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Set.Nonempty", "Set", "lowerBounds"],
  "name": "BddBelow",
  "constType": "{Œ± : Type u_1} ‚Üí [LE Œ±] ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["rfl", "Norm.norm"],
  "name": "ContinuousLinearMap.norm_def",
  "constType":
  "‚àÄ {ùïú : Type u_1} {ùïú‚ÇÇ : Type u_2} {E : Type u_4} {F : Type u_5} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField ùïú] [inst_3 : NontriviallyNormedField ùïú‚ÇÇ]\n  [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú‚ÇÇ F] {œÉ‚ÇÅ‚ÇÇ : ùïú ‚Üí+* ùïú‚ÇÇ} (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] F),\n  ‚Äñf‚Äñ = sInf {c | 0 ‚â§ c ‚àß ‚àÄ (x : E), ‚Äñf x‚Äñ ‚â§ c * ‚Äñx‚Äñ}",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe",
   "Norm.norm",
   "Set",
   "Singleton.singleton",
   "Metric.infDist",
   "Submodule.span"],
  "name": "SphericallyCompleteSpace.Orth",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí [inst_1 : SeminormedAddCommGroup E] ‚Üí [NormedSpace ùïú E] ‚Üí [IsUltrametricDist E] ‚Üí E ‚Üí E ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_15",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.not_right",
   "Set.not_nonempty_iff_eq_empty",
   "Set.Nonempty",
   "Set",
   "EmptyCollection.emptyCollection"],
  "name": "Set.nonempty_iff_ne_empty",
  "constType": "‚àÄ {Œ± : Type u} {s : Set Œ±}, s.Nonempty ‚Üî s ‚â† ‚àÖ",
  "constCategory": "Theorem"},
 {"references":
  ["Or.casesOn",
   "LT.lt",
   "Max.max",
   "Eq.trans",
   "of_eq_true",
   "LE.le",
   "eq_true",
   "le_total",
   "max_eq_left",
   "max_eq_right",
   "congrArg"],
  "name": "max_lt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b c : Œ±}, b < a ‚Üí c < a ‚Üí max b c < a",
  "constCategory": "Theorem"},
 {"references": ["not_le", "LT.lt", "Not", "LE.le", "propext"],
  "name":
  "SphericallyCompleteSpace.instIsSphericallyDenseOfDenselyNormedField._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, (¬¨a ‚â§ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Max.max", "LT.lt.trans_le", "le_max_left"],
  "name": "lt_max_of_lt_left",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {a b c : Œ±}, a < b ‚Üí a < max b c",
  "constCategory": "Theorem"},
 {"references":
  ["negSucc_zsmul",
   "HAdd.hAdd",
   "Eq.trans",
   "one_nsmul",
   "Neg.neg",
   "congr_arg",
   "HSMul.hSMul",
   "OfNat.ofNat"],
  "name": "neg_one_zsmul",
  "constType": "‚àÄ {G : Type u_1} [inst : SubNegMonoid G] (x : G), -1 ‚Ä¢ x = -x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "SphericallyCompleteSpace._aux_SphericalCompleteness_NormedVectorSpace_Orthogonal_Defs___unexpand_SphericallyCompleteSpace_SOrth_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Set", "eq_true", "OrderBot.bddBelow", "BddBelow"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_3",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [OrderBot Œ±] (s : Set Œ±), BddBelow s = True",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass.one_mul"],
  "name": "one_mul",
  "constType": "‚àÄ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "Int.cast_natCast",
   "Int.cast",
   "congrArg",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_isInt.match_1_1"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a : Œ±} {n : ‚Ñï},\n  Mathlib.Meta.NormNum.IsNat a n ‚Üí Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth",
   "Inv.inv",
   "Eq.mp",
   "inv_smul_smul‚ÇÄ",
   "HSMul.hSMul",
   "Ne",
   "SphericallyCompleteSpace.Orth",
   "OfNat.ofNat",
   "congrArg"],
  "name": "SphericallyCompleteSpace.smul_orth_iff_orth_of_nonzero",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x y : E} {a : ùïú}, a ‚â† 0 ‚Üí ((x ‚üÇ[ùïú] y) ‚Üî a ‚Ä¢ x ‚üÇ[ùïú] y)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Singleton.singleton",
   "Classical.propDecidable",
   "Subtype.val",
   "Set.Elem",
   "SphericallyCompleteSpace.orth_symm",
   "sub_eq_add_neg",
   "mul_le_mul_iff_right‚ÇÄ",
   "Submodule.mem_span_singleton",
   "Eq.symm",
   "norm_zero",
   "sup_of_le_right",
   "infDist_smul‚ÇÄ",
   "Norm.norm",
   "sub_neg_eq_add",
   "le_ciInf_set_iff",
   "SphericallyCompleteSpace.Orth",
   "Mathlib.Tactic.Abel.term_add_constg",
   "smul_submodule_eq_self",
   "SetLike.coe",
   "lowerBounds",
   "one_smul",
   "Int.negOfNat",
   "neg_one_zsmul",
   "zero_smul",
   "norm_neg",
   "Eq.mpr",
   "SphericallyCompleteSpace.orth_iff._simp_1_6",
   "one_mul",
   "setOf",
   "max_le",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "SphericallyCompleteSpace.orth_iff._simp_1_9",
   "dist_eq_norm",
   "Mathlib.Meta.NormNum.isInt_neg",
   "dist_zero",
   "congr",
   "neg_mul",
   "iInf",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "neg_smul",
   "Set",
   "one_nsmul",
   "dist_comm",
   "SphericallyCompleteSpace.orth_iff._simp_1_3",
   "not_or._simp_2",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Max.max",
   "Ne",
   "eq_of_le_of_ge",
   "dite",
   "le_refl",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Submodule.span",
   "GE.ge",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.orth_iff._simp_1_2",
   "And.left",
   "SphericallyCompleteSpace.orth_iff._simp_1_5",
   "Neg.neg",
   "SphericallyCompleteSpace.orth_iff._simp_1_8",
   "SphericallyCompleteSpace.orth_iff._simp_1_7",
   "And.right",
   "add_zero",
   "SphericallyCompleteSpace.orth_iff._simp_1_10",
   "Exists.casesOn",
   "Set.image",
   "zero_add",
   "SphericallyCompleteSpace.orth_iff._simp_1_1",
   "sup_of_le_left",
   "norm_pos_iff",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "HSMul.hSMul",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Metric.infDist_eq_iInf",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "le_trans",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "congrArg",
   "Dist.dist",
   "le_of_eq",
   "Set.smulSet",
   "Metric.infDist",
   "Metric.infDist_le_dist_of_mem",
   "Not",
   "Mathlib.Tactic.Abel.term_neg",
   "norm_smul",
   "Or.casesOn",
   "LT.lt",
   "of_eq_true",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "SphericallyCompleteSpace.orth_iff._simp_1_4"],
  "name": "SphericallyCompleteSpace.orth_iff",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [iud : IsUltrametricDist E] {x y : E},\n  (x ‚üÇ[ùïú] y) ‚Üî ‚àÄ (Œ± Œ≤ : ùïú), ‚ÄñŒ± ‚Ä¢ x + Œ≤ ‚Ä¢ y‚Äñ = max ‚ÄñŒ± ‚Ä¢ x‚Äñ ‚ÄñŒ≤ ‚Ä¢ y‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "SetLike.ext'_iff",
   "Set",
   "LinearMap.range",
   "Iff.rfl",
   "Function.Surjective",
   "DFunLike.coe",
   "LinearMap.coe_range",
   "Set.range",
   "congrArg",
   "Set.univ",
   "SetLike.coe",
   "Submodule.top_coe",
   "Top.top",
   "id",
   "Eq.mpr",
   "Set.range_eq_univ",
   "propext"],
  "name": "LinearMap.range_eq_top",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F}, LinearMap.range f = ‚ä§ ‚Üî Function.Surjective ‚áëf",
  "constCategory": "Theorem"},
 {"references": ["dist_eq_norm_sub"],
  "name": "dist_eq_norm",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a b : E), dist a b = ‚Äña - b‚Äñ",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "Left.neg_pos_iff",
   "neg_neg",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "le_of_forall_neg_add_le",
   "Iff.mpr",
   "LE.le",
   "HSub.hSub"],
  "name": "le_of_forall_pos_sub_le",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±] [AddLeftMono Œ±] [DenselyOrdered Œ±] {a b : Œ±},\n  (‚àÄ (Œµ : Œ±), 0 < Œµ ‚Üí a - Œµ ‚â§ b) ‚Üí a ‚â§ b",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "SphericallyCompleteSpace.orth_iff._simp_1_9",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {x y : Œ±}, (x ‚â• y) = (y ‚â§ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name": "SphericallyCompleteSpace.Prod.sphericallyCompleteSpace._simp_2",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EStateM",
  "constType": "Type u ‚Üí Type u ‚Üí Type u ‚Üí Type u",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Dist.dist", "setOf"],
  "name": "Metric.ball",
  "constType": "{Œ± : Type u} ‚Üí [PseudoMetricSpace Œ±] ‚Üí Œ± ‚Üí ‚Ñù ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references": ["String.toRawSubstring"],
  "name": "String.toRawSubstring'",
  "constType": "String ‚Üí Substring.Raw",
  "constCategory": "Definition"},
 {"references": ["HasSubset.Subset", "Set", "Membership.mem"],
  "name": "Set.mem_of_mem_of_subset",
  "constType": "‚àÄ {Œ± : Type u} {x : Œ±} {s t : Set Œ±}, x ‚àà s ‚Üí s ‚äÜ t ‚Üí x ‚àà t",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "False.elim",
   "_private.Init.Data.Nat.Basic.0.Nat.lt_or_gt_of_ne.match_1_1",
   "Nat.lt_trichotomy",
   "Ne",
   "GT.gt"],
  "name": "Nat.lt_or_gt_of_ne",
  "constType": "‚àÄ {a b : ‚Ñï}, a ‚â† b ‚Üí a < b ‚à® a > b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddLeftMono", "rel_iff_cov", "LE.le", "AddLeftReflectLE"],
  "name": "add_le_add_iff_left",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : LE Œ±] [AddLeftMono Œ±] [AddLeftReflectLE Œ±] (a : Œ±) {b c : Œ±},\n  a + b ‚â§ a + c ‚Üî b ‚â§ c",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set.Nonempty",
   "Set",
   "Antitone",
   "NNReal",
   "NNReal.toReal",
   "Set.iInter"],
  "name": "SphericallyCompleteSpace.mk._flat_ctor",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±],\n  (‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n      (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty) ‚Üí\n    SphericallyCompleteSpace Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "id",
   "Classical.not_forall._simp_1",
   "eq_iff_iff._simp_1",
   "iff_false"],
  "name": "Lean.Grind.of_forall_eq_false",
  "constType":
  "‚àÄ (Œ± : Sort u) (p : Œ± ‚Üí Prop), (‚àÄ (x : Œ±), p x) = False ‚Üí ‚àÉ x, ¬¨p x",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Inv.inv", "inv_pos", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_4",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a : G‚ÇÄ},\n  (0 < a‚Åª¬π) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["csInf_le",
   "Set.Nonempty",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "InfSet.sInf",
   "le_csInf",
   "BddBelow"],
  "name": "csInf_le_csInf",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s t : Set Œ±},\n  BddBelow t ‚Üí s.Nonempty ‚Üí s ‚äÜ t ‚Üí sInf t ‚â§ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.zero_le_coe",
   "LE.le",
   "NNReal",
   "NNReal.toReal",
   "eq_true",
   "OfNat.ofNat"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.Quotient.0.SphericallyCompleteSpace.hhhh._simp_4",
  "constType": "‚àÄ {q : NNReal}, (0 ‚â§ ‚Üëq) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PadicAlgCl", "UniformSpace.Completion", "NNReal", "Nat.Prime"],
  "name": "PadicComplex",
  "constType": "(p : ‚Ñï) ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí Type",
  "constCategory": "Definition"},
 {"references": ["InfSet.sInf", "Set.range"],
  "name": "iInf",
  "constType": "{Œ± : Type u} ‚Üí {Œπ : Sort v} ‚Üí [InfSet Œ±] ‚Üí (Œπ ‚Üí Œ±) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "LinearMap.ker",
   "Membership.mem",
   "DFunLike.coe",
   "OfNat.ofNat",
   "propext",
   "LinearMap.mem_ker"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_1",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_11} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] {f : F} {y : M},\n  (y ‚àà LinearMap.ker f) = (f y = 0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MonadQuotation.getContext",
  "constType": "{m : Type ‚Üí Type} ‚Üí [self : MonadQuotation m] ‚Üí m Name",
  "constCategory": "Definition"},
 {"references": ["not_le", "LT.lt", "Not", "LE.le", "propext"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_9",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, (¬¨a ‚â§ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "propext",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí a = b",
  "constCategory": "Axiom"},
 {"references": ["LT.lt", "eq_true", "zero_lt_one", "OfNat.ofNat"],
  "name": "zero_lt_one._simp_1",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [ZeroLEOneClass Œ±] [NeZero 1],\n  (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Submodule.mem_bot", "Bot.bot", "OfNat.ofNat", "propext"],
  "name":
  "SphericallyCompleteSpace.instSphericallyCompleteSpaceContinuousLinearMap._simp_2",
  "constType":
  "‚àÄ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x ‚àà ‚ä•) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "AddLeftMono",
   "Nat.cast",
   "Eq.trans",
   "LT.lt.trans_le",
   "zero_lt_one",
   "Nat.mono_cast",
   "Eq.casesOn",
   "OfNat.ofNat",
   "congrArg",
   "Nat.cast_add",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Monotone.imp",
   "LE.le",
   "eq_of_heq",
   "Eq.symm",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.le_add_left._simp_1"],
  "name": "Nat.cast_add_one_pos",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [AddLeftMono Œ±] [ZeroLEOneClass Œ±] [NeZero 1]\n  (n : ‚Ñï), 0 < ‚Üën + 1",
  "constCategory": "Theorem"},
 {"references": ["Array.mkArray2", "Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.node2",
  "constType": "SourceInfo ‚Üí SyntaxNodeKind ‚Üí Syntax ‚Üí Syntax ‚Üí Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "Membership.mem",
   "LE.le",
   "Submodule.span_singleton_le_iff_mem",
   "Submodule.span",
   "propext"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_3",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (m : M)\n  (p : Submodule R M), (R ‚àô m ‚â§ p) = (m ‚àà p)",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_8",
  "constType":
  "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {f : Œ± ‚Üí Œ≤} {p : Œ≤ ‚Üí Prop}, (‚àÄ (b : Œ≤) (a : Œ±), f a = b ‚Üí p b) = ‚àÄ (a : Œ±), p (f a)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Set", "Membership.mem", "Iff.rfl"],
  "name": "AddSubsemigroup.mem_mk",
  "constType":
  "‚àÄ {M : Type u_1} [inst : Add M] {s : Set M} {x : M} (h_add : ‚àÄ {a b : M}, a ‚àà s ‚Üí b ‚àà s ‚Üí a + b ‚àà s),\n  x ‚àà { carrier := s, add_mem' := h_add } ‚Üî x ‚àà s",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "ite",
  "constType": "{Œ± : Sort u} ‚Üí (c : Prop) ‚Üí [h : Decidable c] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "ENNReal",
   "EMetric.infEdist_zero_of_mem",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "Membership.mem",
   "ENNReal.toReal",
   "OfNat.ofNat",
   "EMetric.infEdist",
   "congrArg"],
  "name": "Metric.infDist_zero_of_mem",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±}, x ‚àà s ‚Üí Metric.infDist x s = 0",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.trichotomy",
   "Eq.trans",
   "SummationFilter.unconditional",
   "Mem‚Ñìp.summable",
   "eq_true",
   "mem‚Ñìp_zero",
   "Set.range",
   "congrArg",
   "Mem‚Ñìp.bddAbove",
   "Mem‚Ñìp",
   "funext",
   "mem‚Ñìp_gen",
   "ENNReal.toReal",
   "Eq.symm",
   "Eq.ndrec",
   "Not",
   "Norm.norm",
   "Neg.neg",
   "HPow.hPow",
   "BddAbove",
   "OfNat.ofNat",
   "Summable",
   "LT.lt",
   "Or.casesOn",
   "ENNReal",
   "of_eq_true",
   "id",
   "Top.top",
   "norm_neg",
   "Ne",
   "Eq.mpr",
   "Set.Finite",
   "mem‚Ñìp_infty",
   "Mem‚Ñìp.finite_dsupport",
   "setOf",
   "inv_eq_one._simp_4"],
  "name": "Mem‚Ñìp.neg",
  "constType":
  "‚àÄ {Œ± : Type u_3} {E : Œ± ‚Üí Type u_4} {p : ENNReal} [inst : (i : Œ±) ‚Üí NormedAddCommGroup (E i)] {f : (i : Œ±) ‚Üí E i},\n  Mem‚Ñìp f p ‚Üí Mem‚Ñìp (-f) p",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_22",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x y : Œ±}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Subsingleton",
  "constType": "{Œ± : Type u} ‚Üí Set Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Nat.cast", "Mathlib.Tactic.Zify.natCast_lt", "propext"],
  "name": "Mathlib.Tactic.Zify.natCast_lt._simp_1",
  "constType": "‚àÄ (a b : ‚Ñï), (a < b) = (‚Üëa < ‚Üëb)",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Dist.dist",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "sub_zero",
   "dist_eq_norm_sub",
   "OfNat.ofNat",
   "congrArg"],
  "name": "dist_zero_right",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), dist a 0 = ‚Äña‚Äñ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OfNat.ofNat",
  "constType": "{Œ± : Type u} ‚Üí (x : ‚Ñï) ‚Üí [self : OfNat Œ± x] ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAdd.hAdd",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí {Œ≥ : outParam (Type w)} ‚Üí [self : HAdd Œ± Œ≤ Œ≥] ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥",
  "constCategory": "Definition"},
 {"references": ["Dist.dist", "LE.le", "setOf"],
  "name": "Metric.closedBall",
  "constType": "{Œ± : Type u} ‚Üí [PseudoMetricSpace Œ±] ‚Üí Œ± ‚Üí ‚Ñù ‚Üí Set Œ±",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.coe_mono",
   "LinearMap.range",
   "LinearMap.comp",
   "DFunLike.coe",
   "Set.range_comp_subset_range"],
  "name": "LinearMap.range_comp_le_range",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} {M : Type u_5} {M‚ÇÇ : Type u_6} {M‚ÇÉ : Type u_7} [inst : Semiring R]\n  [inst_1 : Semiring R‚ÇÇ] [inst_2 : Semiring R‚ÇÉ] [inst_3 : AddCommMonoid M] [inst_4 : AddCommMonoid M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÉ] [inst_6 : _root_.Module R M] [inst_7 : _root_.Module R‚ÇÇ M‚ÇÇ] [inst_8 : _root_.Module R‚ÇÉ M‚ÇÉ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÑ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÑ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} [inst_9 : RingHomCompTriple œÑ‚ÇÅ‚ÇÇ œÑ‚ÇÇ‚ÇÉ œÑ‚ÇÅ‚ÇÉ]\n  [inst_10 : RingHomSurjective œÑ‚ÇÇ‚ÇÉ] [inst_11 : RingHomSurjective œÑ‚ÇÅ‚ÇÉ] (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (g : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÑ‚ÇÇ‚ÇÉ] M‚ÇÉ),\n  LinearMap.range (g ‚àò‚Çõ‚Çó f) ‚â§ LinearMap.range g",
  "constCategory": "Theorem"},
 {"references": ["Nat.le_trans", "Nat.le_succ", "LE.le"],
  "name": "Nat.le_of_succ_le",
  "constType": "‚àÄ {n m : ‚Ñï}, n.succ ‚â§ m ‚Üí n ‚â§ m",
  "constCategory": "Theorem"},
 {"references": ["Iff.trans", "Max.max", "sup_eq_left", "eq_comm", "LE.le"],
  "name": "left_eq_sup",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, a = a ‚äî b ‚Üî b ‚â§ a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "IsChain",
   "Subtype.ext_iff",
   "Set",
   "Membership.mem",
   "zorn_le",
   "Iff.mp",
   "_private.Mathlib.Order.Zorn.0.zorn_le‚ÇÄ.match_1_7",
   "Subtype.val",
   "BddAbove",
   "Set.Elem",
   "Exists.casesOn",
   "_private.Mathlib.Order.Zorn.0.zorn_le‚ÇÄ.match_1_5",
   "_private.Mathlib.Order.Zorn.0.zorn_le‚ÇÄ.match_1_3",
   "_private.Mathlib.Order.Zorn.0.zorn_le‚ÇÄ.match_1_1",
   "Set.image",
   "Maximal",
   "HasSubset.Subset",
   "upperBounds",
   "LE.le",
   "IsMax",
   "Ne",
   "Eq.ndrec",
   "And.casesOn"],
  "name": "zorn_le‚ÇÄ",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (s : Set Œ±),\n  (‚àÄ c ‚äÜ s, IsChain (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) c ‚Üí ‚àÉ ub ‚àà s, ‚àÄ z ‚àà c, z ‚â§ ub) ‚Üí ‚àÉ m, Maximal (fun x ‚Ü¶ x ‚àà s) m",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.¬´term_‚üÇ‚Çõ_¬ª",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Neg.neg", "Iff.mpr", "OfNat.ofNat", "neg_neg_iff_pos"],
  "name": "neg_neg_of_pos",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedAddMonoid Œ±] {a : Œ±}, 0 < a ‚Üí -a < 0",
  "constCategory": "Theorem"},
 {"references": ["Set", "isClosed_closure", "closure", "IsClosed.closure_eq"],
  "name": "closure_eq_iff_isClosed",
  "constType":
  "‚àÄ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, closure s = s ‚Üî IsClosed s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} ‚Üí {motive : a ‚àß b ‚Üí Sort u} ‚Üí (t : a ‚àß b) ‚Üí ((left : a) ‚Üí (right : b) ‚Üí motive ‚ãØ) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references":
  ["NNReal.coe_le_coe", "LE.le", "NNReal", "NNReal.toReal", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_10",
  "constType": "‚àÄ {r‚ÇÅ r‚ÇÇ : NNReal}, (‚Üër‚ÇÅ ‚â§ ‚Üër‚ÇÇ) = (r‚ÇÅ ‚â§ r‚ÇÇ)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Inter.inter", "Membership.mem", "Set.mem_inter_iff", "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} (x : Œ±) (a b : Set Œ±), (x ‚àà a ‚à© b) = (x ‚àà a ‚àß x ‚àà b)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "zero_add",
   "Nat.cast",
   "Nat.cast_zero",
   "id",
   "Eq.mpr",
   "Nat.cast_succ",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.cast_one",
  "constType": "‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R], ‚Üë1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "lp",
   "LinearMap.range",
   "Membership.mem",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Membership.mem.out",
   "Subtype.val",
   "DFunLike.coe",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_10",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_6",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "RingHom.id",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_8",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_5",
   "lp.instNormedSpace._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_11",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_3",
   "And.left",
   "rfl",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "PreLp",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_2",
   "Exists.choose_spec",
   "Set",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "LinearMap.mem_range_self",
   "Exists.choose",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_1",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp._proof_4",
   "SphericallyCompleteSpace.IsImmediate",
   "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp",
   "ENNReal",
   "SphericallyCompleteSpace.SphericalCompletion",
   "Maximal",
   "HSMul.hSMul",
   "LE.le",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_5",
  "constType":
  "‚àÄ (ùïú : Type u_2) [inst : NontriviallyNormedField ùïú] (E : Type u_1) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] (x : ùïú) (x_1 : E),\n  ‚ü®(SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) (x ‚Ä¢ x_1), ‚ãØ‚ü© =\n    ‚ü®(SphericallyCompleteSpace.sphericallyCompleteExtension ùïú E) (x ‚Ä¢ x_1), ‚ãØ‚ü©",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_refl"],
  "name": "le_refl",
  "constType": "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a : Œ±), a ‚â§ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SphericallyCompleteSpace.SphericalCompletion._proof_1",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] (i : ‚Ñï), IsBoundedSMul ùïú E",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "NegMemClass.neg_mem"],
  "name": "Submodule.neg_mem",
  "constType":
  "‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x : M}, x ‚àà p ‚Üí -x ‚àà p",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val",
   "And.left"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_5",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (M : ‚Ü•(D + ùïú ‚àô a)) (this : ‚àÉ y ‚àà D, ‚àÉ z ‚àà ùïú ‚àô a, y + z = ‚ÜëM),\n  this.choose ‚àà D",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Subtype.mk.injEq",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "forall_congr",
   "Membership.mem",
   "Set.mem_range_self",
   "Set.range",
   "congrArg"],
  "name": "Set.rangeFactorization_injective",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort u_1} {f : Œπ ‚Üí Œ±}, Function.Injective (Set.rangeFactorization f) ‚Üî Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "le_refl",
   "sub_add_cancel",
   "Eq.trans",
   "Membership.mem",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._proof_1_4",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._simp_1_3",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "le_max_of_le_right",
   "sub_add_sub_cancel",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "not_false_eq_true",
   "False.elim",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "StrictAnti.antitone",
   "HSub.hSub",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._proof_1_5",
   "norm_zero",
   "add_comm",
   "QuotientAddGroup.mk'",
   "sub_self",
   "Norm.norm",
   "Neg.neg",
   "And.right",
   "NNReal",
   "Nat.recAux",
   "Submodule.toAddSubgroup",
   "Mathlib.Tactic.Abel.term_add_constg",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.mk_eq_and_norm_sub_lt",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max._simp_1_1",
   "SphericallyCompleteSpace.c‚ÇÄ._simp_4",
   "Decidable.byContradiction",
   "zero_add",
   "lp.norm_apply_le_norm",
   "eq_false",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Antitone",
   "Int.negOfNat",
   "Top.top",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "max_le",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "IsUltrametricDist.norm_add_le_max",
   "HasQuotient.Quotient",
   "Eq.mp",
   "lp",
   "max_le_max",
   "Mathlib.Tactic.Abel.unfold_sub",
   "le_trans",
   "NNReal.toReal",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_neg",
   "DFunLike.coe",
   "congrArg",
   "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section",
   "not_true_eq_false",
   "Mathlib.Tactic.Abel.termg",
   "Not",
   "PreLp",
   "Set",
   "ENNReal.top_ne_zero",
   "Nat.zero_le",
   "Mathlib.Tactic.Abel.term_neg",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "StrictAnti",
   "Metric.closedBall",
   "Max.max",
   "ENNReal",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "QuotientAddGroup.mk",
   "inferInstance",
   "dite"],
  "name":
  "_private.SphericalCompleteness.NormedVectorSpace.SphericalCompletion.SphericallyCompleteExtension.0.SphericallyCompleteSpace.quotient_mk_section_norm_apply_self_le_max",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] (E : ‚Ñï ‚Üí Type u_2) [inst_1 : (i : ‚Ñï) ‚Üí NormedAddCommGroup (E i)]\n  [inst_2 : (i : ‚Ñï) ‚Üí NormedSpace ùïú (E i)] [iiud : ‚àÄ (i : ‚Ñï), IsUltrametricDist (E i)]\n  ‚¶Éc : ‚Ñï ‚Üí ‚Ü•(lp E ‚ä§) ‚ß∏ SphericallyCompleteSpace.c‚ÇÄ ùïú E‚¶Ñ ‚¶Ér : ‚Ñï ‚Üí NNReal‚¶Ñ (hsr : StrictAnti r)\n  (hanti : Antitone fun i ‚Ü¶ Metric.closedBall (c i) ‚Üë(r i)) (n : ‚Ñï),\n  ‚Äñ‚Üë‚Üë(SphericallyCompleteSpace.quotient_mk_section‚úù E hsr hanti n) n‚Äñ ‚â§\n    max ‚Äñ‚Üë(SphericallyCompleteSpace.quotient_mk_section‚úù¬π E hsr hanti 0)‚Äñ\n      (max ‚Äñ‚Üë(SphericallyCompleteSpace.quotient_mk_section‚úù¬≤ E hsr hanti 1)‚Äñ ‚Üë(r 0))",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Iff.mp",
  "constType": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí a ‚Üí b",
  "constCategory": "Theorem"},
 {"references": ["Int.cast"],
  "name": "Int.rawCast",
  "constType": "{Œ± : Type u} ‚Üí [Ring Œ±] ‚Üí ‚Ñ§ ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "add_sub_assoc",
   "sub_add_cancel",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "congrArg"],
  "name": "sub_add_sub_cancel",
  "constType":
  "‚àÄ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - b + (b - c) = a - c",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat.cast",
   "Unit",
   "_private.Mathlib.Tactic.NormNum.Result.0.Mathlib.Meta.NormNum.IsNat.to_eq.match_1_1"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : AddMonoidWithOne Œ±] {n : ‚Ñï} {a a' : Œ±}, Mathlib.Meta.NormNum.IsNat a n ‚Üí ‚Üën = a' ‚Üí a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "AddSubmonoid.mem_mk",
   "propext",
   "OfNat.ofNat"],
  "name":
  "SphericallyCompleteSpace.quotient_norm_mk_le_of_eventually_norm_le._simp_1_4",
  "constType":
  "‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubsemigroup M} {x : M} (h_zero : 0 ‚àà s.carrier),\n  (x ‚àà { toAddSubsemigroup := s, zero_mem' := h_zero }) = (x ‚àà s)",
  "constCategory": "Theorem"},
 {"references": ["eq_self", "Eq.trans", "of_eq_true", "Neg.neg", "congrArg"],
  "name": "Mathlib.Tactic.Abel.subst_into_negg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (a ta t : Œ±), a = ta ‚Üí -ta = t ‚Üí -a = t",
  "constCategory": "Theorem"},
 {"references":
  ["Metric.closedBall",
   "Set",
   "Metric.mem_closedBall",
   "Dist.dist",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x y : Œ±} {Œµ : ‚Ñù}, (y ‚àà Metric.closedBall x Œµ) = (dist y x ‚â§ Œµ)",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "Module.Basis.linearIndependent",
   "Eq.trans",
   "disjoint_bot_right._simp_1",
   "Submodule.map",
   "Membership.mem",
   "Submodule.span",
   "Module.Basis.ofVectorSpace",
   "LinearIndependent.linearIndepOn_id",
   "Subtype.val",
   "Set.Elem",
   "Submodule.subtype",
   "Module.finrank",
   "RingHom.id",
   "Disjoint",
   "Set.subset_univ",
   "Eq.symm",
   "LinearIndepOn",
   "rfl",
   "Set.card_image_of_injective",
   "LinearMap.ker",
   "Submodule.coe_subtype",
   "LinearIndepOn.subset_extend",
   "Bot.bot",
   "Submodule.range_subtype",
   "Set.image",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "Set.Finite.fintype",
   "Submodule.ker_subtype",
   "FiniteDimensional",
   "Eq.mp",
   "LinearMap.range",
   "Submodule.map_top",
   "LinearIndepOn.image",
   "Module.Basis.coe_extend",
   "Module.Basis.extend",
   "Set.image_congr",
   "DFunLike.coe",
   "Set.range",
   "LinearIndependent.set_finite_of_isNoetherian",
   "LinearIndependent",
   "congrArg",
   "LinearIndepOn.extend",
   "Fintype.card",
   "congr",
   "Module.finrank_eq_card_basis",
   "Submodule.span_image",
   "Module.Basis.coe_ofVectorSpace",
   "Module.Basis.span_eq",
   "Set",
   "Subtype.range_coe_subtype",
   "Set.univ",
   "Subtype.range_coe",
   "Subtype.coe_injective",
   "of_eq_true",
   "Module.Basis.ofVectorSpaceIndex",
   "Set.eq_of_subset_of_card_le",
   "LE.le"],
  "name": "Submodule.eq_top_of_finrank_eq",
  "constType":
  "‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]\n  [FiniteDimensional K V] {S : Submodule K V}, Module.finrank K ‚Ü•S = Module.finrank K V ‚Üí S = ‚ä§",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DenselyNormedField.lt_norm_lt",
  "constType":
  "‚àÄ {Œ± : Type u_5} [self : DenselyNormedField Œ±] (x y : ‚Ñù), 0 ‚â§ x ‚Üí x < y ‚Üí ‚àÉ a, x < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < y",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_4",
  "constType": "‚àÄ {a b c : Prop}, (a ‚àß b ‚Üí c) = (a ‚Üí b ‚Üí c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubsemigroup.carrier",
   "Set",
   "Membership.mem",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "AddSubmonoid.mk.congr_simp",
  "constType":
  "‚àÄ {M : Type u_3} [inst : AddZeroClass M] (toAddSubsemigroup toAddSubsemigroup_1 : AddSubsemigroup M)\n  (e_toAddSubsemigroup : toAddSubsemigroup = toAddSubsemigroup_1) (zero_mem' : 0 ‚àà toAddSubsemigroup.carrier),\n  { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' } =\n    { toAddSubsemigroup := toAddSubsemigroup_1, zero_mem' := ‚ãØ }",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.direct_prod_iso_sum_of_orth._simp_8",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 ‚â§ ‚Äña‚Äñ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.substr",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "Eq.symm",
   "congrArg"],
  "name": "forall_prop_domain_congr",
  "constType":
  "‚àÄ {p‚ÇÅ p‚ÇÇ : Prop} {q‚ÇÅ : p‚ÇÅ ‚Üí Prop} {q‚ÇÇ : p‚ÇÇ ‚Üí Prop} (h‚ÇÅ : p‚ÇÅ = p‚ÇÇ),\n  (‚àÄ (a : p‚ÇÇ), q‚ÇÅ ‚ãØ = q‚ÇÇ a) ‚Üí (‚àÄ (a : p‚ÇÅ), q‚ÇÅ a) = ‚àÄ (a : p‚ÇÇ), q‚ÇÇ a",
  "constCategory": "Theorem"},
 {"references": ["csInf_le", "Set", "Membership.mem", "OrderBot.bddBelow"],
  "name": "csInf_le'",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Œ±] {s : Set Œ±} {a : Œ±}, a ‚àà s ‚Üí sInf s ‚â§ a",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius._simp_1_3",
  "constType": "‚àÄ {a b c : Prop}, (a ‚àß b ‚Üí c) = (a ‚Üí b ‚Üí c)",
  "constCategory": "Theorem"},
 {"references": ["LinearIsometry.toLinearMap", "LinearIsometry.continuous"],
  "name": "LinearIsometry.toContinuousLinearMap",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : _root_.Module R E] ‚Üí [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_3",
   "Subtype.val",
   "Set.Elem",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_7",
   "HDiv.hDiv",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_6",
   "InfSet.sInf",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_4",
   "Set",
   "NNReal",
   "Nat.brecOn",
   "Prod.snd",
   "Exists.choose",
   "HPow.hPow",
   "OfNat.ofNat",
   "Nonempty.some",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_2",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball.match_1",
   "Min.min",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_1",
   "Nat.below",
   "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball._proof_5",
   "setOf"],
  "name":
  "_private.SphericalCompleteness.Basic.0.SphericallyCompleteSpace.countable_chain_of_ball",
  "constType":
  "{Œ± : Type u_1} ‚Üí\n  [PseudoMetricSpace Œ±] ‚Üí\n    {S : Set (Œ± √ó NNReal)} ‚Üí [hS : Nonempty ‚ÜëS] ‚Üí (‚àÄ w ‚àà S, sInf {x | ‚àÉ w ‚àà S, w.2 = x} < w.2) ‚Üí ‚Ñï ‚Üí ‚ÜëS",
  "constCategory": "Definition"},
 {"references":
  ["IsChain",
   "Set.Nonempty",
   "Set",
   "le_trans",
   "LE.le",
   "exists_maximal_of_nonempty_chains_bounded",
   "BddAbove"],
  "name": "zorn_le_nonempty",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) c ‚Üí c.Nonempty ‚Üí BddAbove c) ‚Üí ‚àÉ m, IsMax m",
  "constCategory": "Theorem"},
 {"references":
  ["le_max_right", "Max.max", "eq_max", "LE.le", "le_max_left", "max_le"],
  "name": "max_comm",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (a b : Œ±), max a b = max b a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Neg.neg",
  "constType": "{Œ± : Type u} ‚Üí [self : Neg Œ±] ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Set.iInter",
   "Membership.mem.out",
   "sub_zero",
   "Left.mul_nonneg",
   "Subtype.val",
   "Set.Elem",
   "sub_eq_add_neg",
   "RingHom.id",
   "Eq.symm",
   "Eq.ndrec",
   "Set.iInter_congr_Prop",
   "rfl",
   "Exists.choose_spec",
   "Norm.norm",
   "NNReal",
   "Set.Nonempty.some_mem",
   "Set.iInter_coe_set",
   "Prod.snd",
   "Mathlib.Tactic.Abel.term_add_constg",
   "Classical.em",
   "map_add",
   "Int.negOfNat",
   "mul_max_of_nonneg",
   "norm_neg",
   "Eq.mpr",
   "Exists.choose.congr_simp",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "max_le",
   "sup_le_sup_right",
   "dist_eq_norm",
   "le_sup_iff",
   "Mathlib.Meta.NormNum.isInt_neg",
   "map_sub",
   "Prod.fst",
   "mul_le_mul_of_nonneg_right",
   "congr",
   "Subtype.property",
   "map_zero",
   "Mathlib.Tactic.Abel.termg",
   "propext",
   "lt_of_not_ge",
   "dist_comm",
   "Set",
   "mul_nonneg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Metric.closedBall",
   "eq_self",
   "Max.max",
   "max_le_max_left",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_3",
   "norm_nonneg",
   "max_assoc",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_1",
   "le_refl",
   "Inter.inter",
   "Membership.mem",
   "Iff.mp",
   "Subtype.mk.congr_simp",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "forall_congr",
   "funext",
   "HSub.hSub",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "max_eq_left",
   "max_comm",
   "Neg.neg",
   "mul_le_mul_of_nonneg_left",
   "Set.inter_comm",
   "Set.Nonempty.some",
   "add_zero",
   "Exists.casesOn",
   "zero_add",
   "Iff.of_eq",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "id",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "IsUltrametricDist.norm_add_le_max",
   "Eq.mp",
   "Metric.mem_closedBall",
   "Mathlib.Tactic.Abel.unfold_sub",
   "max_le_max",
   "le_trans",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_2",
   "NNReal.toReal",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_add",
   "DFunLike.coe",
   "congrArg",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_5",
   "Subtype.prop",
   "Dist.dist",
   "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_4",
   "Not",
   "dist_self",
   "Set.Nonempty",
   "ContinuousLinearMap.le_opNorm",
   "Exists.choose",
   "Mathlib.Tactic.Abel.term_neg",
   "Submodule.sub_mem_iff_left",
   "exists_prop_congr",
   "Or.casesOn",
   "LT.lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Mathlib.Tactic.Abel.const_add_termg",
   "add_sub_add_right_eq_sub"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [iude : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E},\n  a ‚àâ D ‚Üí\n    ‚àÄ {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [iud : IsUltrametricDist F] [inst_4 : NormedSpace ùïú F]\n      [hsc : SphericallyCompleteSpace F] (S : ‚Ü•D ‚ÜíL[ùïú] F) {ùí∞ : Set (E ‚ÜíL[ùïú] F)},\n      ùí∞.Nonempty ‚Üí\n        ‚àÄ {Œµ : ‚Üëùí∞ ‚Üí ‚Ñù},\n          (‚àÄ (T : ‚Üëùí∞), 0 < Œµ T) ‚Üí\n            (‚àÄ (U V : ‚Üëùí∞), ‚Äñ‚ÜëU - ‚ÜëV‚Äñ ‚â§ max (Œµ U) (Œµ V)) ‚Üí\n              (‚àÄ (U : ‚Üëùí∞) (x : ‚Ü•D), ‚ÄñS x - ‚ÜëU ‚Üëx‚Äñ ‚â§ Œµ U * ‚Äñx‚Äñ) ‚Üí\n                ‚àÉ z0, ‚àÄ (x : ‚Ü•D) (U : ‚Üëùí∞), ‚ÄñS x + z0 - ‚ÜëU (‚Üëx + a)‚Äñ ‚â§ Œµ U * ‚Äñ‚Üëx + a‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Sort u} {p : Œ± ‚Üí Prop} {q : { a // p a } ‚Üí Prop}, (‚àÄ (x : { a // p a }), q x) = ‚àÄ (a : Œ±) (b : p a), q ‚ü®a, b‚ü©",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "ContinuousLinearMap.id",
   "forall_eq._simp_1",
   "Eq.trans",
   "Eq.mp",
   "Singleton.singleton",
   "Membership.mem",
   "HMul.hMul",
   "sub_zero",
   "Subtype.val",
   "DFunLike.coe",
   "Set.Elem",
   "congrArg",
   "SphericallyCompleteSpace.exists_extension_opNorm_le",
   "RingHom.id",
   "congr",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_1",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_2",
   "norm_zero",
   "forall_prop_domain_congr",
   "zero_lt_one._simp_1",
   "le_refl._simp_1",
   "Set.Nonempty",
   "Norm.norm",
   "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space._simp_1_3",
   "Set",
   "zero_le_one._simp_1",
   "OfNat.ofNat",
   "Exists.casesOn",
   "LT.lt",
   "eq_self",
   "implies_true",
   "Max.max",
   "of_eq_true",
   "max_self",
   "LE.le",
   "Subtype.forall._simp_1",
   "Set.singleton_nonempty._simp_1",
   "Set.mem_singleton_iff._simp_1",
   "one_mul",
   "And.casesOn"],
  "name":
  "SphericallyCompleteSpace.exists_orthproj_of_spherically_complete_space",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [iud : IsUltrametricDist E] [inst_2 : NormedSpace ùïú E] (F : Submodule ùïú E) [SphericallyCompleteSpace ‚Ü•F],\n  ‚àÉ T, (‚àÄ a ‚àà F, ‚Üë(T a) = a) ‚àß ‚ÄñT‚Äñ ‚â§ 1",
  "constCategory": "Theorem"},
 {"references": ["Not", "False.elim", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "‚àÄ {p : Prop} [dec : Decidable p], (¬¨p ‚Üí False) ‚Üí p",
  "constCategory": "Theorem"},
 {"references":
  ["Inv.inv",
   "inv_mul_le_iff‚ÇÄ",
   "HMul.hMul",
   "mul_one",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "inv_le_iff_one_le_mul‚ÇÄ'",
  "constType":
  "‚àÄ {G‚ÇÄ : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : PartialOrder G‚ÇÄ] [PosMulReflectLT G‚ÇÄ] {a b : G‚ÇÄ},\n  0 < a ‚Üí (a‚Åª¬π ‚â§ b ‚Üî 1 ‚â§ a * b)",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "Maximal",
  "constType": "{Œ± : Type u_1} ‚Üí [LE Œ±] ‚Üí (Œ± ‚Üí Prop) ‚Üí Œ± ‚Üí Prop",
  "constCategory": "Definition"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{Œ± : Type u} ‚Üí [Ring Œ±] ‚Üí AddMonoidWithOne Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LinearIsometry.toLinearMap",
   "LinearIsometryEquiv.ofSurjective._proof_2",
   "DFunLike.coe",
   "Function.Surjective",
   "LinearIsometryEquiv.ofSurjective._proof_1",
   "LinearEquiv.ofBijective"],
  "name": "LinearIsometryEquiv.ofSurjective",
  "constType":
  "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E‚ÇÇ : Type u_6} ‚Üí\n      {F : Type u_9} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                      [inst_5 : _root_.Module R‚ÇÇ E‚ÇÇ] ‚Üí\n                        [inst_6 : NormedAddCommGroup F] ‚Üí\n                          [inst_7 : _root_.Module R F] ‚Üí (f : F ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí Function.Surjective ‚áëf ‚Üí F ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "NNReal",
   "Inter.inter",
   "Iff.mp",
   "NNReal.toReal",
   "List.tfae_of_cycle",
   "Prod.snd",
   "Set.iInter",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Metric.closedBall",
   "StrictAnti",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_antitone_radius",
   "Iff.mpr",
   "Antitone",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_pairwise_inter_nonempty",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_iff_strictAnti_radius"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteSpace_equiv",
  "constType":
  "‚àÄ (Œ± : Type u_1) [inst : PseudoMetricSpace Œ±] [iud : IsUltrametricDist Œ±],\n  [SphericallyCompleteSpace Œ±,\n      ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n        Antitone ri ‚Üí\n          (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty,\n      ‚àÄ ‚¶Éci : ‚Ñï ‚Üí Œ±‚¶Ñ ‚¶Éri : ‚Ñï ‚Üí NNReal‚¶Ñ,\n        StrictAnti ri ‚Üí\n          (Antitone fun i ‚Ü¶ Metric.closedBall (ci i) ‚Üë(ri i)) ‚Üí (‚ãÇ i, Metric.closedBall (ci i) ‚Üë(ri i)).Nonempty,\n      ‚àÄ (S : Set (Œ± √ó NNReal)),\n        S.Nonempty ‚Üí\n          (‚àÄ (w1 w2 : ‚ÜëS), (Metric.closedBall (‚Üëw1).1 ‚Üë(‚Üëw1).2 ‚à© Metric.closedBall (‚Üëw2).1 ‚Üë(‚Üëw2).2).Nonempty) ‚Üí\n            (‚ãÇ w, Metric.closedBall (‚Üëw).1 ‚Üë(‚Üëw).2).Nonempty].TFAE",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{Œ± : Sort u} ‚Üí Œ± ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references": ["Max.max", "LE.le", "sup_le_iff", "propext"],
  "name":
  "SphericallyCompleteSpace.not_sphericallyCompleteSpace_of_isSphericallyDense_separable_ultrametric._simp_1_5",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b c : Œ±}, (a ‚äî b ‚â§ c) = (a ‚â§ c ‚àß b ‚â§ c)",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.smul_orth_of_orth",
   "Eq.mp",
   "Membership.mem",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "SphericallyCompleteSpace.Orth",
   "propext",
   "SphericallyCompleteSpace.MOrth",
   "Subspace",
   "SphericallyCompleteSpace.morth_iff_forall_orth",
   "congrArg"],
  "name": "SphericallyCompleteSpace.smul_morth_of_morth",
  "constType":
  "‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] [inst_3 : IsUltrametricDist E] {x : E} {F : Subspace ùïú E} (a : ùïú),\n  SphericallyCompleteSpace.MOrth ùïú x F ‚Üí SphericallyCompleteSpace.MOrth ùïú (a ‚Ä¢ x) F",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Eq.trans",
   "add_add_add_comm",
   "congr",
   "HSMul.hSMul",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.Abel.termg",
   "add_zsmul",
   "congrArg"],
  "name": "Mathlib.Tactic.Abel.term_add_termg",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (n‚ÇÅ : ‚Ñ§) (x a‚ÇÅ : Œ±) (n‚ÇÇ : ‚Ñ§) (a‚ÇÇ : Œ±) (n' : ‚Ñ§) (a' : Œ±),\n  n‚ÇÅ + n‚ÇÇ = n' ‚Üí\n    a‚ÇÅ + a‚ÇÇ = a' ‚Üí\n      Mathlib.Tactic.Abel.termg n‚ÇÅ x a‚ÇÅ + Mathlib.Tactic.Abel.termg n‚ÇÇ x a‚ÇÇ = Mathlib.Tactic.Abel.termg n' x a'",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.ext",
   "Eq.symm",
   "Prod.snd",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn",
   "Prod.fst"],
  "name": "Prod.ext_iff",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {x y : Œ± √ó Œ≤}, x = y ‚Üî x.1 = y.1 ‚àß x.2 = y.2",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Set.mem_range", "Set.range", "propext"],
  "name":
  "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_6",
  "constType":
  "‚àÄ {Œ± : Type u} {Œπ : Sort u_1} {f : Œπ ‚Üí Œ±} {x : Œ±}, (x ‚àà Set.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass.zero_mem",
   "outParam",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.smul_orth_of_orth._simp_1_2",
  "constType":
  "‚àÄ {S : Type u_3} {M : outParam (Type u_4)} {inst : Zero M} {inst_1 : SetLike S M} [self : ZeroMemClass S M] (s : S),\n  (0 ‚àà s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Norm.norm",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "sub_neg_eq_add",
   "le_max_iff",
   "sub_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "zero_add",
   "Max.max",
   "IsUltrametricDist.dist_triangle_max",
   "congr",
   "LE.le",
   "Dist.dist",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "dist_eq_norm_sub",
   "propext"],
  "name": "IsUltrametricDist.norm_add_le_max",
  "constType":
  "‚àÄ {S : Type u_1} [inst : SeminormedAddGroup S] [IsUltrametricDist S] (x y : S), ‚Äñx + y‚Äñ ‚â§ max ‚Äñx‚Äñ ‚Äñy‚Äñ",
  "constCategory": "Theorem"},
 {"references": ["Classical.propDecidable", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "‚àÄ {a : Prop}, ¬¨¬¨a ‚Üî a",
  "constCategory": "Theorem"},
 {"references": ["Set.Nonempty", "Set", "le_csInf_iff", "OrderBot.bddBelow"],
  "name": "le_csInf_iff''",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Œ±] {s : Set Œ±} {a : Œ±},\n  s.Nonempty ‚Üí (a ‚â§ sInf s ‚Üî ‚àÄ b ‚àà s, a ‚â§ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_add",
   "_private.Mathlib.Tactic.NormNum.Basic.0.Mathlib.Meta.NormNum.isInt_add.match_1_1",
   "Int.add",
   "HAdd.hAdd",
   "Eq.symm",
   "Int.cast"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {f : Œ± ‚Üí Œ± ‚Üí Œ±} {a b : Œ±} {a' b' c : ‚Ñ§},\n  f = HAdd.hAdd ‚Üí\n    Mathlib.Meta.NormNum.IsInt a a' ‚Üí\n      Mathlib.Meta.NormNum.IsInt b b' ‚Üí a'.add b' = c ‚Üí Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "LinearMap.range",
   "Membership.mem",
   "LinearMap.mem_range",
   "DFunLike.coe",
   "propext"],
  "name": "SphericallyCompleteSpace.exists_max_imm_ext_in_sph_comp._simp_1_11",
  "constType":
  "‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_5} {M‚ÇÇ : Type u_6} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R‚ÇÇ M‚ÇÇ]\n  {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_10} [inst_6 : FunLike F M M‚ÇÇ] [inst_7 : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ]\n  [inst_8 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ}, (x ‚àà LinearMap.range f) = ‚àÉ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe_eq_coe", "Membership.mem", "Subtype.val", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_12",
  "constType":
  "‚àÄ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ‚Ü•p}, (‚Üëx = ‚Üëy) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["exists_and_right", "propext"],
  "name":
  "SphericallyCompleteSpace.exists_morth_vec_of_not_full_finrank._simp_1_16",
  "constType":
  "‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop} {b : Prop}, (‚àÉ x, p x ‚àß b) = ((‚àÉ x, p x) ‚àß b)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "LE.le", "eq_true", "le_sup_left"],
  "name": "SphericallyCompleteSpace.exists_extension_opNorm_le._simp_1_1",
  "constType":
  "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, (a ‚â§ a ‚äî b) = True",
  "constCategory": "Theorem"},
 {"references": ["inv_smul_smul", "Units.mk0", "Ne", "OfNat.ofNat"],
  "name": "inv_smul_smul‚ÇÄ",
  "constType":
  "‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} [inst : GroupWithZero Œ±] [inst_1 : MulAction Œ± Œ≤] {a : Œ±},\n  a ‚â† 0 ‚Üí ‚àÄ (x : Œ≤), a‚Åª¬π ‚Ä¢ a ‚Ä¢ x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Membership.mem",
   "Set.nonempty_iInter",
   "Set.iInter",
   "propext"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_z0._simp_1_4",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_5} {f : Œπ ‚Üí Set Œ±}, (‚ãÇ i, f i).Nonempty = ‚àÉ x, ‚àÄ (i : Œπ), x ‚àà f i",
  "constCategory": "Theorem"},
 {"references": ["Norm.norm", "LE.le", "eq_true", "norm_nonneg", "OfNat.ofNat"],
  "name": "SphericallyCompleteSpace.hahn_banach'._simp_1_5",
  "constType":
  "‚àÄ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), (0 ‚â§ ‚Äña‚Äñ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "Nat.cast_zero",
   "OfNat.ofNat",
   "congrArg",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.cast_zero.match_1_1"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 ‚Üí a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.ext",
   "Submodule.toAddSubmonoid",
   "Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "Subtype.val",
   "Submodule.add_mem_sup",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "RingHom.id",
   "Subtype.coe_eta",
   "Eq.symm",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_zero",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_5",
   "And.left",
   "LinearMap.ker",
   "Neg.neg",
   "And.right",
   "iff_true",
   "Mathlib.Tactic.Abel.term_add_constg",
   "LinearMap.sub_mem_ker_iff",
   "Bot.bot",
   "zero_add",
   "IsCompl.of_eq",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Int.negOfNat",
   "id",
   "Top.top",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Abel.term_atomg",
   "AddSubmonoid.mk_eq_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Abel.term_add_termg",
   "Mathlib.Tactic.Abel.zero_termg",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_3",
   "Eq.mp",
   "Mathlib.Tactic.Abel.unfold_sub",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "Mathlib.Meta.NormNum.isInt_neg",
   "DFunLike.coe",
   "congrArg",
   "Subtype.prop",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_2",
   "congr",
   "map_zero",
   "Mathlib.Tactic.Abel.termg",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_1",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_6",
   "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_4",
   "Mathlib.Tactic.Abel.term_neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "and_self",
   "Max.max",
   "of_eq_true",
   "Min.min",
   "Mathlib.Tactic.Abel.const_add_termg"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp",
  "constType":
  "‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [IsUltrametricDist E]\n  [inst_3 : NormedSpace ùïú E] (F : Submodule ùïú E) [SphericallyCompleteSpace ‚Ü•F] (T : E ‚ÜíL[ùïú] ‚Ü•F),\n  (‚àÄ (a : E) (b : a ‚àà F), T a = ‚ü®a, b‚ü©) ‚Üí IsCompl F (LinearMap.ker T)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "mul_add",
   "HMul.hMul",
   "HPow.hPow",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf",
  "constType":
  "‚àÄ {R : Type u_1} [inst : CommSemiring R] {a b c : R} (x : R) (e : ‚Ñï), a + b = c ‚Üí x ^ e * a + x ^ e * b = x ^ e * c",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Membership.mem", "Submodule.mem_inf", "propext"],
  "name": "SphericallyCompleteSpace.orth_of_orthcomp._simp_1_1",
  "constType":
  "‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M} {x : M}, (x ‚àà p ‚äì q) = (x ‚àà p ‚àß x ‚àà q)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_3",
   "Eq.trans",
   "lp",
   "Singleton.singleton",
   "Membership.mem",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_3",
   "Set.range",
   "congrArg",
   "Set.mem_setOf",
   "Mem‚Ñìp",
   "zero_mem‚Ñìp",
   "forall_congr",
   "funext",
   "Set.range_const",
   "PreLp",
   "Mem‚Ñìp.add",
   "Norm.norm",
   "Set",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_2",
   "Mem‚Ñìp.neg",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_2",
   "SphericallyCompleteSpace.sphericallyCompleteExtension._simp_1",
   "HAdd.hAdd",
   "ENNReal",
   "of_eq_true",
   "upperBounds",
   "SphericallyCompleteSpace.sphericallyCompleteSpace_lp_quotient_c‚ÇÄ._simp_4",
   "Iff.mpr",
   "LE.le",
   "id",
   "Top.top",
   "Eq.mpr",
   "mem‚Ñìp_infty",
   "setOf"],
  "name": "SphericallyCompleteSpace.sphericallyCompleteExtension._proof_4",
  "constType":
  "‚àÄ (E : Type u_1) [inst : NormedAddCommGroup E] (x y : E), (fun x_1 ‚Ü¶ x + y) ‚àà lp (fun x ‚Ü¶ E) ‚ä§",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "neg_inj", "propext"],
  "name": "SphericallyCompleteSpace.sorth_orthcomp._simp_1_2",
  "constType":
  "‚àÄ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = -b) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "add_left_inj", "propext"],
  "name":
  "SphericallyCompleteSpace.instSubtypeMemSubmoduleChooseMaximalSetImm_ext_in_sph_comp._simp_15",
  "constType":
  "‚àÄ {G : Type u_1} [inst : Add G] [IsRightCancelAdd G] (a : G) {b c : G}, (b + a = c + a) = (b = c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Exists.choose_spec",
   "Set",
   "Singleton.singleton",
   "And.right",
   "Membership.mem",
   "Submodule.span",
   "Exists.choose",
   "Subtype.val"],
  "name": "SphericallyCompleteSpace.rooij_lemma_4_4_T._proof_3",
  "constType":
  "‚àÄ {ùïú : Type u_2} [inst : NontriviallyNormedField ùïú] {E : Type u_1} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {D : Submodule ùïú E} {a : E} (M : ‚Ü•(D + ùïú ‚àô a)) (this : ‚àÉ y ‚àà D, ‚àÉ z ‚àà ùïú ‚àô a, y + z = ‚ÜëM),\n  ‚àÉ z ‚àà ùïú ‚àô a, this.choose + z = ‚ÜëM",
  "constCategory": "Theorem"},
 {"references":
  ["Isometry.injective",
   "Set",
   "Membership.mem",
   "Equiv.ofInjective",
   "Set.range",
   "Set.Elem",
   "Isometry"],
  "name": "Isometry.isometryEquivOnRange",
  "constType":
  "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    [inst : EMetricSpace Œ±] ‚Üí [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí {f : Œ± ‚Üí Œ≤} ‚Üí Isometry f ‚Üí Œ± ‚âÉ·µ¢ ‚Üë(Set.range f)",
  "constCategory": "Definition"},
 {"references":
  ["HDiv.hDiv",
   "id",
   "Eq.mpr",
   "Mathlib.Tactic.FieldSimp.NF.eval",
   "Mathlib.Tactic.FieldSimp.NF",
   "congrArg"],
  "name": "Mathlib.Tactic.FieldSimp.NF.div_eq_eval",
  "constType":
  "‚àÄ {M : Type u_1} [inst : GroupWithZero M] {l‚ÇÅ l‚ÇÇ l : Mathlib.Tactic.FieldSimp.NF M} {x‚ÇÅ x‚ÇÇ : M},\n  x‚ÇÅ = l‚ÇÅ.eval ‚Üí x‚ÇÇ = l‚ÇÇ.eval ‚Üí l‚ÇÅ.eval / l‚ÇÇ.eval = l.eval ‚Üí x‚ÇÅ / x‚ÇÇ = l.eval",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Lean.Omega.Constraint.isImpossible.match_1", "Decidable.decide"],
  "name": "Lean.Omega.Constraint.isImpossible",
  "constType": "Omega.Constraint ‚Üí Bool",
  "constCategory": "Definition"},
 {"references": ["Classical.choose"],
  "name": "Exists.choose",
  "constType": "{Œ± : Sort u_1} ‚Üí {p : Œ± ‚Üí Prop} ‚Üí (‚àÉ a, p a) ‚Üí Œ±",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Monotone",
   "Iff.mpr",
   "LE.le",
   "monotone_iff_forall_lt",
   "LT.lt.le",
   "StrictMono"],
  "name": "StrictMono.monotone",
  "constType":
  "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PartialOrder Œ±] [inst_1 : Preorder Œ≤] {f : Œ± ‚Üí Œ≤}, StrictMono f ‚Üí Monotone f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Or.casesOn",
  "constType":
  "‚àÄ {a b : Prop} {motive : a ‚à® b ‚Üí Prop} (t : a ‚à® b), (‚àÄ (h : a), motive ‚ãØ) ‚Üí (‚àÄ (h : b), motive ‚ãØ) ‚Üí motive t",
  "constCategory": "Definition"},
 {"references": ["LT.lt"],
  "name": "StrictAnti",
  "constType":
  "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [Preorder Œ±] ‚Üí [Preorder Œ≤] ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.Prod.0.Prod.exists.match_1_3",
   "_private.Init.Data.Prod.0.Prod.exists.match_1_1"],
  "name": "Prod.exists",
  "constType":
  "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {p : Œ± √ó Œ≤ ‚Üí Prop}, (‚àÉ x, p x) ‚Üî ‚àÉ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["max_comm", "Max.max", "LE.le", "max_eq_left"],
  "name": "max_eq_right",
  "constType":
  "‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí max a b = b",
  "constCategory": "Theorem"},
 {"references":
  ["SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_5",
   "SphericallyCompleteSpace.imm_ext_in_sph_comp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_1",
   "PreLp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_2",
   "HasQuotient.Quotient",
   "Set",
   "lp",
   "SphericallyCompleteSpace.SphericalCompletion._proof_3",
   "Membership.mem",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_3",
   "SphericallyCompleteSpace.c‚ÇÄ",
   "Exists.choose",
   "DFunLike.coe",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_6",
   "SphericallyCompleteSpace.SphericalCompletion._proof_5",
   "SphericallyCompleteSpace.sphericallyCompleteExtension",
   "SphericallyCompleteSpace.SphericalCompletion",
   "ENNReal",
   "Maximal",
   "RingHom.id",
   "Top.top",
   "SphericallyCompleteSpace.SphericalCompletionEmbedding._proof_1",
   "SphericallyCompleteSpace.SphericalCompletion._proof_4"],
  "name": "SphericallyCompleteSpace.SphericalCompletionEmbedding",
  "constType":
  "(ùïú : Type u_1) ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    (E : Type u) ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          [inst_3 : IsUltrametricDist E] ‚Üí E ‚Üí‚Çó·µ¢[ùïú] SphericallyCompleteSpace.SphericalCompletion ùïú E",
  "constCategory": "Definition"}]