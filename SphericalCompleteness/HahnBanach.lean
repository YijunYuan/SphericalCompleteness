import SphericalCompleteness.VectorSpace

namespace SphericalCompleteness

lemma lemma_4_4_codim_1
(ğ•œ : Type*) [NontriviallyNormedField ğ•œ]
(E : Type*) [NormedAddCommGroup E] [IsUltrametricDist E] [NormedSpace ğ•œ E]
(D : Submodule ğ•œ E)
(a : E) (ha1 : a âˆ‰ D) (ha2 : D + Submodule.span ğ•œ {a} = âŠ¤)
(F : Type*) [NormedAddCommGroup F] [IsUltrametricDist F]
[NormedSpace ğ•œ F] [SphericallyCompleteSpace F]
(S : D â†’L[ğ•œ] F) (ğ’° : Set (E â†’L[ğ•œ] F)) (hğ’° : ğ’°.Nonempty)
(Îµ : â†‘ğ’° â†’ â„)
(hÎµ1 : âˆ€ T : â†‘ğ’°, 0 < Îµ T)
(hÎµ2 : âˆ€ U V : â†‘ğ’°, â€–U.val - V.valâ€– â‰¤ max (Îµ U) (Îµ V))
(hÎµ3 : âˆ€ U : â†‘ğ’°, âˆ€ x : D, â€–S x - U.val xâ€– â‰¤ Îµ U * â€–xâ€–)
:
âˆƒ (T : E â†’L[ğ•œ] F), (âˆ€ x : D, T x = S x) âˆ§ (âˆ€ U : â†‘ğ’°, â€–T - U.valâ€– â‰¤ Îµ U)
 := sorry


@[ext]
structure PartialExtension (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]
(E : Type*) [NormedAddCommGroup E] [IsUltrametricDist E] [NormedSpace ğ•œ E]
{D : Submodule ğ•œ E}
(F : Type*) [NormedAddCommGroup F] [IsUltrametricDist F]
[NormedSpace ğ•œ F] [SphericallyCompleteSpace F]
(S : D â†’L[ğ•œ] F) (ğ’° : Set (E â†’L[ğ•œ] F)) (hğ’° : ğ’°.Nonempty)
(Îµ : â†‘ğ’° â†’ â„) where
  M : Submodule ğ•œ E
  hDM : D â‰¤ M
  T : M â†’L[ğ•œ] F
  hT : âˆ€ x : D, T âŸ¨x, hDM x.propâŸ© = S x
  hU : âˆ€ U : â†‘ğ’°, âˆ€ x : M, â€–T x- U.val xâ€– â‰¤ (Îµ U) * â€–xâ€–

instance pene (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]
(E : Type*) [NormedAddCommGroup E] [IsUltrametricDist E] [NormedSpace ğ•œ E]
{D : Submodule ğ•œ E}
(F : Type*) [NormedAddCommGroup F] [IsUltrametricDist F]
[NormedSpace ğ•œ F] [SphericallyCompleteSpace F]
(S : D â†’L[ğ•œ] F) (ğ’° : Set (E â†’L[ğ•œ] F)) (hğ’° : ğ’°.Nonempty)
(Îµ : â†‘ğ’° â†’ â„)
(hÎµ3 : âˆ€ U : â†‘ğ’°, âˆ€ x : D, â€–S x - U.val xâ€– â‰¤ Îµ U * â€–xâ€–)
: Nonempty (PartialExtension ğ•œ E F S ğ’° hğ’° Îµ) :=
  Nonempty.intro { M := D, hDM := fun â¦ƒxâ¦„ a â†¦ a, T := S, hT := by simp, hU := hÎµ3 }

instance (ğ•œ : Type*) [NontriviallyNormedField ğ•œ]
(E : Type*) [NormedAddCommGroup E] [IsUltrametricDist E] [NormedSpace ğ•œ E]
{D : Submodule ğ•œ E}
(F : Type*) [NormedAddCommGroup F] [IsUltrametricDist F]
[NormedSpace ğ•œ F] [SphericallyCompleteSpace F]
(S : D â†’L[ğ•œ] F) (ğ’° : Set (E â†’L[ğ•œ] F)) (hğ’° : ğ’°.Nonempty)
(Îµ : â†‘ğ’° â†’ â„)
: PartialOrder (PartialExtension ğ•œ E F S ğ’° hğ’° Îµ) where
  le a b := âˆƒ hab : a.M â‰¤ b.M , âˆ€ x : a.M, b.T âŸ¨x.val, hab x.propâŸ© = a.T x
  le_refl a := by
    use fun â¦ƒxâ¦„ a â†¦ a
    simp only [Subtype.coe_eta, implies_true]
  le_trans a b c := by
    rintro âŸ¨hab, habTâŸ© âŸ¨hbc, hbcTâŸ©
    use fun â¦ƒxâ¦„ a â†¦ hbc (hab a)
    intro x
    specialize habT x
    specialize hbcT âŸ¨x.val, hab x.propâŸ©
    rw [hbcT, habT]
  le_antisymm a b:= by
    rintro âŸ¨hab, habTâŸ© âŸ¨hba, hbaTâŸ©
    refine PartialExtension.ext ?_ ?_
    Â· exact Submodule.ext fun x â†¦ { mp := fun a_1 â†¦ hab a_1, mpr := fun a_1 â†¦ hba a_1 }
    Â· have : a.M = b.M :=
        by rw [Submodule.ext fun x â†¦ { mp := fun a_1 â†¦ hab a_1, mpr := fun a_1 â†¦ hba a_1 }]
      cases a; cases b
      subst this
      simp only [heq_eq_eq]
      ext z
      rw [â† habT]


lemma lemma_4_4
(ğ•œ : Type*) [NontriviallyNormedField ğ•œ]
{E : Type*} [NormedAddCommGroup E] [IsUltrametricDist E] [NormedSpace ğ•œ E]
{D : Submodule ğ•œ E}
{F : Type*} [NormedAddCommGroup F] [IsUltrametricDist F]
[NormedSpace ğ•œ F] [SphericallyCompleteSpace F]
{S : D â†’L[ğ•œ] F} {ğ’° : Set (E â†’L[ğ•œ] F)} (hğ’° : ğ’°.Nonempty)
(Îµ : â†‘ğ’° â†’ â„)
(hÎµ1 : âˆ€ T : â†‘ğ’°, 0 < Îµ T)
(hÎµ2 : âˆ€ U V : â†‘ğ’°, â€–U.val - V.valâ€– â‰¤ max (Îµ U) (Îµ V))
(hÎµ3 : âˆ€ U : â†‘ğ’°, âˆ€ x : D, â€–S x - U.val xâ€– â‰¤ Îµ U * â€–xâ€–)
:
âˆƒ (T : E â†’L[ğ•œ] F), (âˆ€ x : D, T x = S x) âˆ§ (âˆ€ U : â†‘ğ’°, â€–T - U.valâ€– â‰¤ Îµ U)
 := by
  have := @zorn_le_nonempty (PartialExtension ğ•œ E F S ğ’° hğ’° Îµ) _ (pene ğ•œ E F S ğ’° hğ’° Îµ hÎµ3
    ) (by
    intro P hP hhP
    let Mmax := Submodule.span ğ•œ (â‹ƒ (p : P), (p.val.M : Set E))
    #check @IsLinearMap.mk' ğ•œ Mmax F _ _ _ _ _
    use {M := Mmax
         hDM := by
          unfold Mmax
          intro z hz
          exact Submodule.mem_span_of_mem <| Set.mem_iUnion_of_mem
            (Classical.indefiniteDescription (Membership.mem P) hhP) <| hhP.some.hDM hz
         T := by
          #check @ContinuousLinearMap.mk ğ•œ ğ•œ _ _ (RingHom.id ğ•œ) â†¥Mmax _ _ F _ _ _ _
          sorry
         hT := sorry
         hU := sorry, }
    sorry
  )
  rcases this with âŸ¨T, hTâŸ©
  have : T.M = âŠ¤ := by
    by_contra hc
    have : T.M < âŠ¤ := by exact Ne.lt_top' fun a â†¦ hc (id (Eq.symm a))
    rcases Set.exists_of_ssubset this with âŸ¨a, haâŸ©
    --have := lemma_4_4_codim_1 ğ•œ E T.M a ha.2
    sorry
  let f := this â–¸ T.T

  sorry


end SphericalCompleteness

#check StrongDual
